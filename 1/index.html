<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fine-tuning CodeLlama-7B for Fortran Code Generation</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.3/zephyr/bootstrap.min.css"
      integrity="sha512-CWXb9sx63+REyEBV/cte+dE1hSsYpJifb57KkqAXjsN3gZQt6phZt7e5RhgZrUbaNfCdtdpcqDZtuTEB+D3q2Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/fortran.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/cpp.min.js"></script>
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
      integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
      crossorigin="anonymous"></script>
  </head>
  <body>
    
<div class="container">
  <div class="row">
    <div class="col d-flex justify-content-between align-items-center">
      <h2>Two Sum</h2>
      <div>
        <a href="/" class="btn btn-outline-primary me-2">
          üè†
        </a>
        <a
          href="/2609/"
          class="btn btn-outline-secondary me-2">
          ‚¨ÖÔ∏è
        </a>
        <a
          href="/9/"
          class="btn btn-outline-secondary">
          ‚û°Ô∏è
        </a>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col">
      <div class="leetcode-problem-content card">
        <div class="card-body">
          <p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>
<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>
<p>You can return the answer in any order.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> nums = [2,7,11,15], target = 9
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> nums = [3,2,4], target = 6
<strong>Output:</strong> [1,2]</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> nums = [3,3], target = 6
<strong>Output:</strong> [0,1]</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>Only one valid answer exists.</strong></li>
</ul>
<p><strong>Follow-up:</strong> Can you come up with an algorithm that is less than <code>O(n2)</code> time complexity?</p>
          <hr />
          <span class="fst-italic">
            Note: This problem is from
            <a
              href="https://leetcode.com/problems/two-sum/description/">LeetCode</a>.
          </span>
        </div>
      </div>
      <style>
        .leetcode-problem-content {
          max-height: 200px;
          overflow-y: auto;
        }
      </style>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="our-model-tab"
            data-bs-toggle="tab"
            data-bs-target="#our-model-tab-pane"
            type="button"
            role="tab"
            aria-controls="our-model-tab-pane"
            aria-selected="true">
            ü¶æ Our model
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="our-model-tab-pane"
          role="tabpanel"
          aria-labelledby="our-model-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-success"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚úÖ
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-success"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font_emoji">
                    ‚úÖ
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-success"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚úÖ
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">program main
    implicit none

    integer, parameter :: n = 4
    integer, dimension(n) :: nums = [2, 7, 11, 15]
    integer :: target = 9
    integer, dimension(2) :: indices

    call solve(nums, target, indices)

    write (*, '(A, I0, A, I0)') 'Indices: ', indices(1), ', ', indices(2)

contains

    subroutine solve(nums, target, indices)
        implicit none
        integer, dimension(:), intent(in) :: nums
        integer, intent(in) :: target
        integer, dimension(:), intent(out) :: indices
        integer :: i, j

        do i = 1, size(nums) - 1
            do j = i + 1, size(nums)
                if (nums(i) + nums(j) == target) then
                    indices(1) = i
                    indices(2) = j
                    return
                end if
            end do
        end do
    end subroutine solve

end program main</code></pre>

          
          <div class="alert alert-info" role="alert">
            <strong>stdout</strong>
            <pre>Indices: 1, 2
</pre>
          </div>
           
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="codellama-tab"
            data-bs-toggle="tab"
            data-bs-target="#codellama-tab-pane"
            type="button"
            role="tab"
            aria-controls="codellama-tab-pane"
            aria-selected="true">
            ü¶ô CodeLlama-7B
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="python-tab"
            data-bs-toggle="tab"
            data-bs-target="#python-tab-pane"
            type="button"
            role="tab"
            aria-controls="python-tab-pane"
            aria-selected="false">
            üêç Python
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="cpp-tab"
            data-bs-toggle="tab"
            data-bs-target="#cpp-tab-pane"
            type="button"
            role="tab"
            aria-controls="cpp-tab-pane"
            aria-selected="false">
            ü§† C++
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="codellama-tab-pane"
          role="tabpanel"
          aria-labelledby="codellama-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">module solve_two_sum
implicit none
contains

function two_sum(nums, target) result(indices)
! Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
! You may assume that each input would have exactly one solution, and you may not use the same element twice.
! You can return the answer in any order.
!
! Example 1:
! Input: nums = [2,7,11,15], target = 9
! Output: [0,1]
! Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
!
! Example 2:
! Input: nums = [3,2,4], target = 6
! Output: [1,2]
!
! Example 3:
! Input: nums = [3,3], target = 6
! Output: [0,1]
!
! Constraints:
! 2 <= nums.length <= 104
! -109 <= nums[i] <= 109
! -109 <= target <= 109
! Only one valid answer exists.
!
! Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?

integer, intent(in) :: nums(:), target
integer :: indices(2)

! Initialize the indices to -1 to indicate that they have not been found yet
indices = -1

! Loop through the array and find the first number that is equal to the target - nums(i)
do i = 1, size(nums)
    if (nums(i) == target - nums(i)) then
        ! If the first number is found, set the indices to the current index and the previous index
        indices = [i, i - 1]
        exit
    end if
end do

end function two_sum

end module solve_two_sum

program test_two_sum
use solve_two_sum, only: two_sum
implicit none

! Test case 1:
! Given nums = [2, 7, 11, 15], target = 9,
! return [0, 1].
integer, parameter :: nums1(4) = [2, 7, 11, 15]
integer, parameter :: target1 = 9
integer :: indices1(2)

! Test case 2:
! Given nums = [3, 2, 4], target = 6,
! return [1, 2].
integer, parameter :: nums2(3) = [3, 2, 4]
integer, parameter :: target2 = 6
integer :: indices2(2)

! Test case 3:
! Given nums = [3, 3], target = 6,
! return [0, 1].
integer, parameter :: nums3(2) = [3, 3]
integer, parameter :: target3 = 6
integer :: indices3(2)

! Test case 4:
! Given nums = [2, 7, 11, 15], target = 18,
! return [1, 2].
integer, parameter :: nums4(4) = [2, 7, 11, 15]
integer, parameter :: target4 = 18
integer :: indices4(2)

! Test case 5:
! Given nums = [2, 7, 11, 15], target = 100,
! return [0, 0].
integer, parameter :: nums5(4) = [2, 7, 11, 15]
integer, parameter :: target5 = 100
integer :: indices5(2)

! Test the function with the given examples
indices1 = two_sum(nums1, target1)
indices2 = two_sum(nums2, target2)
indices3 = two_sum(nums3, target3)
indices4 = two_sum(nums4, target4)
indices5 = two_sum(nums5, target5)

! Print the results
write (*,*) "Test case 1:", indices1
write (*,
</code></pre>
           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:38:4:

   38 | do i = 1, size(nums)
      |    1
Error: Symbol ‚Äòi‚Äô at (1) has no IMPLICIT type
temp.f95:51:5:

   51 | use solve_two_sum, only: two_sum
      |     1
Fatal Error: Cannot open module file ‚Äòsolve_two_sum.mod‚Äô for reading at (1): No such file or directory
compilation terminated.
</pre>
          </div>
          
        </div>
        <div
          class="tab-pane fade"
          id="python-tab-pane"
          role="tabpanel"
          aria-labelledby="python-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-python">def twoSum(nums, target):
    map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in map:
            return [map[complement], i]
        map[num] = i
    return []
</code></pre>
<p>The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).</p>
<p>This approach has a time complexity of O(n) and a space complexity of O(n) as well.</p>
        </div>
        <div
          class="tab-pane fade"
          id="cpp-tab-pane"
          role="tabpanel"
          aria-labelledby="cpp-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;unordered_map&gt;

std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt;&amp; nums, int target) {
    std::unordered_map&lt;int, int&gt; map;
    for (int i = 0; i &lt; nums.size(); i++) {
        int complement = target - nums[i];
        if (map.find(complement) != map.end()) {
            return {map[complement], i};
        }
        map[nums[i]] = i;
    }
    return {};
}
</code></pre>
<p>The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).</p>
<p>This approach has a time complexity of O(n) and a space complexity of O(n) as well.</p>
        </div>
      </div>
      <style>
        .model-code {
          max-height: 600px;
          overflow-y: auto;
        }

        .font-emoji {
          font-family: emoji;
        }
      </style>
    </div>
  </div>
</div>
<script>
  hljs.addPlugin(new CopyButtonPlugin());
  hljs.highlightAll();
</script>

  </body>
</html>