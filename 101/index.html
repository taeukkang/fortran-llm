<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fine-tuning CodeLlama-7B for Fortran Code Generation</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.3/zephyr/bootstrap.min.css"
      integrity="sha512-CWXb9sx63+REyEBV/cte+dE1hSsYpJifb57KkqAXjsN3gZQt6phZt7e5RhgZrUbaNfCdtdpcqDZtuTEB+D3q2Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/fortran.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/cpp.min.js"></script>
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
      integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
      crossorigin="anonymous"></script>
  </head>
  <body>
    
<div class="container">
  <div class="row">
    <div class="col d-flex justify-content-between align-items-center">
      <h2>Symmetric Tree</h2>
      <div>
        <a href="/" class="btn btn-outline-primary me-2">
          üè†
        </a>
        <a
          href="/100/"
          class="btn btn-outline-secondary me-2">
          ‚¨ÖÔ∏è
        </a>
        <a
          href="/104/"
          class="btn btn-outline-secondary">
          ‚û°Ô∏è
        </a>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col">
      <div class="leetcode-problem-content card">
        <div class="card-body">
          <p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> root = [1,2,2,3,4,4,3]
<strong>Output:</strong> true</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> root = [1,2,2,null,3,null,3]
<strong>Output:</strong> false</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>Follow up:</strong> Could you solve it both recursively and iteratively?</p>
          <hr />
          <span class="fst-italic">
            Note: This problem is from
            <a
              href="https://leetcode.com/problems/symmetric-tree/description/">LeetCode</a>.
          </span>
        </div>
      </div>
      <style>
        .leetcode-problem-content {
          max-height: 200px;
          overflow-y: auto;
        }
      </style>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="our-model-tab"
            data-bs-toggle="tab"
            data-bs-target="#our-model-tab-pane"
            type="button"
            role="tab"
            aria-controls="our-model-tab-pane"
            aria-selected="true">
            ü¶æ Our model
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="our-model-tab-pane"
          role="tabpanel"
          aria-labelledby="our-model-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font_emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">program main
    use, intrinsic :: iso_fortran_env, only : error_unit, output_unit
    implicit none
    integer, parameter :: unit_in = input_unit, unit_out = output_unit
    type(tree_node), pointer :: root
    logical :: result

    call read_tree(unit=unit_in, root=root)
    result = check_mirror(root)
    write (unit=output_unit, fmt='(L1)') result

contains

    function check_mirror(root) result(result)
        class(tree_node), pointer, intent(in) :: root
        logical :: result
        class(tree_node), pointer :: left, right

        if (.not. associated(root)) then
            result = .true.
            return
        end if

        left => root%left
        right => root%right

        ! Check if left subtree is a mirror of right subtree
        if (associated(left)) then
            result = check_mirror(left)
            if (.not. result) return
        else if (associated(right)) then
            result = .false.
            return
        end if

        ! Check if right subtree is a mirror of left subtree
        if (associated(right)) then
            result = check_mirror(right)
            if (.not. result) return
        else if (associated(left)) then
            result = .false.
            return
        end if

        ! If we reach this point, both subtrees are mirrors of each other
        result = .true.

    end function check_mirror

    subroutine read_tree(unit, root)
        integer, intent(in) :: unit
        type(tree_node), pointer, intent(out) :: root
        integer :: value

        read (unit=unit, fmt=*) value
        if (value == -1) then
            nullify(root)
        else
            allocate(root)
            root%val = value
            call read_tree(unit, root%left)
            call read_tree(unit, root%right)
        end if

    end subroutine read_tree

end program main

type :: tree_node
    integer :: val
    class(tree_node), pointer :: left => null(), right => null()
end type tree_node</code></pre>

           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:4:46:

    4 |     integer, parameter :: unit_in = input_unit, unit_out = output_unit
      |                                              1
Error: Symbol ‚Äòinput_unit‚Äô at (1) has no IMPLICIT type; did you mean ‚Äòoutput_unit‚Äô?
temp.f95:5:20:

    5 |     type(tree_node), pointer :: root
      |                    1
Error: Derived type ‚Äòtree_node‚Äô at (1) is being used before it is defined
temp.f95:15:25:

   15 |         class(tree_node), pointer, intent(in) :: root
      |                         1
Error: Derived type ‚Äòtree_node‚Äô at (1) is being used before it is defined
temp.f95:17:25:

   17 |         class(tree_node), pointer :: left, right
      |                         1
Error: Derived type ‚Äòtree_node‚Äô at (1) is being used before it is defined
temp.f95:24:22:

   24 |         left => root%left
      |                      1
Error: Symbol ‚Äòroot‚Äô at (1) has no IMPLICIT type
temp.f95:25:23:

   25 |         right => root%right
      |                       1
Error: Symbol ‚Äòroot‚Äô at (1) has no IMPLICIT type
temp.f95:52:24:

   52 |         type(tree_node), pointer, intent(out) :: root
      |                        1
Error: Derived type ‚Äòtree_node‚Äô at (1) is being used before it is defined
temp.f95:59:21:

   59 |             allocate(root)
      |                     1
Error: Allocate-object at (1) is neither a data pointer nor an allocatable variable
temp.f95:60:18:

   60 |             root%val = value
      |                  1
Error: Symbol ‚Äòroot‚Äô at (1) has no IMPLICIT type
temp.f95:61:39:

   61 |             call read_tree(unit, root%left)
      |                                       1
Error: Symbol ‚Äòroot‚Äô at (1) has no IMPLICIT type
temp.f95:62:39:

   62 |             call read_tree(unit, root%right)
      |                                       1
Error: Symbol ‚Äòroot‚Äô at (1) has no IMPLICIT type
temp.f95:1:12:

    1 | program main
      |            1
......
   69 | type :: tree_node
      |                 2
Error: Two main PROGRAMs at (1) and (2)
</pre>
          </div>
          
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="codellama-tab"
            data-bs-toggle="tab"
            data-bs-target="#codellama-tab-pane"
            type="button"
            role="tab"
            aria-controls="codellama-tab-pane"
            aria-selected="true">
            ü¶ô CodeLlama-7B
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="python-tab"
            data-bs-toggle="tab"
            data-bs-target="#python-tab-pane"
            type="button"
            role="tab"
            aria-controls="python-tab-pane"
            aria-selected="false">
            üêç Python
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="cpp-tab"
            data-bs-toggle="tab"
            data-bs-target="#cpp-tab-pane"
            type="button"
            role="tab"
            aria-controls="cpp-tab-pane"
            aria-selected="false">
            ü§† C++
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="codellama-tab-pane"
          role="tabpanel"
          aria-labelledby="codellama-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">module BinaryTree
    implicit none
    private
    public :: Node, is_mirror

    type :: Node
        integer :: val
        type(Node), pointer :: left => null()
        type(Node), pointer :: right => null()
    end type Node

contains

    function is_mirror(root) result(is_mirrored)
        type(Node), pointer, intent(in) :: root
        logical :: is_mirrored

        is_mirrored = is_mirror_recursive(root)
    end function is_mirror

    recursive function is_mirror_recursive(root) result(is_mirrored)
        type(Node), pointer, intent(in) :: root
        logical :: is_mirrored

        if (.not. associated(root)) then
            is_mirrored = .true.
            return
        end if

        is_mirrored = (root%val == root%left%val) .and. (root%val == root%right%val) .and. &
            is_mirror_recursive(root%left) .and. is_mirror_recursive(root%right)
    end function is_mirror_recursive
end module BinaryTree

program main
    use BinaryTree
    implicit none

    type(Node), pointer :: root
    logical :: is_mirrored

    ! Example 1
    root => Node(val=1, left=Node(val=2, left=Node(val=2), right=Node(val=3)), &
        right=Node(val=4, left=Node(val=4), right=Node(val=3)))
    is_mirrored = is_mirror(root)
    write (*,*) "Example 1: ", is_mirrored

    ! Example 2
    root => Node(val=1, left=Node(val=2, left=Node(val=2), right=Node(val=3)), &
        right=Node(val=4, left=Node(val=4), right=Node(val=3)))
    is_mirrored = is_mirror(root)
    write (*,*) "Example 2: ", is_mirrored
end program main
</code></pre>
           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:43:46:

   43 |     root => Node(val=1, left=Node(val=2, left=Node(val=2), right=Node(val=3)), &
      |                                              1
Error: The element in the structure constructor at (1), for pointer component ‚Äòleft‚Äô should be a POINTER or a TARGET
temp.f95:43:65:

   43 |     root => Node(val=1, left=Node(val=2, left=Node(val=2), right=Node(val=3)), &
      |                                                                 1
Error: The element in the structure constructor at (1), for pointer component ‚Äòright‚Äô should be a POINTER or a TARGET
temp.f95:49:46:

   49 |     root => Node(val=1, left=Node(val=2, left=Node(val=2), right=Node(val=3)), &
      |                                              1
Error: The element in the structure constructor at (1), for pointer component ‚Äòleft‚Äô should be a POINTER or a TARGET
temp.f95:49:65:

   49 |     root => Node(val=1, left=Node(val=2, left=Node(val=2), right=Node(val=3)), &
      |                                                                 1
Error: The element in the structure constructor at (1), for pointer component ‚Äòright‚Äô should be a POINTER or a TARGET
</pre>
          </div>
          
        </div>
        <div
          class="tab-pane fade"
          id="python-tab-pane"
          role="tabpanel"
          aria-labelledby="python-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-python">def isSymmetric(root):
    return checkSymmetry(root, root)

def checkSymmetry(node1, node2):
    if not node1 and not node2:
        return True
    if not node1 or not node2:
        return False
    return (node1.val == node2.val) and checkSymmetry(node1.right, node2.left) and checkSymmetry(node1.left, node2.right)
</code></pre>
<p>The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.</p>
<p>The function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.</p>
<p>The recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.</p>
        </div>
        <div
          class="tab-pane fade"
          id="cpp-tab-pane"
          role="tabpanel"
          aria-labelledby="cpp-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-cpp">bool isSymmetric(TreeNode* root) {
    return checkSymmetry(root, root);
}

bool checkSymmetry(TreeNode* node1, TreeNode* node2) {
    if (!node1 &amp;&amp; !node2) return true;
    if (!node1 || !node2) return false;
    return (node1-&gt;val == node2-&gt;val) &amp;&amp; checkSymmetry(node1-&gt;right, node2-&gt;left) &amp;&amp; checkSymmetry(node1-&gt;left, node2-&gt;right);
}
</code></pre>
<p>The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.</p>
<p>The function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.</p>
<p>The recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.</p>
        </div>
      </div>
      <style>
        .model-code {
          max-height: 600px;
          overflow-y: auto;
        }

        .font-emoji {
          font-family: emoji;
        }
      </style>
    </div>
  </div>
</div>
<script>
  hljs.addPlugin(new CopyButtonPlugin());
  hljs.highlightAll();
</script>

  </body>
</html>