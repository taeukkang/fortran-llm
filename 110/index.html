<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fine-tuning CodeLlama-7B for Fortran Code Generation</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.3/zephyr/bootstrap.min.css"
      integrity="sha512-CWXb9sx63+REyEBV/cte+dE1hSsYpJifb57KkqAXjsN3gZQt6phZt7e5RhgZrUbaNfCdtdpcqDZtuTEB+D3q2Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/fortran.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/cpp.min.js"></script>
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
      integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
      crossorigin="anonymous"></script>
  </head>
  <body>
    
<div class="container">
  <div class="row">
    <div class="col d-flex justify-content-between align-items-center">
      <h2>Balanced Binary Tree</h2>
      <div>
        <a href="/" class="btn btn-outline-primary me-2">
          üè†
        </a>
        <a
          href="/108/"
          class="btn btn-outline-secondary me-2">
          ‚¨ÖÔ∏è
        </a>
        <a
          href="/111/"
          class="btn btn-outline-secondary">
          ‚û°Ô∏è
        </a>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col">
      <div class="leetcode-problem-content card">
        <div class="card-body">
          <p>Given a binary tree, determine if it is <strong>height-balanced</strong>.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> true</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> root = [1,2,2,3,3,null,null,4,4]
<strong>Output:</strong> false</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> root = []
<strong>Output:</strong> true</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
          <hr />
          <span class="fst-italic">
            Note: This problem is from
            <a
              href="https://leetcode.com/problems/balanced-binary-tree/description/">LeetCode</a>.
          </span>
        </div>
      </div>
      <style>
        .leetcode-problem-content {
          max-height: 200px;
          overflow-y: auto;
        }
      </style>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="our-model-tab"
            data-bs-toggle="tab"
            data-bs-target="#our-model-tab-pane"
            type="button"
            role="tab"
            aria-controls="our-model-tab-pane"
            aria-selected="true">
            ü¶æ Our model
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="our-model-tab-pane"
          role="tabpanel"
          aria-labelledby="our-model-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font_emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">program main
    ! Solves the problem: Given a binary tree, determine if it is height-balanced.
    implicit none

    type :: node_t
        integer :: val
        type(node_t), pointer :: left => null(), right => null()
    end type

    type(node_t), target :: root

    call solve(root)

contains

    function is_height_balanced(root) result(is_balanced)
        ! Determines if the given binary tree is height-balanced.
        implicit none
        class(node_t), intent(in) :: root
        logical :: is_balanced
        integer :: depth

        is_balanced = .true.
        depth = 0
        call check_depth(root, depth, is_balanced)
    end function

    subroutine check_depth(root, depth, is_balanced)
        ! Recursive function to check the depth of the given binary tree.
        implicit none
        class(node_t), intent(in) :: root
        integer, intent(inout) :: depth
        logical, intent(inout) :: is_balanced

        if (associated(root%left)) then
            call check_depth(root%left, depth + 1, is_balanced)
        end if
        if (associated(root%right)) then
            call check_depth(root%right, depth + 1, is_balanced)
        end if

        if (abs(depth - get_depth(root%left)) > 1) then
            is_balanced = .false.
        end if
    end subroutine

    function get_depth(root) result(depth)
        ! Returns the depth of the given binary tree.
        implicit none
        class(node_t), intent(in) :: root
        integer :: depth

        if (.not. associated(root)) then
            depth = 0
        else
            depth = max(get_depth(root%left), get_depth(root%right)) + 1
        end if
    end function

    subroutine solve(root)
        ! Runs the solution on the given binary tree.
        implicit none
        type(node_t), intent(inout) :: root

        write (*, '(L1)') is_height_balanced(root)
    end subroutine
end program</code></pre>

           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:53:29:

   53 |         if (.not. associated(root)) then
      |                             1
Error: ‚Äòpointer‚Äô argument of ‚Äòassociated‚Äô intrinsic at (1) must be a POINTER
temp.f95:56:24:

   56 |             depth = max(get_depth(root%left), get_depth(root%right)) + 1
      |                        1
Error: Function ‚Äòget_depth‚Äô at (1) cannot be called recursively, as it is not RECURSIVE
temp.f95:36:63:

   36 |             call check_depth(root%left, depth + 1, is_balanced)
      |                                                               1
Error: SUBROUTINE ‚Äòcheck_depth‚Äô at (1) cannot be called recursively, as it is not RECURSIVE
temp.f95:36:40:

   36 |             call check_depth(root%left, depth + 1, is_balanced)
      |                                        1
Error: Non-variable expression in variable definition context (actual argument to INTENT = OUT/INOUT) at (1)
temp.f95:39:64:

   39 |             call check_depth(root%right, depth + 1, is_balanced)
      |                                                                1
Error: SUBROUTINE ‚Äòcheck_depth‚Äô at (1) cannot be called recursively, as it is not RECURSIVE
temp.f95:39:41:

   39 |             call check_depth(root%right, depth + 1, is_balanced)
      |                                         1
Error: Non-variable expression in variable definition context (actual argument to INTENT = OUT/INOUT) at (1)
</pre>
          </div>
          
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="codellama-tab"
            data-bs-toggle="tab"
            data-bs-target="#codellama-tab-pane"
            type="button"
            role="tab"
            aria-controls="codellama-tab-pane"
            aria-selected="true">
            ü¶ô CodeLlama-7B
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="python-tab"
            data-bs-toggle="tab"
            data-bs-target="#python-tab-pane"
            type="button"
            role="tab"
            aria-controls="python-tab-pane"
            aria-selected="false">
            üêç Python
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="cpp-tab"
            data-bs-toggle="tab"
            data-bs-target="#cpp-tab-pane"
            type="button"
            role="tab"
            aria-controls="cpp-tab-pane"
            aria-selected="false">
            ü§† C++
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="codellama-tab-pane"
          role="tabpanel"
          aria-labelledby="codellama-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">module height_balanced_binary_tree

implicit none

contains

function is_height_balanced(root) result(is_balanced)

    type(node), pointer, intent(in) :: root
    logical :: is_balanced

    is_balanced = is_height_balanced_recursive(root)

end function is_height_balanced

recursive function is_height_balanced_recursive(root) result(is_balanced)

    type(node), pointer, intent(in) :: root
    logical :: is_balanced

    integer :: height_left, height_right

    if (.not. associated(root)) then
        is_balanced = .true.
        return
    end if

    is_balanced = .false.

    height_left = height(root%left)
    height_right = height(root%right)

    if (abs(height_left - height_right) <= 1) then
        is_balanced = is_height_balanced_recursive(root%left) .and. &
                      is_height_balanced_recursive(root%right)
    end if

end function is_height_balanced_recursive

function height(root) result(height)

    type(node), pointer, intent(in) :: root
    integer :: height

    if (.not. associated(root)) then
        height = 0
        return
    end if

    height = max(height(root%left), height(root%right)) + 1

end function height

type node
    integer :: val
    type(node), pointer :: left
    type(node), pointer :: right
end type node

end module height_balanced_binary_tree

program test

use height_balanced_binary_tree
implicit none

type(node), pointer :: root

! Example 1
root = create_node(3)
root%left = create_node(9)
root%right = create_node(20)
root%left%left = create_node(15)
root%left%right = create_node(7)

if (is_height_balanced(root)) then
    write (*,*) "Example 1: Height-balanced"
else
    write (*,*) "Example 1: Not height-balanced"
end if

! Example 2
root = create_node(1)
root%left = create_node(2)
root%right = create_node(2)
root%left%left = create_node(3)
root%left%right = create_node(3)
root%right%left = create_node(4)
root%right%right = create_node(4)

if (is_height_balanced(root)) then
    write (*,*) "Example 2: Height-balanced"
else
    write (*,*) "Example 2: Not height-balanced"
end if

! Example 3
root = null()

if (is_height_balanced(root)) then
    write (*,*) "Example 3: Height-balanced"
else
    write (*,*) "Example 3: Not height-balanced"
end if

contains

function create_node(val) result(node)

    integer, intent(in) :: val
    type(node) :: node

    allocate(node)
    node%val = val
    node%left = null()
    node%right = null()

end function create_node

end program test
</code></pre>
           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:9:15:

    9 |     type(node), pointer, intent(in) :: root
      |               1
Error: Derived type ‚Äònode‚Äô at (1) is being used before it is defined
temp.f95:18:15:

   18 |     type(node), pointer, intent(in) :: root
      |               1
Error: Derived type ‚Äònode‚Äô at (1) is being used before it is defined
temp.f95:30:31:

   30 |     height_left = height(root%left)
      |                               1
Error: Symbol ‚Äòroot‚Äô at (1) has no IMPLICIT type
temp.f95:31:32:

   31 |     height_right = height(root%right)
      |                                1
Error: Symbol ‚Äòroot‚Äô at (1) has no IMPLICIT type
temp.f95:34:57:

   34 |         is_balanced = is_height_balanced_recursive(root%left) .and. &
      |                                                         1
Error: Symbol ‚Äòroot‚Äô at (1) has no IMPLICIT type
temp.f95:40:36:

   40 | function height(root) result(height)
      |                                    1
Error: RESULT variable at (1) must be different than function name
temp.f95:42:15:

   42 |     type(node), pointer, intent(in) :: root
      |               1
Error: Derived type ‚Äònode‚Äô at (1) is being used before it is defined
temp.f95:43:21:

   43 |     integer :: height
      |                     1
Error: Symbol ‚Äòheight‚Äô at (1) has already been host associated
temp.f95:45:36:

   45 |     if (.not. associated(root)) then
      |                                    1
Error: Unexpected block IF statement in CONTAINS section at (1)
temp.f95:46:15:

   46 |         height = 0
      |               1
Error: Symbol ‚Äòheight‚Äô at (1) has already been host associated
temp.f95:47:14:

   47 |         return
      |              1
Error: Unexpected RETURN statement in CONTAINS section at (1)
temp.f95:48:7:

   48 |     end if
      |       1
Error: Expecting END MODULE statement at (1)
temp.f95:50:11:

   50 |     height = max(height(root%left), height(root%right)) + 1
      |           1
Error: Symbol ‚Äòheight‚Äô at (1) has already been host associated
temp.f95:52:3:

   52 | end function height
      |   1
Error: Expecting END MODULE statement at (1)
temp.f95:54:9:

   54 | type node
      |         1
Error: Unexpected derived type declaration statement in CONTAINS section at (1)
temp.f95:55:18:

   55 |     integer :: val
      |                  1
Error: Unexpected data declaration statement in CONTAINS section at (1)
temp.f95:56:15:

   56 |     type(node), pointer :: left
      |               1
Error: Derived type ‚Äònode‚Äô at (1) is being used before it is defined
temp.f95:57:15:

   57 |     type(node), pointer :: right
      |               1
Error: Derived type ‚Äònode‚Äô at (1) is being used before it is defined
temp.f95:58:3:

   58 | end type node
      |   1
Error: Expecting END MODULE statement at (1)
temp.f95:7:32:

    7 | function is_height_balanced(root) result(is_balanced)
      |                                1
Error: Symbol ‚Äòroot‚Äô at (1) has no IMPLICIT type
temp.f95:16:52:

   16 | recursive function is_height_balanced_recursive(root) result(is_balanced)
      |                                                    1
Error: Symbol ‚Äòroot‚Äô at (1) has no IMPLICIT type
temp.f95:64:5:

   64 | use height_balanced_binary_tree
      |     1
Fatal Error: Cannot open module file ‚Äòheight_balanced_binary_tree.mod‚Äô for reading at (1): No such file or directory
compilation terminated.
</pre>
          </div>
          
        </div>
        <div
          class="tab-pane fade"
          id="python-tab-pane"
          role="tabpanel"
          aria-labelledby="python-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def getHeight(node):
    if not node:
        return 0
    left_height = getHeight(node.left)
    right_height = getHeight(node.right)
    if left_height == -1 or right_height == -1 or abs(left_height - right_height) &gt; 1:
        return -1
    return 1 + max(left_height, right_height)

def isBalanced(root):
    return getHeight(root) != -1
</code></pre>
<pre><code>The algorithm is based on the depth-first search. In this algorithm, we define a helper function named `getHeight` which will return the height of the given subtree if it is balanced, otherwise, it will return -1.
</code></pre>
<p>The <code>getHeight</code> function works as follows:
1. If the current node is null, return 0 (base case).
2. Call the function recursively for the left subtree (leftHeight) and the right subtree (rightHeight).
3. If either of the subtrees is not balanced or the height difference is greater than 1, return -1.
4. Otherwise, return the maximum height of the left and right subtrees incremented by 1.</p>
<p>The main function <code>isBalanced</code> just calls the <code>getHeight</code> function and checks whether its result is -1 or not. If it is not -1, the binary tree is height-balanced, otherwise, it is not balanced.</p>
        </div>
        <div
          class="tab-pane fade"
          id="cpp-tab-pane"
          role="tabpanel"
          aria-labelledby="cpp-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-cpp">struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
};

int getHeight(TreeNode* node) {
    if (!node) return 0;
    int leftHeight = getHeight(node-&gt;left);
    int rightHeight = getHeight(node-&gt;right);
    if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1)
        return -1;
    return 1 + max(leftHeight, rightHeight);
}

bool isBalanced(TreeNode* root) {
    return getHeight(root) != -1;
}
</code></pre>
<pre><code>The algorithm is based on the depth-first search. In this algorithm, we define a helper function named `getHeight` which will return the height of the given subtree if it is balanced, otherwise, it will return -1.
</code></pre>
<p>The <code>getHeight</code> function works as follows:
1. If the current node is null, return 0 (base case).
2. Call the function recursively for the left subtree (leftHeight) and the right subtree (rightHeight).
3. If either of the subtrees is not balanced or the height difference is greater than 1, return -1.
4. Otherwise, return the maximum height of the left and right subtrees incremented by 1.</p>
<p>The main function <code>isBalanced</code> just calls the <code>getHeight</code> function and checks whether its result is -1 or not. If it is not -1, the binary tree is height-balanced, otherwise, it is not balanced.</p>
        </div>
      </div>
      <style>
        .model-code {
          max-height: 600px;
          overflow-y: auto;
        }

        .font-emoji {
          font-family: emoji;
        }
      </style>
    </div>
  </div>
</div>
<script>
  hljs.addPlugin(new CopyButtonPlugin());
  hljs.highlightAll();
</script>

  </body>
</html>