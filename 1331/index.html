<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fine-tuning CodeLlama-7B for Fortran Code Generation</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.3/zephyr/bootstrap.min.css"
      integrity="sha512-CWXb9sx63+REyEBV/cte+dE1hSsYpJifb57KkqAXjsN3gZQt6phZt7e5RhgZrUbaNfCdtdpcqDZtuTEB+D3q2Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/fortran.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/cpp.min.js"></script>
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
      integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
      crossorigin="anonymous"></script>
  </head>
  <body>
    
<div class="container">
  <div class="row">
    <div class="col d-flex justify-content-between align-items-center">
      <h2>Rank Transform of an Array</h2>
      <div>
        <a href="/" class="btn btn-outline-primary me-2">
          üè†
        </a>
        <a
          href="/1323/"
          class="btn btn-outline-secondary me-2">
          ‚¨ÖÔ∏è
        </a>
        <a
          href="/1332/"
          class="btn btn-outline-secondary">
          ‚û°Ô∏è
        </a>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col">
      <div class="leetcode-problem-content card">
        <div class="card-body">
          <p>Given an array of integers <code>arr</code>, replace each element with its rank.</p>
<p>The rank represents how large the element is. The rank has the following rules:</p>
<ul>
<li>Rank is an integer starting from 1.</li>
<li>The larger the element, the larger the rank. If two elements are equal, their rank must be the same.</li>
<li>Rank should be as small as possible.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> arr = [40,10,20,30]
<strong>Output:</strong> [4,1,2,3]
<strong>Explanation</strong>: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> arr = [100,100,100]
<strong>Output:</strong> [1,1,1]
<strong>Explanation</strong>: Same elements share the same rank.</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> arr = [37,12,28,9,100,56,80,5,12]
<strong>Output:</strong> [5,3,4,2,8,6,7,1,3]</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= arr.length &lt;= 105</code></li>
<li><code>-109 &lt;= arr[i] &lt;= 109</code></li>
</ul>
<p>- Every time you are in a cell you will collect all the gold in that cell. - From your position, you can walk one step to the left, right, up, or down. - You can't visit the same cell more than once. - Never visit a cell with 0 gold. - You can start and stop collecting gold from any position in the grid that has some gold.</p>
          <hr />
          <span class="fst-italic">
            Note: This problem is from
            <a
              href="https://leetcode.com/problems/rank-transform-of-an-array/description/">LeetCode</a>.
          </span>
        </div>
      </div>
      <style>
        .leetcode-problem-content {
          max-height: 200px;
          overflow-y: auto;
        }
      </style>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="our-model-tab"
            data-bs-toggle="tab"
            data-bs-target="#our-model-tab-pane"
            type="button"
            role="tab"
            aria-controls="our-model-tab-pane"
            aria-selected="true">
            ü¶æ Our model
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="our-model-tab-pane"
          role="tabpanel"
          aria-labelledby="our-model-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-success"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚úÖ
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-success"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font_emoji">
                    ‚úÖ
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">program main
    implicit none

    integer, parameter :: n = 4
    integer :: arr(n) = [40, 10, 20, 30]
    integer :: i, j, k

    do i = 1, n
        write (*, '(I0)') arr(i)
    end do

end program main</code></pre>

          
          <div class="alert alert-info" role="alert">
            <strong>stdout</strong>
            <pre>40
10
20
30
</pre>
          </div>
           
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="codellama-tab"
            data-bs-toggle="tab"
            data-bs-target="#codellama-tab-pane"
            type="button"
            role="tab"
            aria-controls="codellama-tab-pane"
            aria-selected="true">
            ü¶ô CodeLlama-7B
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="python-tab"
            data-bs-toggle="tab"
            data-bs-target="#python-tab-pane"
            type="button"
            role="tab"
            aria-controls="python-tab-pane"
            aria-selected="false">
            üêç Python
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="cpp-tab"
            data-bs-toggle="tab"
            data-bs-target="#cpp-tab-pane"
            type="button"
            role="tab"
            aria-controls="cpp-tab-pane"
            aria-selected="false">
            ü§† C++
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="codellama-tab-pane"
          role="tabpanel"
          aria-labelledby="codellama-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">! This program solves the problem of replacing each element in an array with its rank.
! The rank represents how large the element is. The rank has the following rules:
!
! * Rank is an integer starting from 1.
! * The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
! * Rank should be as small as possible.

program rank_elements

implicit none

! Declare variables
integer, allocatable :: arr(:)
integer :: i, j, n

! Read the number of elements in the array
read(*,*) n

! Allocate memory for the array
allocate(arr(n))

! Read the elements of the array
do i = 1, n
    read(*,*) arr(i)
end do

! Sort the array in descending order
call sort(arr)

! Initialize the rank of each element
do i = 1, n
    arr(i) = i
end do

! Update the rank of each element based on its position in the sorted array
do i = 1, n
    do j = i + 1, n
        if (arr(i) == arr(j)) then
            arr(j) = arr(i)
        end if
    end do
end do

! Print the ranks of the elements
do i = 1, n
    write(*,*) arr(i)
end do

end program rank_elements

! This subroutine sorts an array in descending order using the quicksort algorithm.
subroutine sort(arr)

implicit none

! Declare variables
integer, intent(inout) :: arr(:)
integer :: pivot, left, right, temp

! Base case: If the length of the array is 1 or less, it is already sorted
if (size(arr) <= 1) then
    return
end if

! Choose a pivot element
pivot = arr(1)

! Partition the array around the pivot
left = 1
right = size(arr)

do while (left < right)
    do while (arr(right) >= pivot)
        right = right - 1
    end do
    do while (arr(left) < pivot)
        left = left + 1
    end do
    if (left < right) then
        temp = arr(left)
        arr(left) = arr(right)
        arr(right) = temp
    end if
end do

! Recursively sort the subarrays
call sort(arr(1:left-1))
call sort(arr(right+1:))

end subroutine sort
</code></pre>
           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:87:24:

   87 | call sort(arr(1:left-1))
      |                        1
Error: SUBROUTINE ‚Äòsort‚Äô at (1) cannot be called recursively, as it is not RECURSIVE
temp.f95:88:24:

   88 | call sort(arr(right+1:))
      |                        1
Error: SUBROUTINE ‚Äòsort‚Äô at (1) cannot be called recursively, as it is not RECURSIVE
temp.f95:28:9:

   28 | call sort(arr)
      |         1
Error: Explicit interface required for ‚Äòsort‚Äô at (1): assumed-shape argument
</pre>
          </div>
          
        </div>
        <div
          class="tab-pane fade"
          id="python-tab-pane"
          role="tabpanel"
          aria-labelledby="python-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-python">def getMaximumGold(grid):
    m, n, max_gold = len(grid), len(grid[0]), 0

    def getMaximumGoldHelper(x, y):
        if not (0 &lt;= x &lt; m) or not (0 &lt;= y &lt; n) or grid[x][y] == 0:
            return 0

        original_gold = grid[x][y]
        grid[x][y] = 0

        max_gold = 0
        max_gold = max(max_gold, getMaximumGoldHelper(x + 1, y))
        max_gold = max(max_gold, getMaximumGoldHelper(x - 1, y))
        max_gold = max(max_gold, getMaximumGoldHelper(x, y + 1))
        max_gold = max(max_gold, getMaximumGoldHelper(x, y - 1))

        grid[x][y] = original_gold
        return max_gold + original_gold

    for i in range(m):
        for j in range(n):
            if grid[i][j] != 0:
                max_gold = max(max_gold, getMaximumGoldHelper(i, j))

    return max_gold
</code></pre>
<pre><code>We use a depth-first search (DFS) algorithm to calculate the maximum gold that can be collected in one DFS run, which we do starting from each cell with gold. This algorithm keeps track of the visited cells by changing the gold amount to 0 in the original grid temporarily as part of its recursive computations. As we go through the grid, we store the maximum gold found so far to be returned at the end. Note that the algorithm itself is relatively simple, but the actual implementation varies slightly between languages.
</code></pre>
        </div>
        <div
          class="tab-pane fade"
          id="cpp-tab-pane"
          role="tabpanel"
          aria-labelledby="cpp-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

int getMaximumGoldHelper(vector&lt;vector&lt;int&gt;&gt; &amp;grid, int x, int y, int m, int n) {
    if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || grid[x][y] == 0) return 0;

    int originalGold = grid[x][y];
    grid[x][y] = 0;

    int maxGold = 0;
    maxGold = max(maxGold, getMaximumGoldHelper(grid, x + 1, y, m, n));
    maxGold = max(maxGold, getMaximumGoldHelper(grid, x - 1, y, m, n));
    maxGold = max(maxGold, getMaximumGoldHelper(grid, x, y + 1, m, n));
    maxGold = max(maxGold, getMaximumGoldHelper(grid, x, y - 1, m, n));

    grid[x][y] = originalGold;
    return maxGold + originalGold;
}

int getMaximumGold(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int m = grid.size(), n = grid[0].size(), maxGold = 0;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (grid[i][j] != 0) {
                maxGold = max(maxGold, getMaximumGoldHelper(grid, i, j, m, n));
            }
        }
    }
    return maxGold;
}
</code></pre>
<pre><code>We use a depth-first search (DFS) algorithm to calculate the maximum gold that can be collected in one DFS run, which we do starting from each cell with gold. This algorithm keeps track of the visited cells by changing the gold amount to 0 in the original grid temporarily as part of its recursive computations. As we go through the grid, we store the maximum gold found so far to be returned at the end. Note that the algorithm itself is relatively simple, but the actual implementation varies slightly between languages.
</code></pre>
        </div>
      </div>
      <style>
        .model-code {
          max-height: 600px;
          overflow-y: auto;
        }

        .font-emoji {
          font-family: emoji;
        }
      </style>
    </div>
  </div>
</div>
<script>
  hljs.addPlugin(new CopyButtonPlugin());
  hljs.highlightAll();
</script>

  </body>
</html>