<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fine-tuning CodeLlama-7B for Fortran Code Generation</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.3/zephyr/bootstrap.min.css"
      integrity="sha512-CWXb9sx63+REyEBV/cte+dE1hSsYpJifb57KkqAXjsN3gZQt6phZt7e5RhgZrUbaNfCdtdpcqDZtuTEB+D3q2Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/fortran.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/cpp.min.js"></script>
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
      integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
      crossorigin="anonymous"></script>
  </head>
  <body>
    
<div class="container">
  <div class="row">
    <div class="col d-flex justify-content-between align-items-center">
      <h2>Reformat The String</h2>
      <div>
        <a href="/fortran-llm/" class="btn btn-outline-primary me-2">
          üè†
        </a>
        <a
          href="/fortran-llm/1413/"
          class="btn btn-outline-secondary me-2">
          ‚¨ÖÔ∏è
        </a>
        <a
          href="/fortran-llm/1422/"
          class="btn btn-outline-secondary">
          ‚û°Ô∏è
        </a>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col">
      <div class="leetcode-problem-content card">
        <div class="card-body">
          <p>You are given an alphanumeric string <code>s</code>. (<strong>Alphanumeric string</strong> is a string consisting of lowercase English letters and digits).</p>
<p>You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.</p>
<p>Return <em>the reformatted string</em> or return <strong>an empty string</strong> if it is impossible to reformat the string.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> s =  "a0b1c2 "
<strong>Output:</strong>  "0a1b2c "
<strong>Explanation:</strong> No two adjacent characters have the same type in  "0a1b2c ".  "a0b1c2 ",  "0a1b2c ",  "0c2a1b " are also valid permutations.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> s =  "leetcode "
<strong>Output:</strong>  " "
<strong>Explanation:</strong>  "leetcode " has only characters so we cannot separate them by digits.</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> s =  "1229857369 "
<strong>Output:</strong>  " "
<strong>Explanation:</strong>  "1229857369 " has only digits so we cannot separate them by characters.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> consists of only lowercase English letters and/or digits.</li>
</ul>
          <hr />
          <span class="fst-italic">
            Note: This problem is from
            <a
              href="https://leetcode.com/problems/reformat-the-string/description/">LeetCode</a>.
          </span>
        </div>
      </div>
      <style>
        .leetcode-problem-content {
          max-height: 200px;
          overflow-y: auto;
        }
      </style>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="our-model-tab"
            data-bs-toggle="tab"
            data-bs-target="#our-model-tab-pane"
            type="button"
            role="tab"
            aria-controls="our-model-tab-pane"
            aria-selected="true">
            ü¶æ Our model
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="our-model-tab-pane"
          role="tabpanel"
          aria-labelledby="our-model-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font_emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">program main
    implicit none

    character(len=:), allocatable :: s
    character(len=:), allocatable :: result

    s = "a0b1c2"
    write(*,*) "Input: ", s
    result = solve(s)
    write(*,*) "Output: ", result

    s = "leetcode"
    write(*,*) "Input: ", s
    result = solve(s)
    write(*,*) "Output: ", result

    s = "1229857369"
    write(*,*) "Input: ", s
    result = solve(s)
    write(*,*) "Output: ", result

contains

    function solve(s) result(result)
        implicit none
        character(len=*), intent(in) :: s
        character(len=:), allocatable :: result
        integer :: i, j

        allocate(character(len=size(s)) :: result)
        do i = 1, size(s)
            select case (s(i:i))
                case ("0":"9")
                    result(i:i) = s(i:i)
                case default
                    do j = 1, size(s)
                        if (s(j:j) == s(i:i)) exit
                    end do
                    if (j > size(s)) then
                        deallocate(result)
                        result = ""
                        return
                    end if
                    result(i:i) = s(j:j)
            end select
        end do
    end function solve

end program main</code></pre>

           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:30:36:

   30 |         allocate(character(len=size(s)) :: result)
      |                                    1
Error: ‚Äòarray‚Äô argument of ‚Äòsize‚Äô intrinsic at (1) must be an array
temp.f95:36:35:

   36 |                     do j = 1, size(s)
      |                                   1
Error: ‚Äòarray‚Äô argument of ‚Äòsize‚Äô intrinsic at (1) must be an array
temp.f95:39:33:

   39 |                     if (j > size(s)) then
      |                                 1
Error: ‚Äòarray‚Äô argument of ‚Äòsize‚Äô intrinsic at (1) must be an array
temp.f95:31:23:

   31 |         do i = 1, size(s)
      |                       1
Error: ‚Äòarray‚Äô argument of ‚Äòsize‚Äô intrinsic at (1) must be an array
</pre>
          </div>
          
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="codellama-tab"
            data-bs-toggle="tab"
            data-bs-target="#codellama-tab-pane"
            type="button"
            role="tab"
            aria-controls="codellama-tab-pane"
            aria-selected="true">
            ü¶ô CodeLlama-7B
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="python-tab"
            data-bs-toggle="tab"
            data-bs-target="#python-tab-pane"
            type="button"
            role="tab"
            aria-controls="python-tab-pane"
            aria-selected="false">
            üêç Python
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="cpp-tab"
            data-bs-toggle="tab"
            data-bs-target="#cpp-tab-pane"
            type="button"
            role="tab"
            aria-controls="cpp-tab-pane"
            aria-selected="false">
            ü§† C++
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="codellama-tab-pane"
          role="tabpanel"
          aria-labelledby="codellama-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">program main

implicit none

character(len=500) :: s
character(len=500) :: result
integer :: i, j

! Read input
read(*,*) s

! Initialize result
result = ""

! Check if the string is alphanumeric
if (index(s, "0123456789") == 0 .and. index(s, "abcdefghijklmnopqrstuvwxyz") == 0) then
    write(*,*) ""
    return
end if

! Find the first character that is not a digit or a letter
i = 1
do while (i <= len(s) .and. (s(i:i) >= "0" .and. s(i:i) <= "9" .or. s(i:i) >= "a" .and. s(i:i) <= "z"))
    i = i + 1
end do

! Check if the string is already in the correct format
if (i == len(s) + 1) then
    write(*,*) s
    return
end if

! Find the first character that is a digit or a letter
j = i
do while (j <= len(s) .and. (s(j:j) >= "0" .and. s(j:j) <= "9" .or. s(j:j) >= "a" .and. s(j:j) <= "z"))
    j = j + 1
end do

! Check if the string is already in the correct format
if (j == len(s) + 1) then
    write(*,*) s
    return
end if

! Separate the string into two parts
result = s(i:j-1)
s = s(j:len(s))

! Recursively solve the problem for the remaining string
call solve(s, result)

contains

subroutine solve(s, result)

implicit none

character(len=500) :: s
character(len=500) :: result
integer :: i, j

! Check if the string is alphanumeric
if (index(s, "0123456789") == 0 .and. index(s, "abcdefghijklmnopqrstuvwxyz") == 0) then
    write(*,*) result // s
    return
end if

! Find the first character that is not a digit or a letter
i = 1
do while (i <= len(s) .and. (s(i:i) >= "0" .and. s(i:i) <= "9" .or. s(i:i) >= "a" .and. s(i:i) <= "z"))
    i = i + 1
end do

! Check if the string is already in the correct format
if (i == len(s) + 1) then
    write(*,*) result // s
    return
end if

! Find the first character that is a digit or a letter
j = i
do while (j <= len(s) .and. (s(j:j) >= "0" .and. s(j:j) <= "9" .or. s(j:j) >= "a" .and. s(j:j) <= "z"))
    j = j + 1
end do

! Check if the string is already in the correct format
if (j == len(s) + 1) then
    write(*,*) result // s
    return
end if

! Separate the string into two parts
result = result // s(i:j-1)
s = s(j:len(s))

! Recursively solve the problem for the remaining string
call solve(s, result)

end subroutine solve

end program main
</code></pre>
           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:97:21:

   97 | call solve(s, result)
      |                     1
Error: SUBROUTINE ‚Äòsolve‚Äô at (1) cannot be called recursively, as it is not RECURSIVE
</pre>
          </div>
          
        </div>
        <div
          class="tab-pane fade"
          id="python-tab-pane"
          role="tabpanel"
          aria-labelledby="python-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-python">from collections import deque

def reformat(s: str) -&gt; str:
    letters, digits = deque(), deque()

    for c in s:
        if c.isalpha():
            letters.append(c)
        else:
            digits.append(c)

    if abs(len(letters) - len(digits)) &gt; 1:
        return &quot;&quot;

    result = []
    use_letter = len(letters) &gt; len(digits)

    while letters or digits:
        if use_letter:
            result.append(letters.popleft())
        else:
            result.append(digits.popleft())
        use_letter = not use_letter

    return ''.join(result)
</code></pre>
<p>The algorithm first separates the input string <code>s</code> into two queues, <code>letters</code> and <code>digits</code>. This can be done by iterating through the input string <code>s</code> and checking if each character is a letter or digit. Then it checks if the difference between the number of letters and digits is greater than 1. If so, it returns an empty string as it is impossible to reformat the string with no two adjacent characters having the same type.</p>
<p>If the difference is not greater than 1, the algorithm initializes an empty result string or list. Then, it checks which type (letter or digit) has more elements, and iterates through the queues, alternating between types (letters and digits) and inserting the next character of the current type into the result. This ensures no two adjacent characters have the same type. Finally, the algorithm returns the result in the appropriate type (string or list, depending on the language).</p>
<p>The algorithm's complexity is O(n), where n is the length of the input string <code>s</code>.</p>
        </div>
        <div
          class="tab-pane fade"
          id="cpp-tab-pane"
          role="tabpanel"
          aria-labelledby="cpp-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;queue&gt;

std::string reformat(std::string s) {
    std::queue&lt;char&gt; letters, digits;

    for (char c : s) {
        if (isalpha(c)) letters.push(c);
        else digits.push(c);
    }

    if (abs((int)(letters.size() - digits.size())) &gt; 1) return &quot;&quot;;

    std::string result = &quot;&quot;;
    bool use_letter = letters.size() &gt; digits.size();

    while (!letters.empty() || !digits.empty()) {
        if (use_letter) {
            result += letters.front();
            letters.pop();
        } else {
            result += digits.front();
            digits.pop();
        }
        use_letter = !use_letter;
    }

    return result;
}
</code></pre>
<p>The algorithm first separates the input string <code>s</code> into two queues, <code>letters</code> and <code>digits</code>. This can be done by iterating through the input string <code>s</code> and checking if each character is a letter or digit. Then it checks if the difference between the number of letters and digits is greater than 1. If so, it returns an empty string as it is impossible to reformat the string with no two adjacent characters having the same type.</p>
<p>If the difference is not greater than 1, the algorithm initializes an empty result string or list. Then, it checks which type (letter or digit) has more elements, and iterates through the queues, alternating between types (letters and digits) and inserting the next character of the current type into the result. This ensures no two adjacent characters have the same type. Finally, the algorithm returns the result in the appropriate type (string or list, depending on the language).</p>
<p>The algorithm's complexity is O(n), where n is the length of the input string <code>s</code>.</p>
        </div>
      </div>
      <style>
        .model-code {
          max-height: 600px;
          overflow-y: auto;
        }

        .font-emoji {
          font-family: emoji;
        }
      </style>
    </div>
  </div>
</div>
<script>
  hljs.addPlugin(new CopyButtonPlugin());
  hljs.highlightAll();
</script>

  </body>
</html>