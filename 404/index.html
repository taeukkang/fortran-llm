<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fine-tuning CodeLlama-7B for Fortran Code Generation</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.3/zephyr/bootstrap.min.css"
      integrity="sha512-CWXb9sx63+REyEBV/cte+dE1hSsYpJifb57KkqAXjsN3gZQt6phZt7e5RhgZrUbaNfCdtdpcqDZtuTEB+D3q2Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/fortran.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/cpp.min.js"></script>
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
      integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
      crossorigin="anonymous"></script>
  </head>
  <body>
    
<div class="container">
  <div class="row">
    <div class="col d-flex justify-content-between align-items-center">
      <h2>Sum of Left Leaves</h2>
      <div>
        <a href="/" class="btn btn-outline-primary me-2">
          üè†
        </a>
        <a
          href="/401/"
          class="btn btn-outline-secondary me-2">
          ‚¨ÖÔ∏è
        </a>
        <a
          href="/405/"
          class="btn btn-outline-secondary">
          ‚û°Ô∏è
        </a>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col">
      <div class="leetcode-problem-content card">
        <div class="card-body">
          <p>Given the <code>root</code> of a binary tree, return <em>the sum of all left leaves.</em></p>
<p>A <strong>leaf</strong> is a node with no children. A <strong>left leaf</strong> is a leaf that is the left child of another node.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 24
<strong>Explanation:</strong> There are two left leaves in the binary tree, with values 9 and 15 respectively.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> root = [1]
<strong>Output:</strong> 0</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
          <hr />
          <span class="fst-italic">
            Note: This problem is from
            <a
              href="https://leetcode.com/problems/sum-of-left-leaves/description/">LeetCode</a>.
          </span>
        </div>
      </div>
      <style>
        .leetcode-problem-content {
          max-height: 200px;
          overflow-y: auto;
        }
      </style>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="our-model-tab"
            data-bs-toggle="tab"
            data-bs-target="#our-model-tab-pane"
            type="button"
            role="tab"
            aria-controls="our-model-tab-pane"
            aria-selected="true">
            ü¶æ Our model
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="our-model-tab-pane"
          role="tabpanel"
          aria-labelledby="our-model-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font_emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">program main
    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64
    implicit none
    integer, parameter :: unit_in = 10, unit_out = 20
    character(len=20) :: filename
    type :: TreeNode
        real(kind=DP), pointer :: val => null()
        class(TreeNode), pointer :: left => null(), right => null()
    end type TreeNode
    type(TreeNode), pointer :: root
    integer :: i, n
    real(kind=DP) :: sum

    ! read input from file
    open(newunit=unit_in, file='input.txt', status='old', action='read')
    read(unit=unit_in, fmt=*) filename
    close(unit=unit_in)

    ! read data from file
    open(newunit=unit_in, file=filename, status='old', action='read')
    read(unit=unit_in, fmt=*) n
    allocate(root)
    call read_tree(unit_in, root)
    close(unit=unit_in)

    ! solve problem
    sum = sum_of_left_leaves(root)

    ! write output to file
    open(newunit=unit_out, file='output.txt', status='replace', action='write')
    write(unit=unit_out, fmt='(F0.2)') sum
    close(unit=unit_out)

contains

    subroutine read_tree(unit_in, root)
        integer, intent(in) :: unit_in
        class(TreeNode), pointer :: root
        integer :: i
        logical :: done

        done = .false.
        do while (.not. done)
            read(unit=unit_in, fmt=*, iostat=i)
            if (i /= 0) then
                done = .true.
            else
                allocate(root%left)
                call read_tree(unit_in, root%left)
                allocate(root%right)
                call read_tree(unit_in, root%right)
            end if
        end do
    end subroutine read_tree

    function sum_of_left_leaves(root) result(sum)
        class(TreeNode), pointer :: root
        real(kind=DP) :: sum
        integer :: i

        if (associated(root)) then
            if (associated(root%left)) then
                if (.not. associated(root%left%left) .and. &
                    .not. associated(root%left%right)) then
                    sum = sum + root%left%val
                else
                    sum = sum + sum_of_left_leaves(root%left)
                end if
            end if
            sum = sum + sum_of_left_leaves(root%right)
        end if
    end function sum_of_left_leaves

end program main</code></pre>

           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:67:50:

   67 |                     sum = sum + sum_of_left_leaves(root%left)
      |                                                  1
Error: Function ‚Äòsum_of_left_leaves‚Äô at (1) cannot be called recursively, as it is not RECURSIVE
temp.f95:70:42:

   70 |             sum = sum + sum_of_left_leaves(root%right)
      |                                          1
Error: Function ‚Äòsum_of_left_leaves‚Äô at (1) cannot be called recursively, as it is not RECURSIVE
temp.f95:49:50:

   49 |                 call read_tree(unit_in, root%left)
      |                                                  1
Error: SUBROUTINE ‚Äòread_tree‚Äô at (1) cannot be called recursively, as it is not RECURSIVE
temp.f95:51:51:

   51 |                 call read_tree(unit_in, root%right)
      |                                                   1
Error: SUBROUTINE ‚Äòread_tree‚Äô at (1) cannot be called recursively, as it is not RECURSIVE
temp.f95:15:17:

   15 |     open(newunit=unit_in, file='input.txt', status='old', action='read')
      |                 1
Error: Named constant ‚Äòunit_in‚Äô in variable definition context (NEWUNIT tag) at (1)
temp.f95:20:17:

   20 |     open(newunit=unit_in, file=filename, status='old', action='read')
      |                 1
Error: Named constant ‚Äòunit_in‚Äô in variable definition context (NEWUNIT tag) at (1)
temp.f95:23:28:

   23 |     call read_tree(unit_in, root)
      |                            1
Error: Actual argument to ‚Äòroot‚Äô at (1) must be polymorphic
temp.f95:27:29:

   27 |     sum = sum_of_left_leaves(root)
      |                             1
Error: Actual argument to ‚Äòroot‚Äô at (1) must be polymorphic
temp.f95:30:17:

   30 |     open(newunit=unit_out, file='output.txt', status='replace', action='write')
      |                 1
Error: Named constant ‚Äòunit_out‚Äô in variable definition context (NEWUNIT tag) at (1)
</pre>
          </div>
          
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="codellama-tab"
            data-bs-toggle="tab"
            data-bs-target="#codellama-tab-pane"
            type="button"
            role="tab"
            aria-controls="codellama-tab-pane"
            aria-selected="true">
            ü¶ô CodeLlama-7B
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="python-tab"
            data-bs-toggle="tab"
            data-bs-target="#python-tab-pane"
            type="button"
            role="tab"
            aria-controls="python-tab-pane"
            aria-selected="false">
            üêç Python
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="cpp-tab"
            data-bs-toggle="tab"
            data-bs-target="#cpp-tab-pane"
            type="button"
            role="tab"
            aria-controls="cpp-tab-pane"
            aria-selected="false">
            ü§† C++
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="codellama-tab-pane"
          role="tabpanel"
          aria-labelledby="codellama-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">module BinaryTree

    implicit none

    type :: Node
        integer :: val
        type(Node), pointer :: left
        type(Node), pointer :: right
    end type Node

    interface
        function sum_of_left_leaves(root) result(sum)
            type(Node), pointer, intent(in) :: root
            integer :: sum
        end function sum_of_left_leaves
    end interface

end module BinaryTree

program main
    use BinaryTree
    implicit none
    type(Node), pointer :: root
    integer :: sum

    ! Example 1
    root => Node(val=3, left=Node(val=9, left=Node(val=15, left=Node(val=7), right=Node(val=20)), right=Node(val=20)), right=Node(val=15, left=Node(val=7), right=Node(val=20)))
    sum = sum_of_left_leaves(root)
    write (*,*) "Example 1: Sum of left leaves = ", sum

    ! Example 2
    root => Node(val=1, left=Node(val=2, left=Node(val=3), right=Node(val=4)), right=Node(val=2, left=Node(val=3), right=Node(val=4)))
    sum = sum_of_left_leaves(root)
    write (*,*) "Example 2: Sum of left leaves = ", sum

contains

    function sum_of_left_leaves(root) result(sum)
        type(Node), pointer, intent(in) :: root
        integer :: sum
        type(Node), pointer :: current

        sum = 0
        current => root

        do while (associated(current))
            if (associated(current%left)) then
                if (associated(current%left%left) .and. .not. associated(current%left%right)) then
                    sum = sum + current%left%val
                end if
            end if
            current => current%right
        end do

    end function sum_of_left_leaves

end program main
</code></pre>
           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:13:23:

   13 |             type(Node), pointer, intent(in) :: root
      |                       1
Error: Derived type ‚Äònode‚Äô at (1) is being used before it is defined
temp.f95:21:9:

   21 |     use BinaryTree
      |         1
Fatal Error: Cannot open module file ‚Äòbinarytree.mod‚Äô for reading at (1): No such file or directory
compilation terminated.
</pre>
          </div>
          
        </div>
        <div
          class="tab-pane fade"
          id="python-tab-pane"
          role="tabpanel"
          aria-labelledby="python-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def sum_of_left_leaves(root):
    if not root:
        return 0
    left_sum = 0
    if root.left and not root.left.left and not root.left.right:
        left_sum += root.left.val
    return left_sum + sum_of_left_leaves(root.left) + sum_of_left_leaves(root.right)
</code></pre>
<p>The algorithm uses a recursive approach. For every node in the tree, the program checks if the left child is a leaf node by verifying if it exists and if it has no children. If the left child is a leaf, add its value to the sum, and then call the function for both left and right children of the current node. Since the tree can have varying depths, recursion is useful to explore each subtree and accumulate the sum of all left leaves.</p>
        </div>
        <div
          class="tab-pane fade"
          id="cpp-tab-pane"
          role="tabpanel"
          aria-labelledby="cpp-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-cpp">struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

int sumOfLeftLeaves(TreeNode* root) {
    if (!root) return 0;
    int sum = 0;
    if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) sum += root-&gt;left-&gt;val;
    return sum + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);
}
</code></pre>
<p>The algorithm uses a recursive approach. For every node in the tree, the program checks if the left child is a leaf node by verifying if it exists and if it has no children. If the left child is a leaf, add its value to the sum, and then call the function for both left and right children of the current node. Since the tree can have varying depths, recursion is useful to explore each subtree and accumulate the sum of all left leaves.</p>
        </div>
      </div>
      <style>
        .model-code {
          max-height: 600px;
          overflow-y: auto;
        }

        .font-emoji {
          font-family: emoji;
        }
      </style>
    </div>
  </div>
</div>
<script>
  hljs.addPlugin(new CopyButtonPlugin());
  hljs.highlightAll();
</script>

  </body>
</html>