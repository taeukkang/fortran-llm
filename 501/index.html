<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fine-tuning CodeLlama-7B for Fortran Code Generation</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.3/zephyr/bootstrap.min.css"
      integrity="sha512-CWXb9sx63+REyEBV/cte+dE1hSsYpJifb57KkqAXjsN3gZQt6phZt7e5RhgZrUbaNfCdtdpcqDZtuTEB+D3q2Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/fortran.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/cpp.min.js"></script>
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
      integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
      crossorigin="anonymous"></script>
  </head>
  <body>
    
<div class="container">
  <div class="row">
    <div class="col d-flex justify-content-between align-items-center">
      <h2>Find Mode in Binary Search Tree</h2>
      <div>
        <a href="/fortran-llm/" class="btn btn-outline-primary me-2">
          üè†
        </a>
        <a
          href="/fortran-llm/500/"
          class="btn btn-outline-secondary me-2">
          ‚¨ÖÔ∏è
        </a>
        <a
          href="/fortran-llm/504/"
          class="btn btn-outline-secondary">
          ‚û°Ô∏è
        </a>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col">
      <div class="leetcode-problem-content card">
        <div class="card-body">
          <p>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics)">mode(s)</a> (i.e., the most frequently occurred element) in it</em>.</p>
<p>If the tree has more than one mode, return them in <strong>any order</strong>.</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node's key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> root = [1,null,2,2]
<strong>Output:</strong> [2]</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> root = [0]
<strong>Output:</strong> [0]</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
<p><strong>Follow up:</strong> Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p>
          <hr />
          <span class="fst-italic">
            Note: This problem is from
            <a
              href="https://leetcode.com/problems/find-mode-in-binary-search-tree/description/">LeetCode</a>.
          </span>
        </div>
      </div>
      <style>
        .leetcode-problem-content {
          max-height: 200px;
          overflow-y: auto;
        }
      </style>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="our-model-tab"
            data-bs-toggle="tab"
            data-bs-target="#our-model-tab-pane"
            type="button"
            role="tab"
            aria-controls="our-model-tab-pane"
            aria-selected="true">
            ü¶æ Our model
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="our-model-tab-pane"
          role="tabpanel"
          aria-labelledby="our-model-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font_emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">program main
    use modes_mod
    implicit none

    type(bst_node), pointer :: root
    integer :: i
    type(bst_node), allocatable :: example(:)

    allocate(example(3))
    example(1)%key = 1
    example(2)%key = 2
    example(3)%key = 2
    example(1)%left => null()
    example(1)%right => example(2)
    example(2)%left => example(3)
    example(2)%right => null()
    example(3)%left => null()
    example(3)%right => null()

    print '("Example 1:")'
    call solve(root=example(1))
    print '("Example 2:")'
    call solve(root=example(2))

contains

subroutine solve(root)
    type(bst_node), pointer :: root
    type(bst_node), allocatable :: stack(:)
    integer :: top, i
    logical :: found

    allocate(stack(size(root)))
    top = 0
    stack(top+1) => root
    top = top + 1

    do while (top > 0)
        if (associated(stack(top)%left)) then
            stack(top+1) => stack(top)%left
            top = top + 1
        else if (associated(stack(top)%right)) then
            stack(top+1) => stack(top)%right
            top = top + 1
        else
            do while (.not. associated(stack(top)%left))
                deallocate(stack(top)%right)
                top = top - 1
            end do
            stack(top+1) => stack(top)%left
            top = top + 1
        end if
    end do

    allocate(root%data(size(stack)))
    do i = 1, size(stack)
        root%data(i) = stack(i)%key
    end do

end subroutine solve

end program main</code></pre>

           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:2:9:

    2 |     use modes_mod
      |         1
Fatal Error: Cannot open module file ‚Äòmodes_mod.mod‚Äô for reading at (1): No such file or directory
compilation terminated.
</pre>
          </div>
          
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="codellama-tab"
            data-bs-toggle="tab"
            data-bs-target="#codellama-tab-pane"
            type="button"
            role="tab"
            aria-controls="codellama-tab-pane"
            aria-selected="true">
            ü¶ô CodeLlama-7B
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="python-tab"
            data-bs-toggle="tab"
            data-bs-target="#python-tab-pane"
            type="button"
            role="tab"
            aria-controls="python-tab-pane"
            aria-selected="false">
            üêç Python
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="cpp-tab"
            data-bs-toggle="tab"
            data-bs-target="#cpp-tab-pane"
            type="button"
            role="tab"
            aria-controls="cpp-tab-pane"
            aria-selected="false">
            ü§† C++
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="codellama-tab-pane"
          role="tabpanel"
          aria-labelledby="codellama-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">module bst_mod

! Define the node structure
type :: node
    integer :: val
    type(node), pointer :: left
    type(node), pointer :: right
end type

contains

! Define the function to find the mode(s) of a BST
function find_mode(root) result(modes)
    type(node), pointer :: root
    integer, allocatable :: modes(:)
    integer :: count, max_count
    integer :: i

    ! Initialize the count and max_count
    count = 0
    max_count = 0

    ! Loop through the BST and count the frequency of each value
    call count_frequency(root, count, max_count)

    ! Allocate the array to store the modes
    allocate(modes(max_count))

    ! Loop through the BST again and store the modes in the array
    call store_modes(root, modes, count, max_count, 1)

end function

! Define the recursive function to count the frequency of each value in the BST
recursive subroutine count_frequency(root, count, max_count)
    type(node), pointer :: root
    integer :: count, max_count

    ! Base case: if the current node is null, return
    if (.not. associated(root)) return

    ! Increment the count of the current node's value
    count = count + 1

    ! If the current node's value is greater than the max_count, update the max_count
    if (root%val > max_count) max_count = root%val

    ! Recursively count the frequency of the left and right subtrees
    call count_frequency(root%left, count, max_count)
    call count_frequency(root%right, count, max_count)

end subroutine

! Define the recursive function to store the modes in the array
recursive subroutine store_modes(root, modes, count, max_count, index)
    type(node), pointer :: root
    integer, allocatable :: modes(:)
    integer :: count, max_count, index

    ! Base case: if the current node is null, return
    if (.not. associated(root)) return

    ! If the current node's value is equal to the max_count, store it in the array
    if (root%val == max_count) modes(index) = root%val

    ! Recursively store the modes in the left and right subtrees
    call store_modes(root%left, modes, count, max_count, index)
    call store_modes(root%right, modes, count, max_count, index + 1)

end subroutine

end module

program test_bst

use bst_mod

implicit none

! Test case 1: root = [1,null,2,2]
type(node), pointer :: root
integer :: modes(1)

root => new_node(1)
root%left => new_node(2)
root%right => new_node(2)

modes = find_mode(root)

write (*,*) "Test case 1:", modes

! Test case 2: root = [0]
root => new_node(0)

modes = find_mode(root)

write (*,*) "Test case 2:", modes

! Test case 3: root = [1,null,2,null,3,null,4]
root => new_node(1)
root%left => new_node(2)
root%right => new_node(3)
root%right%right => new_node(4)

modes = find_mode(root)

write (*,*) "Test case 3:", modes

! Test case 4: root = [1,null,2,null,3,null,4,null,null,5]
root => new_node(1)
root%left => new_node(2)
root%right => new_node(3)
root%right%right => new_node(4)
root%right%right%right => new_node(5)

modes = find_mode(root)

write (*,*) "Test case 4:", modes

! Test case 5: root
</code></pre>
           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>f951: Error: Unexpected end of file in ‚Äòtemp.f95‚Äô
</pre>
          </div>
          
        </div>
        <div
          class="tab-pane fade"
          id="python-tab-pane"
          role="tabpanel"
          aria-labelledby="python-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-python">def findMode(root):
    def InOrder(node):
        if not node: return
        yield from InOrder(node.left)
        yield node.val
        yield from InOrder(node.right)

    counts = collections.Counter(InOrder(root))
    max_count = max(counts.values(), default=0)
    return [k for k, v in counts.items() if v == max_count]
</code></pre>
<p>The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.</p>
<p>Once the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.</p>
<p>The time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal.</p>
        </div>
        <div
          class="tab-pane fade"
          id="cpp-tab-pane"
          role="tabpanel"
          aria-labelledby="cpp-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-cpp">void InOrder(TreeNode* root, unordered_map&lt;int, int&gt;&amp; frequencies, int&amp; max_frequency) {
    if (!root) return;
    InOrder(root-&gt;left, frequencies, max_frequency);
    frequencies[root-&gt;val]++;
    max_frequency = max(max_frequency, frequencies[root-&gt;val]);
    InOrder(root-&gt;right, frequencies, max_frequency);
}

vector&lt;int&gt; findMode(TreeNode* root) {
    unordered_map&lt;int, int&gt; frequencies;
    int max_frequency = 0;
    InOrder(root, frequencies, max_frequency);
    vector&lt;int&gt; modes;

    for (const auto&amp; freq : frequencies) {
        if (freq.second == max_frequency) modes.push_back(freq.first);
    }

    return modes;
}
</code></pre>
<p>The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.</p>
<p>Once the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.</p>
<p>The time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal.</p>
        </div>
      </div>
      <style>
        .model-code {
          max-height: 600px;
          overflow-y: auto;
        }

        .font-emoji {
          font-family: emoji;
        }
      </style>
    </div>
  </div>
</div>
<script>
  hljs.addPlugin(new CopyButtonPlugin());
  hljs.highlightAll();
</script>

  </body>
</html>