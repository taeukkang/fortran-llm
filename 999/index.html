<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fine-tuning CodeLlama-7B for Fortran Code Generation</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.3/zephyr/bootstrap.min.css"
      integrity="sha512-CWXb9sx63+REyEBV/cte+dE1hSsYpJifb57KkqAXjsN3gZQt6phZt7e5RhgZrUbaNfCdtdpcqDZtuTEB+D3q2Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/fortran.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/cpp.min.js"></script>
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
      integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
      crossorigin="anonymous"></script>
  </head>
  <body>
    
<div class="container">
  <div class="row">
    <div class="col d-flex justify-content-between align-items-center">
      <h2>Available Captures for Rook</h2>
      <div>
        <a href="/fortran-llm/" class="btn btn-outline-primary me-2">
          üè†
        </a>
        <a
          href="/fortran-llm/997/"
          class="btn btn-outline-secondary me-2">
          ‚¨ÖÔ∏è
        </a>
        <a
          href="/fortran-llm/1002/"
          class="btn btn-outline-secondary">
          ‚û°Ô∏è
        </a>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col">
      <div class="leetcode-problem-content card">
        <div class="card-body">
          <p>On an <code>8 x 8</code> chessboard, there is <strong>exactly one</strong> white rook <code>'R'</code> and some number of white bishops <code>'B'</code>, black pawns <code>'p'</code>, and empty squares <code>'.'</code>.</p>
<p>When the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered <strong>attacking</strong> a pawn if the rook can capture the pawn on the rook's turn. The <strong>number of available captures</strong> for the white rook is the number of pawns that the rook is <strong>attacking</strong>.</p>
<p>Return <em>the <strong>number of available captures</strong> for the white rook</em>.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> board = [[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", "p ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", "R ", ". ", ". ", ". ", "p "],[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", "p ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> In this example, the rook is attacking all the pawns.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> board = [[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "],[ ". ", "p ", "p ", "p ", "p ", "p ", ". ", ". "],[ ". ", "p ", "p ", "B ", "p ", "p ", ". ", ". "],[ ". ", "p ", "B ", "R ", "B ", "p ", ". ", ". "],[ ". ", "p ", "p ", "B ", "p ", "p ", ". ", ". "],[ ". ", "p ", "p ", "p ", "p ", "p ", ". ", ". "],[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The bishops are blocking the rook from attacking any of the pawns.</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> board = [[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", "p ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", "p ", ". ", ". ", ". ", ". "],[ "p ", "p ", ". ", "R ", ". ", "p ", "B ", ". "],[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", "B ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", "p ", ". ", ". ", ". ", ". "],[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The rook is attacking the pawns at positions b5, d6, and f5.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>board.length == 8</code></li>
<li><code>board[i].length == 8</code></li>
<li><code>board[i][j]</code> is either <code>'R'</code>, <code>'.'</code>, <code>'B'</code>, or <code>'p'</code></li>
<li>There is exactly one cell with <code>board[i][j] == 'R'</code></li>
</ul>
          <hr />
          <span class="fst-italic">
            Note: This problem is from
            <a
              href="https://leetcode.com/problems/available-captures-for-rook/description/">LeetCode</a>.
          </span>
        </div>
      </div>
      <style>
        .leetcode-problem-content {
          max-height: 200px;
          overflow-y: auto;
        }
      </style>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="our-model-tab"
            data-bs-toggle="tab"
            data-bs-target="#our-model-tab-pane"
            type="button"
            role="tab"
            aria-controls="our-model-tab-pane"
            aria-selected="true">
            ü¶æ Our model
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="our-model-tab-pane"
          role="tabpanel"
          aria-labelledby="our-model-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-success"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚úÖ
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font_emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">program main
    implicit none

    character(len=1) :: board(8,8)
    integer :: i, j, num_captures

    ! read input
    do i = 1, 8
        read(*,*) board(:,i)
    end do

    ! solve problem
    num_captures = count_rook_captures(board)

    ! print output
    write(*,*) num_captures

contains

    function count_rook_captures(board) result(num_captures)
        implicit none
        character(len=1), intent(in) :: board(8,8)
        integer :: i, j, num_captures

        num_captures = 0
        do i = 1, 8
            do j = 1, 8
                if (board(i,j) == 'R') then
                    call count_rook_captures_helper(board, i, j, num_captures)
                end if
            end do
        end do
    end function count_rook_captures

    subroutine count_rook_captures_helper(board, i, j, num_captures)
        implicit none
        character(len=1), intent(in) :: board(8,8)
        integer, intent(in) :: i, j
        integer, intent(out) :: num_captures

        integer :: k, l

        select case (board(i,j))
        case ('R')
            ! north
            k = i - 1
            do while (k >= 1 .and. board(k,j) /= 'B')
                if (board(k,j) == 'p') then
                    num_captures = num_captures + 1
                end if
                k = k - 1
            end do

            ! east
            l = j + 1
            do while (l <= 8 .and. board(i,l) /= 'B')
                if (board(i,l) == 'p') then
                    num_captures = num_captures + 1
                end if
                l = l + 1
            end do

            ! south
            k = i + 1
            do while (k <= 8 .and. board(k,j) /= 'B')
                if (board(k,j) == 'p') then
                    num_captures = num_captures + 1
                end if
                k = k + 1
            end do

            ! west
            l = j - 1
            do while (l >= 1 .and. board(i,l) /= 'B')
                if (board(i,l) == 'p') then
                    num_captures = num_captures + 1
                end if
                l = l - 1
            end do
        end select
    end subroutine count_rook_captures_helper

end program main</code></pre>

           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>At line 9 of file temp.f95 (unit = 5, file = 'stdin')
Fortran runtime error: End of file

Error termination. Backtrace:
#0  0x78dfceae0960 in ???
#1  0x78dfceae14d9 in ???
#2  0x78dfced3517b in ???
#3  0x78dfced2e684 in ???
#4  0x78dfced2f2aa in ???
#5  0x78dfced34b7a in ???
#6  0x585291b9b51a in MAIN__
#7  0x585291b9b6a6 in main
</pre>
          </div>
          
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <ul class="nav nav-underline mb-2" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="codellama-tab"
            data-bs-toggle="tab"
            data-bs-target="#codellama-tab-pane"
            type="button"
            role="tab"
            aria-controls="codellama-tab-pane"
            aria-selected="true">
            ü¶ô CodeLlama-7B
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="python-tab"
            data-bs-toggle="tab"
            data-bs-target="#python-tab-pane"
            type="button"
            role="tab"
            aria-controls="python-tab-pane"
            aria-selected="false">
            üêç Python
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="cpp-tab"
            data-bs-toggle="tab"
            data-bs-target="#cpp-tab-pane"
            type="button"
            role="tab"
            aria-controls="cpp-tab-pane"
            aria-selected="false">
            ü§† C++
          </button>
        </li>
      </ul>
      <div class="tab-content" id="myTabContent">
        <div
          class="tab-pane fade show active"
          id="codellama-tab-pane"
          role="tabpanel"
          aria-labelledby="codellama-tab"
          tabindex="0">
          <div class="row mb-2">
            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Compiled</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Executed</strong>
                </div>
              </div>
            </div>

            <div class="col">
              <div
                class="card border-danger"
                style="border-width: 2px">
                <div class="card-body">
                  <span class="font-emoji">
                    ‚ùå
                  </span>
                  <strong>Correct</strong>
                </div>
              </div>
            </div>
          </div>
          <pre><code class="language-fortran model-code">!include(sort.f90)

program chess_rook

! Declare variables
integer, parameter :: N = 8
integer :: i, j, k, l, m, n, o, p
integer :: num_captures
character(len=1) :: board(N,N)

! Read input board
read(*,*) board

! Initialize num_captures
num_captures = 0

! Loop through rows
do i = 1, N

! Loop through columns
do j = 1, N

! Check if current cell is a white rook
if (board(i,j) == 'R') then

! Initialize variables
k = i
l = j

! Loop until rook reaches edge of board or captures a black pawn
do while (k > 0 .and. l > 0 .and. board(k,l) /= 'p')

! Check if current cell is a white bishop
if (board(k,l) == 'B') then

! Increment num_captures
num_captures = num_captures + 1

! Exit loop
exit

end if

! Decrement k and l
k = k - 1
l = l - 1

end do

! Loop until rook reaches edge of board or captures a black pawn
do while (k < N .and. l < N .and. board(k,l) /= 'p')

! Check if current cell is a white bishop
if (board(k,l) == 'B') then

! Increment num_captures
num_captures = num_captures + 1

! Exit loop
exit

end if

! Increment k and l
k = k + 1
l = l + 1

end do

! Loop until rook reaches edge of board or captures a black pawn
do while (k > 0 .and. l < N .and. board(k,l) /= 'p')

! Check if current cell is a white bishop
if (board(k,l) == 'B') then

! Increment num_captures
num_captures = num_captures + 1

! Exit loop
exit

end if

! Decrement k and l
k = k - 1
l = l + 1

end do

! Loop until rook reaches edge of board or captures a black pawn
do while (k < N .and. l > 0 .and. board(k,l) /= 'p')

! Check if current cell is a white bishop
if (board(k,l) == 'B') then

! Increment num_captures
num_captures = num_captures + 1

! Exit loop
exit

end if

! Increment k and l
k = k + 1
l = l - 1

end do

end do

end do

! Print output
write(*,*) num_captures

end program chess_rook
</code></pre>
           
          <div class="alert alert-danger" role="alert">
            <strong>stderr</strong>
            <pre>temp.f95:7:27:

    7 | integer :: i, j, k, l, m, n, o, p
      |                           1
Error: Symbol ‚Äòn‚Äô at (1) already has basic type of INTEGER
temp.f95:110:3:

  110 | end do
      |   1
Error: Expecting END IF statement at (1)
temp.f95:112:3:

  112 | end do
      |   1
Error: Expecting END IF statement at (1)
temp.f95:117:3:

  117 | end program chess_rook
      |   1
Error: Expecting END IF statement at (1)
f951: Error: Unexpected end of file in ‚Äòtemp.f95‚Äô
</pre>
          </div>
          
        </div>
        <div
          class="tab-pane fade"
          id="python-tab-pane"
          role="tabpanel"
          aria-labelledby="python-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-python">def regionsBySlashes(grid):
    n = len(grid)
    graph = [[0] * (n * 3) for _ in range(n * 3)]

    for i in range(n):
        for j in range(n):
            if grid[i][j] == '/':
                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1
            if grid[i][j] == '\\':
                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1

    regions = 0
    for i in range(n * 3):
        for j in range(n * 3):
            if not graph[i][j]:
                regions += 1
                dfs(graph, i, j)

    return regions

def dfs(graph, i, j):
    n = len(graph)
    if i &lt; 0 or j &lt; 0 or i &gt;= n or j &gt;= n or graph[i][j]:
        return

    graph[i][j] = 1
    dfs(graph, i - 1, j)
    dfs(graph, i + 1, j)
    dfs(graph, i, j - 1)
    dfs(graph, i, j + 1)
</code></pre>
<p>The algorithm for solving this problem is as follows:</p>
<ol>
<li>
<p>Create a graph representation of the n x n grid. The graph will have n * 3 rows and columns. The reason for this size is that we are going to divide the 1 x 1 grid cell with '/', '\', and ' ' into 9 smaller parts, making it easier to identify regions.</p>
</li>
<li>
<p>Loop through the grid and update the corresponding graph cells based on the '/' and '\' characters. For example, if we find '/' in grid[i][j], we update the graph at grid[i<em>3][j</em>3+2], grid[i<em>3+1][j</em>3+1], and grid[i<em>3+2][j</em>3] to 1.</p>
</li>
<li>
<p>Perform Depth-First Search (DFS) in the graph to count the number of regions.</p>
</li>
<li>
<p>Loop through the entire graph which represents the n x n grid. Whenever we find a cell with value 0, we increment the regions count and perform a DFS on that cell.</p>
</li>
<li>
<p>The DFS function will take graph, i, and j as input parameters. It will mark the cell as visited and call itself recursively for its neighboring cells.</p>
</li>
<li>
<p>The DFS function will stop when a cell is 1 or out of bounds.</p>
</li>
<li>
<p>Finally, we return the value of regions as the result. This will be the number of contiguous regions in the grid.</p>
</li>
</ol>
        </div>
        <div
          class="tab-pane fade"
          id="cpp-tab-pane"
          role="tabpanel"
          aria-labelledby="cpp-tab"
          tabindex="0">
          <alert class="alert alert-info d-flex">
            <strong>üåê Data from online sources</strong>
          </alert>
          <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;string&gt;

int regionsBySlashes(std::vector&lt;std::string&gt;&amp; grid) {
    int n = grid.size();
    std::vector&lt;std::vector&lt;int&gt;&gt; graph(n * 3, std::vector&lt;int&gt;(n * 3, 0));

    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (grid[i][j] == '/') {
                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1;
            }
            if (grid[i][j] == '\\') {
                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1;
            }
        }
    }

    int regions = 0;
    for (int i = 0; i &lt; n * 3; ++i) {
        for (int j = 0; j &lt; n * 3; ++j) {
            if (!graph[i][j]) {
                regions++;
                dfs(graph, i, j);
            }
        }
    }

    return regions;
}

void dfs(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; graph, int i, int j) {
    int n = graph.size();
    if (i &lt; 0 || j &lt; 0 || i &gt;= n || j &gt;= n || graph[i][j]) return;

    graph[i][j] = 1;
    dfs(graph, i - 1, j);
    dfs(graph, i + 1, j);
    dfs(graph, i, j - 1);
    dfs(graph, i, j + 1);
}
</code></pre>
<p>The algorithm for solving this problem is as follows:</p>
<ol>
<li>
<p>Create a graph representation of the n x n grid. The graph will have n * 3 rows and columns. The reason for this size is that we are going to divide the 1 x 1 grid cell with '/', '\', and ' ' into 9 smaller parts, making it easier to identify regions.</p>
</li>
<li>
<p>Loop through the grid and update the corresponding graph cells based on the '/' and '\' characters. For example, if we find '/' in grid[i][j], we update the graph at grid[i<em>3][j</em>3+2], grid[i<em>3+1][j</em>3+1], and grid[i<em>3+2][j</em>3] to 1.</p>
</li>
<li>
<p>Perform Depth-First Search (DFS) in the graph to count the number of regions.</p>
</li>
<li>
<p>Loop through the entire graph which represents the n x n grid. Whenever we find a cell with value 0, we increment the regions count and perform a DFS on that cell.</p>
</li>
<li>
<p>The DFS function will take graph, i, and j as input parameters. It will mark the cell as visited and call itself recursively for its neighboring cells.</p>
</li>
<li>
<p>The DFS function will stop when a cell is 1 or out of bounds.</p>
</li>
<li>
<p>Finally, we return the value of regions as the result. This will be the number of contiguous regions in the grid.</p>
</li>
</ol>
        </div>
      </div>
      <style>
        .model-code {
          max-height: 600px;
          overflow-y: auto;
        }

        .font-emoji {
          font-family: emoji;
        }
      </style>
    </div>
  </div>
</div>
<script>
  hljs.addPlugin(new CopyButtonPlugin());
  hljs.highlightAll();
</script>

  </body>
</html>