{
  "1": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums = [2, 7, 11, 15]\n    integer :: target = 9\n    integer, dimension(2) :: indices\n\n    call solve(nums, target, indices)\n\n    write (*, '(A, I0, A, I0)') 'Indices: ', indices(1), ', ', indices(2)\n\ncontains\n\n    subroutine solve(nums, target, indices)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, intent(in) :: target\n        integer, dimension(:), intent(out) :: indices\n        integer :: i, j\n\n        do i = 1, size(nums) - 1\n            do j = i + 1, size(nums)\n                if (nums(i) + nums(j) == target) then\n                    indices(1) = i\n                    indices(2) = j\n                    return\n                end if\n            end do\n        end do\n    end subroutine solve\n\nend program main",
  "9": "program main\n    implicit none\n\n    integer :: x\n    logical :: isPalindrome\n\n    ! Example 1\n    x = 121\n    print '(L1)', isPalindrome(x)\n\n    ! Example 2\n    x = -121\n    print '(L1)', isPalindrome(x)\n\n    ! Example 3\n    x = 10\n    print '(L1)', isPalindrome(x)\n\ncontains\n\n    function isPalindrome(x) result(res)\n        implicit none\n        integer, intent(in) :: x\n        logical :: res\n        integer :: y\n\n        y = x\n        do while (y > 0)\n            if (mod(x, 10) /= mod(y, 10)) then\n                res = .false.\n                return\n            end if\n            x = x / 10\n            y = y / 10\n        end do\n        res = .true.\n    end function isPalindrome\n\nend program main",
  "13": "program main\n    implicit none\n\n    character(len=10), parameter :: I = \"I\", V = \"V\", X = \"X\", L = \"L\", &\n                                     C = \"C\", D = \"D\", M = \"M\"\n    character(len=*) :: s\n    integer :: n\n\n    call get_command_argument(1, s)\n    read(s, *) n\n\n    write(*, \"(A)\", advance=\"no\") decode(n)\n\ncontains\n\n    function decode(n) result(roman)\n        implicit none\n        integer, intent(in) :: n\n        character(len=:), allocatable :: roman\n\n        if (n == 1) then\n            allocate(character(len=1) :: roman)\n            roman = I\n        else if (n == 5) then\n            allocate(character(len=1) :: roman)\n            roman = V\n        else if (n == 10) then\n            allocate(character(len=1) :: roman)\n            roman = X\n        else if (n == 50) then\n            allocate(character(len=1) :: roman)\n            roman = L\n        else if (n == 100) then\n            allocate(character(len=1) :: roman)\n            roman = C\n        else if (n == 500) then\n            allocate(character(len=1) :: roman)\n            roman = D\n        else if (n == 1000) then\n            allocate(character(len=1) :: roman)\n            roman = M\n        else if (n > 1000) then\n            allocate(character(len=len(decode(n / 1000))+1) :: roman)\n            roman = decode(n / 1000) // M\n            n = mod(n, 1000)\n            if (n > 0) then\n                allocate(character(len=len(roman)+len(decode(n))) :: roman)\n                roman = roman // decode(n)\n            end if\n        end if\n    end function decode\nend program main",
  "14": "program main\n    implicit none\n\n    character(len=:), allocatable :: strs(:)\n    character(len=:), allocatable :: lcp\n\n    strs = [\"flower \", \"flow \", \"flight \"]\n    write(*,*) 'Example 1:'\n    write(*,*) 'Input: ', strs\n    write(*,*) 'Output: ', lcp(strs)\n\n    strs = [\"dog \", \"racecar \", \"car \"]\n    write(*,*) 'Example 2:'\n    write(*,*) 'Input: ', strs\n    write(*,*) 'Output: ', lcp(strs)\n\ncontains\n\n    function lcp(strs) result(lcp_str)\n        implicit none\n        character(len=:), allocatable :: strs(:)\n        character(len=:), allocatable :: lcp_str\n        integer :: i, j, k\n        logical :: found\n\n        do i = 1, size(strs) - 1\n            do j = i + 1, size(strs)\n                if (strs(i)(1:1) == strs(j)(1:1)) then\n                    found = .true.\n                    do k = 2, min(size(strs(i)), size(strs(j)))\n                        if (strs(i)(k:k) /= strs(j)(k:k)) then\n                            found = .false.\n                            exit\n                        end if\n                    end do\n                    if (found) then\n                        lcp_str = strs(i)(1:k-1)\n                        return\n                    end if\n                end if\n            end do\n        end do\n        lcp_str = ''\n    end function lcp\n\nend program main",
  "20": "program main\n    implicit none\n\n    character(len=100) :: s\n    logical :: valid\n\n    ! Example 1\n    s = '() '\n    write(*,*) 'Example 1:'\n    write(*,*) 'Input: ', trim(s)\n    valid = is_valid(s)\n    write(*,*) 'Output: ', valid\n    write(*,*) ''\n\n    ! Example 2\n    s = '()[]{}'\n    write(*,*) 'Example 2:'\n    write(*,*) 'Input: ', trim(s)\n    valid = is_valid(s)\n    write(*,*) 'Output: ', valid\n    write(*,*) ''\n\n    ! Example 3\n    s = '(\\]'\n    write(*,*) 'Example 3:'\n    write(*,*) 'Input: ', trim(s)\n    valid = is_valid(s)\n    write(*,*) 'Output: ', valid\n    write(*,*) ''\n\ncontains\n\n    function is_valid(s) result(valid)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j, n_open_brackets\n        character(len=1) :: c\n        logical :: valid\n\n        valid = .true.\n        n_open_brackets = 0\n\n        do i = 1, len(s)\n            c = s(i:i)\n            select case (c)\n                case ('(')\n                    n_open_brackets = n_open_brackets + 1\n                case (')')\n                    if (n_open_brackets == 0) then\n                        valid = .false.\n                        exit\n                    end if\n                    n_open_brackets = n_open_brackets - 1\n                case ('[')\n                    n_open_brackets = n_open_brackets + 1\n                case (']')\n                    if (n_open_brackets == 0) then\n                        valid = .false.\n                        exit\n                    end if\n                    n_open_brackets = n_open_brackets - 1\n                case ('{')\n                    n_open_brackets = n_open_brackets + 1\n                case ('}')\n                    if (n_open_brackets == 0) then\n                        valid = .false.\n                        exit\n                    end if\n                    n_open_brackets = n_open_brackets - 1\n                case default\n                    continue\n            end select\n        end do\n\n        if (n_open_brackets /= 0) then\n            valid = .false.\n        end if\n\n    end function is_valid\n\nend program main",
  "21": "program main\n    ! Solves the problem of merging two sorted linked lists into one sorted list\n    implicit none\n\n    type :: node\n        integer :: val\n        type(node), pointer :: next => null()\n    end type\n\n    type(node), pointer :: list1, list2, current, new_head\n    integer :: i\n\n    ! Example 1\n    allocate(list1)\n    list1%val = 1\n    allocate(list1%next)\n    list1%next%val = 2\n    allocate(list1%next%next)\n    list1%next%next%val = 4\n    allocate(list2)\n    list2%val = 1\n    allocate(list2%next)\n    list2%next%val = 3\n    allocate(list2%next%next)\n    list2%next%next%val = 4\n    call merge_lists(list1, list2, new_head)\n    do while (associated(new_head))\n        write (*, '(I0)', advance='no') new_head%val\n        new_head => new_head%next\n    end do\n    write (*, *) ''\n\n    ! Example 2\n    deallocate(list1)\n    deallocate(list2)\n    allocate(list1)\n    list1%val = -1\n    allocate(list1%next)\n    list1%next%val = 0\n    allocate(list2)\n    list2%val = 1\n    allocate(list2%next)\n    list2%next%val = 2\n    allocate(list2%next%next)\n    list2%next%next%val = 3\n    allocate(list2%next%next%next)\n    list2%next%next%next%val = 4\n    call merge_lists(list1, list2, new_head)\n    do while (associated(new_head))\n        write (*, '(I0)', advance='no') new_head%val\n        new_head => new_head%next\n    end do\n    write (*, *) ''\n\n    ! Example 3\n    deallocate(list1)\n    deallocate(list2)\n    allocate(list1)\n    list1%val = -1\n    allocate(list2)\n    list2%val = 0\n    call merge_lists(list1, list2, new_head)\n    do while (associated(new_head))\n        write (*, '(I0)', advance='no') new_head%val\n        new_head => new_head%next\n    end do\n    write (*, *) ''\n\ncontains\n\n    subroutine merge_lists(list1, list2, new_head)\n        ! Merges the two lists in a one sorted list\n        implicit none\n        type(node), pointer :: list1, list2, new_head\n        type(node), pointer :: current1, current2\n\n        if (.not. associated(list1)) then\n            ! If list1 is empty, return list2\n            new_head => list2\n            return\n        else if (.not. associated(list2)) then\n            ! If list2 is empty, return list1\n            new_head => list1\n            return\n        end if\n\n        ! Set up pointers for the first elements of each list\n        current1 => list1\n        current2 => list2\n\n        ! Loop until we reach the end of either list\n        do while (associated(current1%next) .or. associated(current2%next))\n            ! Check if the current element of list1 is less than or equal to the current element of list2\n            if (current1%val <= current2%val) then\n                ! Splice the current element of list1 into the new list\n                new_head => current1\n                current1 => current1%next\n            else\n                ! Splice the current element of list2 into the new list\n                new_head => current2\n                current2 => current2%next\n            end if\n            ! Move on to the next element of the new list\n            new_head => new_head%next\n        end do\n\n        ! If there are still elements left in list1, add them to the end of the new list\n        if (associated(current1)) then\n            new_head%next => current1\n        end if\n\n        ! If there are",
  "26": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: nums\n    integer :: k\n\n    ! Examples from the problem statement\n    nums(1) = 1\n    nums(2) = 1\n    nums(3) = 2\n    call print_array('Example 1', nums)\n    k = remove_duplicates(nums)\n    call print_array('Example 1', nums, k)\n\n    nums(1) = 0\n    nums(2) = 0\n    nums(3) = 1\n    nums(4) = 1\n    nums(5) = 1\n    nums(6) = 2\n    nums(7) = 2\n    nums(8) = 3\n    nums(9) = 3\n    nums(10) = 4\n    call print_array('Example 2', nums)\n    k = remove_duplicates(nums)\n    call print_array('Example 2', nums, k)\n\ncontains\n\n    subroutine print_array(title, arr, k)\n        character(len=*) :: title\n        integer, dimension(:), intent(in) :: arr\n        integer, intent(in), optional :: k\n\n        write (*, '(A)') trim(title)\n        if (present(k)) then\n            write (*, '(*(I0, 1X))') arr(1:k)\n        else\n            write (*, '(*(I0, 1X))') arr\n        end if\n        write (*, *)\n    end subroutine print_array\n\nend program main\n\nfunction remove_duplicates(nums) result(k)\n    implicit none\n    integer, dimension(:), intent(inout) :: nums\n    integer :: k\n\n    ! Custom judge\n    ! int[] nums = [...]; // Input array\n    ! int[] expectedNums = [...]; // The expected answer with correct length\n    !\n    ! int k = removeDuplicates(nums); // Calls your implementation\n    !\n    ! assert k == expectedNums.length;\n    ! for (int i = 0; i < k; i++) {\n    !     assert nums[i] == expectedNums[i];\n    ! }\n\n    ! Solution\n    k = 1\n    do i = 2, size(nums)\n        if (nums(i) /= nums(k)) then\n            k = k + 1\n            nums(k) = nums(i)\n        end if\n    end do\n\nend function remove_duplicates",
  "27": "program main\n\n! This program solves the problem of removing all occurrences of a value in an integer array\n! in place, without changing the order of the other elements.\n!\n! The problem statement is as follows:\n!\n! Given an integer array nums and an integer val, remove all occurrences of val in nums\n! in-place. The relative order of the elements may be changed. Then return the new length\n! of the array.\n!\n! Custom Judge:\n!\n! The judge will test your solution with the following code:\n!\n! int[] nums = [...]; // Input array\n! int val = ...; // Value to remove\n! int[] expectedNums = [...]; // The expected answer with correct length.\n!                             // It is sorted with no values equaling val.\n!\n! int k = removeElement(nums, val); // Calls your implementation\n!\n! assert k == expectedNums.length;\n! sort(nums, 0, k); // Sort the first k elements of nums\n! for (int i = 0; i < actualLength; i++) {\n!     assert nums[i] == expectedNums[i];\n! }\n!\n! If all assertions pass, then your solution will be accepted.\n!\n! Examples:\n!\n! Example 1:\n!\n! Input: nums = [3,2,2,3], val = 3\n! Output: 2, nums = [2,2,_,_]\n! Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n!              It does not matter what you leave beyond the returned k (hence they are underscores).\n!\n! Example 2:\n!\n! Input: nums = [0,1,2,2,3,0,4,2], val = 2\n! Output: 5, nums = [0,1,4,0,3,_,_,_]\n! Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n!              Note that the five elements can be returned in any order.\n!              It does not matter what you leave beyond the returned k (hence they are underscores).\n!\n! Constraints:\n!\n!     0 <= nums.length <= 100\n!     0 <= nums[i] <= 50\n!     0 <= val <= 100\n\nimplicit none\n\ninteger, parameter :: dp = selected_real_kind(15)\n\ninterface\n    subroutine remove_element(nums, val) bind(c)\n        use iso_c_binding\n        implicit none\n        integer(c_int), intent(inout) :: nums(*)\n        integer(c_int), value :: val\n    end subroutine\nend interface\n\ninteger, allocatable :: nums(:)\ninteger :: val, k, i, j\ncharacter(len=100) :: line\n\n! Read input from stdin\ndo while (.true.)\n    read(unit=*, fmt='(A)', iostat=i) line\n    if (i /= 0) exit\n    backspace(unit=*)\n    allocate(nums(size(line)))\n    read(unit=*, fmt=*) nums\n    call remove_element(nums, val)\n    write(*, '(I0, X, *(I0, X))') k, nums(1:k)\n    deallocate(nums)\nend do\n\ncontains\n\nsubroutine remove_element(nums, val)\n    implicit none\n    integer, intent(inout) :: nums(*)\n    integer, value :: val\n    integer :: i, j\n\n    ! Remove all occurrences of val in nums\n    k = 0\n    do i = 1, size(nums)\n        if (nums(i) /= val) then\n            k = k + 1\n            nums(k) = nums(i)\n        end if\n    end do\n\n    ! Return the new length of nums\n    return\nend subroutine\n\nend program",
  "28": "program main\n    implicit none\n\n    integer :: i, j, k\n    character(len=10) :: needle, haystack\n\n    ! Example 1\n    needle = 'sad '\n    haystack = 'sadbutsad '\n    i = str_index(haystack, needle)\n    write (*,*) 'Example 1:'\n    write (*,'(A,I0)') 'Index of first occurrence of \"', needle, '\" in \"', haystack, '\" is ', i\n\n    ! Example 2\n    needle = 'leeto '\n    haystack = 'leetcode '\n    i = str_index(haystack, needle)\n    write (*,*) 'Example 2:'\n    write (*,'(A,I0)') 'Index of first occurrence of \"', needle, '\" in \"', haystack, '\" is ', i\n\ncontains\n\n    function str_index(haystack, needle) result(i)\n        implicit none\n        character(*), intent(in) :: haystack, needle\n        integer :: i\n\n        do i = 1, len(haystack)-len(needle)+1\n            if (haystack(i:i+len(needle)-1) == needle) then\n                exit\n            end if\n        end do\n\n        if (i > len(haystack)-len(needle)+1) then\n            i = -1\n        end if\n    end function str_index\n\nend program main",
  "35": "program binary_search\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums = (/ 1, 3, 5, 6 /), target\n    integer :: i, j, k, l, m\n\n    ! Example 1\n    target = 5\n    call binary_search_example(nums, target)\n\n    ! Example 2\n    target = 2\n    call binary_search_example(nums, target)\n\n    ! Example 3\n    target = 7\n    call binary_search_example(nums, target)\n\ncontains\n\n    subroutine binary_search_example(nums, target)\n        implicit none\n        integer, intent(in) :: nums(:), target\n        integer :: i, j, k, l, m\n\n        i = 1\n        j = size(nums)\n        do while (i < j)\n            k = (i + j)/2\n            if (nums(k) == target) then\n                print '(A,I0)', 'Target found at index ', k\n                return\n            else if (nums(k) < target) then\n                i = k + 1\n            else\n                j = k\n            end if\n        end do\n        if (i == j) then\n            print '(A,I0)', 'Target not found. Insertion index: ', i\n        else\n            print '(A,I0)', 'Target not found. Insertion index: ', i - 1\n        end if\n    end subroutine binary_search_example\n\nend program binary_search",
  "58": "program main\n    implicit none\n\n    character(len=100) :: s\n    integer :: n\n\n    call get_command_argument(1, s)\n    n = len_trim(s)\n    write (*,*) 'n = ', n\n\nend program main",
  "66": "program main\n    implicit none\n\n    integer, parameter :: n = 100\n    integer(kind=8) :: digits(n), result(n)\n\n    ! Example 1\n    digits = [1, 2, 3]\n    call increment_large_integer(digits, result)\n    print \"(A,*(I1))\", \"Example 1: \", result\n\n    ! Example 2\n    digits = [4, 3, 2, 1]\n    call increment_large_integer(digits, result)\n    print \"(A,*(I1))\", \"Example 2: \", result\n\n    ! Example 3\n    digits = [9]\n    call increment_large_integer(digits, result)\n    print \"(A,*(I1))\", \"Example 3: \", result\n\ncontains\n\n    subroutine increment_large_integer(digits, result)\n        implicit none\n        integer, intent(in) :: digits(:)\n        integer, intent(out) :: result(:)\n        integer :: i, carry\n\n        carry = 1\n        do i = size(digits), 1, -1\n            if (carry == 0) exit\n            result(i) = digits(i) + carry\n            carry = 0\n            if (result(i) >= 10) then\n                result(i) = result(i) - 10\n                carry = 1\n            end if\n        end do\n        if (carry /= 0) then\n            result(1:size(digits)) = digits(1:size(digits))\n            result(size(digits)+1) = carry\n        end if\n    end subroutine increment_large_integer\n\nend program main",
  "67": "program main\n    implicit none\n\n    character(len=:), allocatable :: a, b, c\n\n    a = '11'\n    b = '1'\n    call solve(a, b, c)\n    print *, c\n\n    a = '1010'\n    b = '1011'\n    call solve(a, b, c)\n    print *, c\n\ncontains\n\n    subroutine solve(a, b, c)\n        implicit none\n        character(len=*), intent(in) :: a, b\n        character(len=:), allocatable, intent(out) :: c\n        integer :: i, j, k, n\n\n        n = len(a)\n        allocate(character(len=n+1) :: c)\n        c = ''\n\n        do i = 1, n\n            j = i + 1\n            if (j > n) exit\n            k = iarithmetic_sum(a(i:j), b(i:j))\n            write (c(i:i), '(I1)') k\n        end do\n\n    end subroutine solve\n\n    function iarithmetic_sum(a, b) result(c)\n        implicit none\n        character(len=*), intent(in) :: a, b\n        integer :: c\n        integer :: i, n\n\n        n = len(a)\n        c = 0\n        do i = 1, n\n            c = c + ichar(a(i:i)) - ichar('0') + ichar(b(i:i)) - ichar('0')\n        end do\n\n    end function iarithmetic_sum\n\nend program main",
  "69": "program main\n    implicit none\n\n    integer :: x, y\n\n    x = 4\n    y = sqrt(x)\n    print '(I0)', y\n\n    x = 8\n    y = sqrt(x)\n    print '(I0)', y\n\ncontains\n\n    pure integer function sqrt(x) result(y)\n        implicit none\n        integer, value :: x\n        integer :: i, j\n\n        if (x == 0) then\n            y = 0\n            return\n        end if\n\n        i = 1\n        j = x\n        do while (i < j)\n            i = i + 1\n            j = j / 2\n        end do\n\n        y = i - 1\n\n    end function sqrt\n\nend program main",
  "70": "program main\n    implicit none\n\n    integer, parameter :: n = 2\n    integer :: i, j, k, l, m, n_steps\n    integer, dimension(n) :: steps\n\n    ! Example 1\n    write (*, \"(A)\") \"Example 1:\"\n    write (*, \"(A, I0)\") \"Input: \", n\n    write (*, \"(A, I0)\") \"Output: \", climb_stairs(n)\n    write (*, *)\n\n    ! Example 2\n    write (*, \"(A)\") \"Example 2:\"\n    write (*, \"(A, I0)\") \"Input: \", n\n    write (*, \"(A, I0)\") \"Output: \", climb_stairs(n)\n    write (*, *)\n\ncontains\n\n    function climb_stairs(n) result(num_ways)\n        implicit none\n        integer, intent(in) :: n\n        integer :: num_ways, i\n\n        if (n == 1) then\n            num_ways = 1\n        else if (n == 2) then\n            num_ways = 2\n        else\n            num_ways = climb_stairs(n - 1) + climb_stairs(n - 2)\n        end if\n    end function climb_stairs\n\nend program main",
  "83": "program main\n    ! This program solves the problem of deleting all duplicates from a sorted linked list\n    ! so that each element appears only once.\n    implicit none\n\n    type :: node_t\n        integer :: val\n        type(node_t), pointer :: next => null()\n    end type\n\n    type(node_t), target :: head\n    type(node_t), pointer :: curr, prev\n\n    ! Example 1\n    call init_list(head)\n    call append(head, 1)\n    call append(head, 1)\n    call append(head, 2)\n    print '(A)', 'Example 1:'\n    call delete_duplicates(head)\n    call print_list(head)\n\n    ! Example 2\n    call init_list(head)\n    call append(head, 1)\n    call append(head, 1)\n    call append(head, 2)\n    call append(head, 3)\n    call append(head, 3)\n    print '(A)', 'Example 2:'\n    call delete_duplicates(head)\n    call print_list(head)\n\ncontains\n\n    subroutine init_list(head)\n        ! Initialize an empty linked list\n        type(node_t), intent(out) :: head\n\n        nullify(head%next)\n    end subroutine\n\n    subroutine append(head, val)\n        ! Append a new node with value `val` to the end of the linked list\n        type(node_t), intent(inout) :: head\n        integer, intent(in) :: val\n        type(node_t), pointer :: new_node\n\n        allocate(new_node)\n        new_node%val = val\n        new_node%next => null()\n\n        if (associated(head%next)) then\n            ! There are already some nodes in the list\n            curr => head\n            do while (associated(curr%next))\n                curr => curr%next\n            end do\n            curr%next => new_node\n        else\n            ! This is the first node in the list\n            head%next => new_node\n        end if\n    end subroutine\n\n    subroutine delete_duplicates(head)\n        ! Delete all duplicates from the linked list\n        type(node_t), intent(inout) :: head\n        type(node_t), pointer :: curr, prev\n\n        curr => head\n        prev => null()\n\n        do while (associated(curr%next))\n            if (curr%val == curr%next%val) then\n                ! Found a duplicate, delete it\n                prev%next => curr%next\n                deallocate(curr)\n                curr => prev\n            else\n                ! No duplicate found, move on to the next node\n                prev => curr\n                curr => curr%next\n            end if\n        end do\n    end subroutine\n\n    subroutine print_list(head)\n        ! Print the linked list to stdout\n        type(node_t), intent(in) :: head\n        type(node_t), pointer :: curr\n\n        curr => head\n        do while (associated(curr%next))\n            write (*, '(I0)') curr%val\n            curr => curr%next\n        end do\n        write (*, '(I0)') curr%val\n    end subroutine\n\nend program",
  "88": "program main\n    implicit none\n\n    integer, parameter :: m = 3, n = 3\n    integer, dimension(m+n) :: nums1 = [1,2,3,0,0,0]\n    integer, dimension(n) :: nums2 = [2,5,6]\n\n    call merge_sorted_arrays(nums1, m, nums2, n)\n\n    write (*, '(A)') 'nums1 = ', nums1\n\ncontains\n\nsubroutine merge_sorted_arrays(nums1, m, nums2, n)\n    implicit none\n    integer, intent(inout) :: nums1(:)\n    integer, intent(in) :: m, n\n    integer, intent(in) :: nums2(:)\n    integer :: i, j, k\n\n    ! Merge nums1 and nums2 into a single array sorted in non-decreasing order\n    ! Store the final sorted array inside nums1\n    ! nums1 has a length of m + n, where the first m elements denote the elements that should be merged\n    ! and the last n elements are set to 0 and should be ignored\n    ! nums2 has a length of n\n\n    i = 1\n    j = 1\n    k = 1\n\n    do while (i <= m .and. j <= n)\n        if (nums1(i) < nums2(j)) then\n            nums1(k) = nums1(i)\n            i = i + 1\n        else\n            nums1(k) = nums2(j)\n            j = j + 1\n        end if\n        k = k + 1\n    end do\n\n    if (i > m) then\n        nums1(k:) = nums2(j:)\n    end if\nend subroutine merge_sorted_arrays\n\nend program main",
  "94": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 3\n    type(tree_node), allocatable :: roots(:)[:]\n    integer :: i\n\n    allocate(roots(n)[*])\n\n    ! Example 1\n    allocate(roots(1)[1])\n    allocate(roots(1)[1]%left, source=tree_node(-1))\n    allocate(roots(1)[1]%right, source=tree_node(2))\n    call print_inorder(roots(1)[1])\n    deallocate(roots(1)[1])\n\n    ! Example 2\n    allocate(roots(1)[1])\n    allocate(roots(1)[1]%left, source=tree_node(-1))\n    allocate(roots(1)[1]%right, source=tree_node(-1))\n    call print_inorder(roots(1)[1])\n    deallocate(roots(1)[1])\n\n    ! Example 3\n    allocate(roots(1)[1])\n    allocate(roots(1)[1]%left, source=tree_node(1))\n    allocate(roots(1)[1]%right, source=tree_node(2))\n    call print_inorder(roots(1)[1])\n    deallocate(roots(1)[1])\n\ncontains\n\n    subroutine print_inorder(root)\n        type(tree_node), intent(in) :: root\n        if (associated(root%left)) then\n            call print_inorder(root%left)\n        end if\n        write (unit=error_unit, fmt='(*(g0,1x))') root%value\n        if (associated(root%right)) then\n            call print_inorder(root%right)\n        end if\n    end subroutine print_inorder\n\nend program main\n\ntype :: tree_node\n    real(kind=DP) :: value\n    class(tree_node), pointer :: left => null()\n    class(tree_node), pointer :: right => null()\nend type tree_node",
  "100": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    type(node), target :: p(n)\n    type(node), target :: q(n)\n\n    call init_nodes(p)\n    call init_nodes(q)\n\n    print '(L1)', same_tree(p, q)\n\ncontains\n\n    subroutine init_nodes(nodes)\n        implicit none\n        type(node), intent(inout) :: nodes(:)\n        integer :: i\n\n        do i = 1, size(nodes)\n            allocate(nodes(i)%left)\n            allocate(nodes(i)%right)\n            nodes(i)%val = i\n        end do\n    end subroutine init_nodes\n\n    logical function same_tree(p, q) result(same)\n        implicit none\n        type(node), intent(in) :: p(:)\n        type(node), intent(in) :: q(:)\n        integer :: i\n\n        same = .true.\n\n        do i = 1, size(p)\n            if (associated(p(i)%left)) then\n                if (.not. associated(q(i)%left)) return\n                same = same .and. same_tree(p(i)%left, q(i)%left)\n            else\n                if (associated(q(i)%left)) return\n            end if\n\n            if (associated(p(i)%right)) then\n                if (.not. associated(q(i)%right)) return\n                same = same .and. same_tree(p(i)%right, q(i)%right)\n            else\n                if (associated(q(i)%right)) return\n            end if\n\n            if (p(i)%val /= q(i)%val) return\n        end do\n    end function same_tree\n\nend program main\n\ntype node\n    integer :: val\n    class(node), pointer :: left => null()\n    class(node), pointer :: right => null()\nend type node",
  "101": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, output_unit\n    implicit none\n    integer, parameter :: unit_in = input_unit, unit_out = output_unit\n    type(tree_node), pointer :: root\n    logical :: result\n\n    call read_tree(unit=unit_in, root=root)\n    result = check_mirror(root)\n    write (unit=output_unit, fmt='(L1)') result\n\ncontains\n\n    function check_mirror(root) result(result)\n        class(tree_node), pointer, intent(in) :: root\n        logical :: result\n        class(tree_node), pointer :: left, right\n\n        if (.not. associated(root)) then\n            result = .true.\n            return\n        end if\n\n        left => root%left\n        right => root%right\n\n        ! Check if left subtree is a mirror of right subtree\n        if (associated(left)) then\n            result = check_mirror(left)\n            if (.not. result) return\n        else if (associated(right)) then\n            result = .false.\n            return\n        end if\n\n        ! Check if right subtree is a mirror of left subtree\n        if (associated(right)) then\n            result = check_mirror(right)\n            if (.not. result) return\n        else if (associated(left)) then\n            result = .false.\n            return\n        end if\n\n        ! If we reach this point, both subtrees are mirrors of each other\n        result = .true.\n\n    end function check_mirror\n\n    subroutine read_tree(unit, root)\n        integer, intent(in) :: unit\n        type(tree_node), pointer, intent(out) :: root\n        integer :: value\n\n        read (unit=unit, fmt=*) value\n        if (value == -1) then\n            nullify(root)\n        else\n            allocate(root)\n            root%val = value\n            call read_tree(unit, root%left)\n            call read_tree(unit, root%right)\n        end if\n\n    end subroutine read_tree\n\nend program main\n\ntype :: tree_node\n    integer :: val\n    class(tree_node), pointer :: left => null(), right => null()\nend type tree_node",
  "104": "program max_depth\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n\n    type, public :: node_t\n        real(kind=DP) :: val\n        class(node_t), pointer :: left => null()\n        class(node_t), pointer :: right => null()\n    end type\n\n    interface\n        function max_depth_recursive(root) result(res)\n            import :: node_t\n            class(node_t), intent(in) :: root\n            integer :: res\n        end function\n\n        function max_depth_iterative(root) result(res)\n            import :: node_t\n            class(node_t), intent(in) :: root\n            integer :: res\n        end function\n    end interface\n\n    type(node_t), target :: root\n    integer :: res\n\n    call test_max_depth(root)\n\ncontains\n\n    subroutine test_max_depth(root)\n        type(node_t), intent(inout) :: root\n\n        write (unit=error_unit, fmt='(A)') 'Testing recursive solution...'\n        res = max_depth_recursive(root)\n        if (res /= 3) then\n            write (unit=error_unit, fmt='(A)') 'Recursive solution failed!'\n            stop 1\n        else\n            write (unit=error_unit, fmt='(A)') 'Recursive solution passed.'\n        end if\n\n        write (unit=error_unit, fmt='(A)') 'Testing iterative solution...'\n        res = max_depth_iterative(root)\n        if (res /= 3) then\n            write (unit=error_unit, fmt='(A)') 'Iterative solution failed!'\n            stop 1\n        else\n            write (unit=error_unit, fmt='(A)') 'Iterative solution passed.'\n        end if\n    end subroutine\n\n    function max_depth_recursive(root) result(res)\n        class(node_t), intent(in) :: root\n        integer :: res\n\n        if (.not. associated(root)) then\n            res = 0\n        else\n            res = 1 + max(max_depth_recursive(root%left), max_depth_recursive(root%right))\n        end if\n    end function\n\n    function max_depth_iterative(root) result(res)\n        class(node_t), intent(in) :: root\n        integer :: res\n\n        type(node_t), pointer :: current => root\n        integer :: level, max_level\n\n        do while (associated(current))\n            level = 0\n            do while (associated(current))\n                level = level + 1\n                current => current%left\n            end do\n            max_level = max(max_level, level)\n            current => root\n            level = 0\n            do while (associated(current))\n                level = level + 1\n                current => current%right\n            end do\n            max_level = max(max_level, level)\n        end do\n\n        res = max_level\n    end function\nend program",
  "108": "program main\n    ! Solve the problem described in the task\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: nums\n    type(Node), pointer :: root\n\n    ! Example 1\n    nums = [-10, -3, 0, 5, 9]\n    call solve(nums, root)\n    write (*, '(A)') 'Example 1:'\n    call print_tree(root)\n\n    ! Example 2\n    nums = [1, 3]\n    call solve(nums, root)\n    write (*, '(A)') 'Example 2:'\n    call print_tree(root)\n\ncontains\n\n    subroutine solve(nums, root)\n        ! Solves the problem\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        type(Node), pointer, intent(out) :: root\n\n        integer :: i\n\n        allocate(root)\n        root%val = nums(1)\n        root%left => null()\n        root%right => null()\n\n        do i = 2, size(nums)\n            call insert(root, nums(i))\n        end do\n    end subroutine solve\n\n    subroutine insert(node, val)\n        ! Inserts a new node into the binary search tree\n        implicit none\n        class(Node), pointer, intent(inout) :: node\n        integer, intent(in) :: val\n\n        if (val < node%val) then\n            if (.not. associated(node%left)) then\n                allocate(node%left)\n                node%left%val = val\n                node%left%left => null()\n                node%left%right => null()\n            else\n                call insert(node%left, val)\n            end if\n        else\n            if (.not. associated(node%right)) then\n                allocate(node%right)\n                node%right%val = val\n                node%right%left => null()\n                node%right%right => null()\n            else\n                call insert(node%right, val)\n            end if\n        end if\n    end subroutine insert\n\n    subroutine print_tree(node)\n        ! Prints the binary search tree\n        implicit none\n        class(Node), pointer, intent(in) :: node\n\n        if (associated(node)) then\n            write (*, '(I0)', advance='no') node%val\n            call print_tree(node%left)\n            call print_tree(node%right)\n        end if\n    end subroutine print_tree\n\nend program main\n\ntype Node\n    integer :: val\n    type(Node), pointer :: left\n    type(Node), pointer :: right\nend type Node",
  "110": "program main\n    ! Solves the problem: Given a binary tree, determine if it is height-balanced.\n    implicit none\n\n    type :: node_t\n        integer :: val\n        type(node_t), pointer :: left => null(), right => null()\n    end type\n\n    type(node_t), target :: root\n\n    call solve(root)\n\ncontains\n\n    function is_height_balanced(root) result(is_balanced)\n        ! Determines if the given binary tree is height-balanced.\n        implicit none\n        class(node_t), intent(in) :: root\n        logical :: is_balanced\n        integer :: depth\n\n        is_balanced = .true.\n        depth = 0\n        call check_depth(root, depth, is_balanced)\n    end function\n\n    subroutine check_depth(root, depth, is_balanced)\n        ! Recursive function to check the depth of the given binary tree.\n        implicit none\n        class(node_t), intent(in) :: root\n        integer, intent(inout) :: depth\n        logical, intent(inout) :: is_balanced\n\n        if (associated(root%left)) then\n            call check_depth(root%left, depth + 1, is_balanced)\n        end if\n        if (associated(root%right)) then\n            call check_depth(root%right, depth + 1, is_balanced)\n        end if\n\n        if (abs(depth - get_depth(root%left)) > 1) then\n            is_balanced = .false.\n        end if\n    end subroutine\n\n    function get_depth(root) result(depth)\n        ! Returns the depth of the given binary tree.\n        implicit none\n        class(node_t), intent(in) :: root\n        integer :: depth\n\n        if (.not. associated(root)) then\n            depth = 0\n        else\n            depth = max(get_depth(root%left), get_depth(root%right)) + 1\n        end if\n    end function\n\n    subroutine solve(root)\n        ! Runs the solution on the given binary tree.\n        implicit none\n        type(node_t), intent(inout) :: root\n\n        write (*, '(L1)') is_height_balanced(root)\n    end subroutine\nend program",
  "111": "program min_depth_binary_tree\n    implicit none\n\n    type :: node\n        integer :: val\n        type(node), pointer :: left => null(), right => null()\n    end type\n\n    type(node), target :: root\n    type(node), pointer :: current\n    integer :: i, j, n\n\n    ! Examples\n    n = 1\n    allocate(root%left)\n    root%left%val = 3\n    allocate(root%right)\n    root%right%val = 9\n    allocate(root%left%left)\n    root%left%left%val = 20\n    allocate(root%right%left)\n    root%right%left%val = 15\n    allocate(root%right%right)\n    root%right%right%val = 7\n    call print_min_depth(root)\n\n    n = 2\n    deallocate(root%left)\n    deallocate(root%right)\n    allocate(root%left)\n    root%left%val = 2\n    do i = 1, 5\n        allocate(current%left)\n        current%left%val = i\n        if (i /= 5) then\n            allocate(current%right)\n            current%right%val = i + 1\n        end if\n        current => current%left\n    end do\n    call print_min_depth(root)\n\ncontains\n\n    subroutine print_min_depth(root)\n        type(node), intent(in) :: root\n        integer :: min_depth\n\n        min_depth = min_depth_recursive(root)\n        write (*, '(A, I0)') 'Minimum depth of the binary tree is ', min_depth\n\n    contains\n\n        function min_depth_recursive(current) result(min_depth)\n            type(node), intent(in), pointer :: current\n            integer :: min_depth\n\n            if (.not. associated(current)) then\n                min_depth = 0\n            else\n                min_depth = 1 + min([min_depth_recursive(current%left), &\n                                     min_depth_recursive(current%right)])\n            end if\n        end function\n\n    end subroutine\n\nend program",
  "112": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, iostat_end, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=256) :: filename\n    type :: TreeNode\n        real(kind=DP), pointer :: val => null()\n        class(TreeNode), pointer :: left => null(), right => null()\n    end type TreeNode\n    type(TreeNode), pointer :: root\n    integer :: status, iostatus\n    logical :: exists\n    real(kind=DP) :: targetSum\n\n    ! read input from file\n    write (unit=unit_out, fmt='(A)') 'Enter filename:'\n    read (unit=unit_in, fmt='(A)', iostat=status, iomsg=filename)\n    inquire (file=filename, exist=exists)\n    if (.not. exists) then\n        write (unit=error_unit, fmt='(2A)') 'error: ', trim(filename), ' does not exist'\n        stop 1\n    end if\n    open (newunit=unit_in, file=filename, status='old', action='read', &\n          iostat=iostatus, iomsg=filename)\n    if (iostatus /= 0) then\n        write (unit=error_unit, fmt='(2A)') 'error: ', trim(filename), ' could not be opened for reading'\n        stop 2\n    end if\n    read (unit=unit_in, fmt=*, iostat=status) root, targetSum\n    close (unit=unit_in)\n\n    ! solve problem\n    if (solve(root, targetSum)) then\n        write (unit=unit_out, fmt='(L1)') .true.\n    else\n        write (unit=unit_out, fmt='(L1)') .false.\n    end if\n\ncontains\n\n    function solve(node, targetSum) result(hasPath)\n        class(TreeNode), intent(in) :: node\n        real(kind=DP), value :: targetSum\n        logical :: hasPath\n\n        if (associated(node%left)) then\n            hasPath = solve(node%left, targetSum - node%val)\n        else\n            hasPath = .false.\n        end if\n        if (hasPath) return\n\n        if (associated(node%right)) then\n            hasPath = solve(node%right, targetSum - node%val)\n        else\n            hasPath = .false.\n        end if\n        if (hasPath) return\n\n        if (abs(targetSum - node%val) < 1.0D-6) then\n            hasPath = .true.\n        else\n            hasPath = .false.\n        end if\n    end function solve\n\nend program main",
  "118": "program pascals_triangle\n    implicit none\n\n    integer :: numRows\n    integer :: i, j\n    integer :: row(numRows)\n\n    do i = 1, numRows\n        if (i == 1) then\n            row(i) = 1\n        else\n            row(i) = 1\n            do j = 2, i - 1\n                row(j) = row(j - 1) + row(j)\n            end do\n        end if\n        print '(*(I1, :, \",\"))', row\n    end do\n\nend program pascals_triangle",
  "119": "program pascals_triangle\n    implicit none\n\n    integer :: rowIndex\n    integer :: i, j\n    integer :: row(rowIndex+1)\n\n    do while (get_next_example())\n        read (*, *) rowIndex\n        call solve(rowIndex, row)\n        write (*, '(*(I0, 1X))') row\n    end do\n\ncontains\n\n    logical function get_next_example()\n        implicit none\n        character(len=100) :: line\n        integer :: status\n\n        read (*, '(A)', iostat=status) line\n        if (status /= 0) then\n            get_next_example = .false.\n            return\n        end if\n\n        if (line == '') then\n            get_next_example = .false.\n            return\n        else\n            get_next_example = .true.\n            return\n        end if\n    end function get_next_example\n\n    subroutine solve(rowIndex, row)\n        implicit none\n        integer, intent(in) :: rowIndex\n        integer, intent(out) :: row(:)\n\n        integer :: i\n\n        row(1) = 1\n        do i = 2, rowIndex+1\n            row(i) = row(i-1) + row(i-2)\n        end do\n    end subroutine solve\nend program pascals_triangle",
  "121": "program main\n    implicit none\n\n    integer, parameter :: n = 7\n    integer, dimension(n) :: prices\n    integer :: i\n    integer :: result\n\n    ! Example 1\n    prices = (/ 7, 1, 5, 3, 6, 4 /)\n    write (*, '(A)') 'Example 1'\n    result = max_profit(prices)\n    write (*, '(A, I0)') 'Max profit: ', result\n\n    ! Example 2\n    prices = (/ 7, 6, 4, 3, 1 /)\n    write (*, '(A)') 'Example 2'\n    result = max_profit(prices)\n    write (*, '(A, I0)') 'Max profit: ', result\n\ncontains\n\n    function max_profit(prices) result(max_profit_)\n        implicit none\n        integer, dimension(:), intent(in) :: prices\n        integer :: max_profit_\n        integer :: min_price\n        integer :: max_price\n        integer :: i\n\n        min_price = prices(1)\n        max_price = prices(1)\n        max_profit_ = 0\n\n        do i = 2, size(prices)\n            if (prices(i) < min_price) then\n                min_price = prices(i)\n            else if (prices(i) > max_price) then\n                max_price = prices(i)\n            end if\n        end do\n\n        if (max_price > min_price) then\n            max_profit_ = max_price - min_price\n        end if\n    end function max_profit\nend program main",
  "125": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    logical :: result\n\n    ! Example 1\n    s = \"A man, a plan, a canal: Panama \"\n    result = isPalindrome(s)\n    write(*,*) \"Example 1:\"\n    write(*,*) \"Input: \", s\n    write(*,*) \"Output: \", result\n    write(*,*) \"\"\n\n    ! Example 2\n    s = \"race a car \"\n    result = isPalindrome(s)\n    write(*,*) \"Example 2:\"\n    write(*,*) \"Input: \", s\n    write(*,*) \"Output: \", result\n    write(*,*) \"\"\n\n    ! Example 3\n    s = \"  \"\n    result = isPalindrome(s)\n    write(*,*) \"Example 3:\"\n    write(*,*) \"Input: \", s\n    write(*,*) \"Output: \", result\n    write(*,*) \"\"\n\ncontains\n\n    function isPalindrome(s) result(result_)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=:), allocatable :: lowercase\n        integer :: i, j\n        logical :: result_\n\n        lowercase = toLowerCase(s)\n        i = 1\n        j = len(lowercase)\n        do while (i < j)\n            if (lowercase(i:i) /= lowercase(j:j)) then\n                result_ = .false.\n                return\n            end if\n            i = i + 1\n            j = j - 1\n        end do\n        result_ = .true.\n    end function isPalindrome\n\n    function toLowerCase(s) result(lowercase)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=:), allocatable :: lowercase\n        integer :: i\n\n        allocate(character(len=len(s)) :: lowercase)\n        do i = 1, len(s)\n            select case (s(i:i))\n                case ('A':'Z')\n                    lowercase(i:i) = char(iachar(s(i:i)) + 32)\n                case default\n                    lowercase(i:i) = s(i:i)\n            end select\n        end do\n    end function toLowerCase\n\nend program main",
  "136": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums\n    integer :: i\n\n    ! Example 1\n    nums = [2, 2, 1]\n    call solve(nums)\n    print '(A, I0)', 'Example 1: ', nums(1)\n\n    ! Example 2\n    nums = [4, 1, 2, 1, 2]\n    call solve(nums)\n    print '(A, I0)', 'Example 2: ', nums(1)\n\n    ! Example 3\n    nums = [1]\n    call solve(nums)\n    print '(A, I0)', 'Example 3: ', nums(1)\n\ncontains\n\n    subroutine solve(nums)\n        implicit none\n        integer, dimension(:), intent(inout) :: nums\n        integer :: i, j\n\n        do i = 1, size(nums) - 1\n            do j = i + 1, size(nums)\n                if (nums(i) == nums(j)) then\n                    nums(i) = 0\n                    exit\n                end if\n            end do\n        end do\n\n        do i = 1, size(nums)\n            if (nums(i) /= 0) then\n                nums(1) = nums(i)\n                return\n            end if\n        end do\n    end subroutine solve\nend program main",
  "141": "program main\n    implicit none\n\n    type :: Node\n        integer :: val\n        type(Node), pointer :: next => null()\n    end type\n\n    type(Node), target :: head\n    type(Node), pointer :: current\n    logical :: has_cycle\n\n    ! Example 1\n    allocate(current, source=Node(3))\n    allocate(current%next, source=Node(2))\n    allocate(current%next%next, source=Node(0))\n    allocate(current%next%next%next, source=Node(-4))\n    has_cycle = hasCycle(head)\n    print '(L1)', has_cycle\n\n    ! Example 2\n    deallocate(current)\n    allocate(current, source=Node(1))\n    allocate(current%next, source=Node(2))\n    has_cycle = hasCycle(head)\n    print '(L1)', has_cycle\n\n    ! Example 3\n    deallocate(current)\n    allocate(current, source=Node(1))\n    has_cycle = hasCycle(head)\n    print '(L1)', has_cycle\n\ncontains\n\n    function hasCycle(head) result(has_cycle)\n        type(Node), target :: head\n        type(Node), pointer :: current\n        integer :: pos\n\n        current => head\n        pos = 1\n\n        do while (associated(current%next))\n            if (pos == current%next%val) then\n                has_cycle = .true.\n                exit\n            end if\n            current => current%next\n            pos = current%val\n        end do\n\n        has_cycle = .false.\n    end function\n\nend program",
  "144": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=*), parameter :: filename_in = \"example_input.txt\"\n    character(len=*), parameter :: filename_out = \"example_output.txt\"\n    type :: node\n        real(kind=DP) :: val\n        type(node), pointer :: left => null(), right => null()\n    end type\n    type(node), pointer :: root\n    integer :: iostat\n    logical :: exists\n\n    ! Read input from file\n    open(newunit=unit_in, file=filename_in, status=\"old\", action=\"read\", &\n         form=\"formatted\", access=\"sequential\", iostat=iostat, &\n         position=\"rewind\")\n    if (iostat /= 0) then\n        write(unit=error_unit, fmt=\"(A)\") \"Error: cannot open input file.\"\n        stop 1\n    end if\n    exists = .true.\n    call read_tree(unit_in, root, exists)\n    close(unit=unit_in)\n\n    ! Output preorder traversal\n    write(unit=unit_out, fmt=\"(*(G0))\") preorder_traversal(root)\n\n    ! Write output to file\n    open(newunit=unit_out, file=filename_out, status=\"replace\", action=\"write\", &\n         form=\"formatted\", access=\"sequential\", iostat=iostat, &\n         position=\"rewind\")\n    if (iostat /= 0) then\n        write(unit=error_unit, fmt=\"(A)\") \"Error: cannot open output file.\"\n        stop 1\n    end if\n    call write_preorder_traversal(unit_out, root)\n    close(unit=unit_out)\n\ncontains\n\n    function preorder_traversal(root) result(values)\n        implicit none\n        class(node), intent(in) :: root\n        real(kind=DP), allocatable :: values(:)\n        allocate(values(size(root)))\n        values = preorder_traversal_recursive(root)\n    end function\n\n    recursive function preorder_traversal_recursive(root) result(values)\n        implicit none\n        class(node), intent(in) :: root\n        real(kind=DP), allocatable :: values(:)\n        if (.not. associated(root)) then\n            allocate(values(0))\n            return\n        end if\n        allocate(values(size(root)+1))\n        values(1) = root%val\n        values(2:) = preorder_traversal_recursive(root%left)\n        values(size(values)-1:) = preorder_traversal_recursive(root%right)\n    end function\n\n    subroutine write_preorder_traversal(unit, root)\n        implicit none\n        integer, value :: unit\n        class(node), intent(in) :: root\n        if (.not. associated(root)) then\n            return\n        end if\n        write(unit=unit, fmt=\"(G0)\") root%val\n        call write_preorder_traversal(unit, root%left)\n        call write_preorder_traversal(unit, root%right)\n    end subroutine\n\n    subroutine read_tree(unit, root, exists)\n        implicit none\n        integer, value :: unit\n        class(node), pointer :: root\n        logical, intent(out) :: exists\n        real(kind=DP) :: val\n        exists = .false.\n        read(unit=unit, fmt=*, iostat=iostat) val\n        if (iostat == 0) then\n            exists = .true.\n            allocate(root)\n            root%val = val\n            call read_tree(unit, root%left, exists)\n            call read_tree(unit, root%right, exists)\n        end if\n    end subroutine\n\nend program",
  "145": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, output_unit\n    implicit none\n    integer, parameter :: n = 5\n    type(node), allocatable :: roots(:)\n    integer :: i\n\n    allocate(roots(n))\n\n    ! Example 1\n    call init_node(roots(1), 1, null(), null())\n    call init_node(roots(2), 2, roots(1), null())\n    call init_node(roots(3), 3, null(), roots(2))\n    call init_node(roots(4), 4, roots(3), null())\n    call init_node(roots(5), 5, roots(4), null())\n    write (output_unit, '(*(g0,:,\" \"))') 'Example 1:'\n    call print_postorder(roots(5))\n    deallocate(roots)\n\n    ! Example 2\n    allocate(roots(1))\n    call init_node(roots(1), 1, null(), null())\n    write (output_unit, '(*(g0,:,\" \"))') 'Example 2:'\n    call print_postorder(roots(1))\n    deallocate(roots)\n\n    ! Example 3\n    allocate(roots(1))\n    call init_node(roots(1), 1, null(), null())\n    write (output_unit, '(*(g0,:,\" \"))') 'Example 3:'\n    call print_postorder(roots(1))\n    deallocate(roots)\n\ncontains\n\n    subroutine init_node(this, val, left, right)\n        class(node), intent(out) :: this\n        integer, intent(in) :: val\n        class(node), intent(in), optional :: left, right\n\n        this%val = val\n        if (present(left)) then\n            this%left => left\n        else\n            this%left => null()\n        end if\n        if (present(right)) then\n            this%right => right\n        else\n            this%right => null()\n        end if\n    end subroutine init_node\n\n    recursive subroutine print_postorder(root)\n        class(node), intent(in) :: root\n\n        if (.not. associated(root%left)) then\n            if (.not. associated(root%right)) then\n                write (output_unit, '(i0)') root%val\n            else\n                call print_postorder(root%right)\n                write (output_unit, '(i0)') root%val\n            end if\n        else\n            call print_postorder(root%left)\n            if (.not. associated(root%right)) then\n                write (output_unit, '(i0)') root%val\n            else\n                call print_postorder(root%right)\n                write (output_unit, '(i0)') root%val\n            end if\n        end if\n    end subroutine print_postorder\n\nend program main\n\ntype node\n    integer :: val\n    class(node), pointer :: left => null(), right => null()\nend type node",
  "157": "program main\n\n    implicit none\n\n    integer :: n, i, j\n    character(len=4) :: buf4\n    character(len=1000) :: file\n    character(len=1000), allocatable :: buf(:)\n\n    ! Read n characters from file and store it in buf\n    call read(file, n, buf)\n\n    ! Print the contents of buf\n    do i = 1, size(buf)\n        print *, buf(i)\n    end do\n\ncontains\n\n    subroutine read4(buf4)\n        implicit none\n        character(len=4), intent(out) :: buf4\n        integer :: i\n\n        ! Your code here\n        buf4 = \"abcd\"\n    end subroutine read4\n\n    function read(file, n, buf) result(num_chars_read)\n        implicit none\n        character(len=*), intent(in) :: file\n        integer, intent(in) :: n\n        character(len=*), intent(out) :: buf\n        integer :: num_chars_read\n\n        ! Your code here\n        num_chars_read = 0\n    end function read\n\nend program main",
  "160": "program main\n    ! Solves the problem of finding the intersection node of two linked lists.\n    implicit none\n\n    type :: node_type\n        integer :: val\n        type(node_type), pointer :: next => null()\n    end type node_type\n\n    type(node_type), target :: headA, headB\n    type(node_type), pointer :: currA, currB\n    integer :: i, j, k, l\n    logical :: found\n\n    ! Test case 1\n    call init_linked_list(headA, [4, 1, 8, 4, 5])\n    call init_linked_list(headB, [5, 6, 1, 8, 4, 5])\n    currA => headA\n    currB => headB\n    call find_intersection(currA, currB, found)\n    if (found) then\n        print \"(A)\", \"Intersected at '8'\"\n    else\n        print \"(A)\", \"No intersection\"\n    end if\n\n    ! Test case 2\n    call init_linked_list(headA, [1, 9, 1, 2, 4])\n    call init_linked_list(headB, [3, 2, 4])\n    currA => headA\n    currB => headB\n    call find_intersection(currA, currB, found)\n    if (found) then\n        print \"(A)\", \"Intersected at '2'\"\n    else\n        print \"(A)\", \"No intersection\"\n    end if\n\n    ! Test case 3\n    call init_linked_list(headA, [2, 6, 4])\n    call init_linked_list(headB, [1, 5])\n    currA => headA\n    currB => headB\n    call find_intersection(currA, currB, found)\n    if (found) then\n        print \"(A)\", \"Intersected at '2'\"\n    else\n        print \"(A)\", \"No intersection\"\n    end if\n\ncontains\n\n    subroutine init_linked_list(head, values)\n        ! Initializes a linked list with the given values.\n        type(node_type), target :: head\n        integer, intent(in) :: values(:)\n        type(node_type), pointer :: curr\n        integer :: i\n\n        curr => head\n        do i = 1, size(values)\n            allocate(curr%next)\n            curr%next%val = values(i)\n            curr => curr%next\n        end do\n        nullify(curr%next)\n    end subroutine init_linked_list\n\n    subroutine find_intersection(headA, headB, found)\n        ! Finds the intersection node of two linked lists.\n        type(node_type), target :: headA, headB\n        type(node_type), pointer :: currA, currB\n        logical, intent(out) :: found\n        integer :: skipA, skipB\n\n        ! Find the intersection node by comparing the values of the two lists.\n        currA => headA\n        currB => headB\n        skipA = 0\n        skipB = 0\n        do while (.true.)\n            if (currA%val == currB%val) then\n                found = .true.\n                exit\n            end if\n            skipA = skipA + 1\n            skipB = skipB + 1\n            currA => currA%next\n            currB => currB%next\n            if (.not. associated(currA)) then\n                currA => headA\n                skipA = 0\n            end if\n            if (.not. associated(currB)) then\n                currB => headB\n                skipB = 0\n            end if\n        end do\n\n        ! Print the result.\n        if (found) then\n            print \"(A, I0)\", \"Intersected at '\", currA%val, \"'\"\n        else\n            print \"(A)\", \"No intersection\"\n        end if\n    end subroutine find_intersection\n\nend program main",
  "163": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, parameter :: lower = 0\n    integer, parameter :: upper = 99\n    integer, dimension(n) :: nums = (/ 0, 1, 3, 50, 75 /)\n    integer :: i\n\n    call solve(nums, lower, upper)\n\ncontains\n\nsubroutine solve(nums, lower, upper)\n    implicit none\n    integer, intent(in) :: nums(:), lower, upper\n    character(len=100) :: buffer\n    integer :: i, j, k\n\n    do i = 1, size(nums)\n        write (buffer, \"(I0)\") nums(i)\n        print \"(A)\", trim(buffer)\n    end do\n\nend subroutine solve\n\nend program main",
  "168": "program main\n    implicit none\n\n    integer, parameter :: columnNumber = 1\n    character(len=5) :: columnTitle\n\n    call getColumnTitle(columnNumber, columnTitle)\n    print '(A)', trim(columnTitle)\n\ncontains\n\n    subroutine getColumnTitle(columnNumber, columnTitle)\n        implicit none\n        integer, intent(in) :: columnNumber\n        character(len=*), intent(out) :: columnTitle\n\n        character(len=1), dimension(:), allocatable :: letters\n        integer :: i, n\n\n        allocate(letters(columnNumber))\n\n        do i = 1, size(letters)\n            letters(i) = char(iachar('A') + mod(columnNumber - 1, 26))\n            columnNumber = (columnNumber - 1) / 26\n        end do\n\n        n = size(letters)\n        if (n > 0) then\n            columnTitle = repeat(' ', n-1) // letters(n)\n        else\n            columnTitle = ''\n        end if\n    end subroutine getColumnTitle\nend program main",
  "169": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: nums = (/ 3, 2, 3 /)\n    integer :: i\n\n    write (*, '(A)') 'Expected: 3'\n    write (*, '(A)') 'Actual: ', majority_element(nums)\n\ncontains\n\n    function majority_element(nums) result(majority)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer :: majority\n        integer :: count\n\n        do i = 1, size(nums)\n            count = 0\n            do j = 1, size(nums)\n                if (nums(i) == nums(j)) then\n                    count = count + 1\n                end if\n            end do\n            if (count > size(nums)/2) then\n                majority = nums(i)\n                exit\n            end if\n        end do\n    end function majority_element\n\nend program main",
  "170": "program main\n    use :: two_sum_mod\n    implicit none\n\n    type(TwoSum) :: two_sum\n    integer :: i\n    integer, parameter :: n = 6\n    integer, parameter :: nums(n) = [1, 3, 5, 4, 7, 2]\n    logical, parameter :: expected(n) = [.false., .true., .true., .true., .false., .false.]\n\n    do i = 1, n\n        call two_sum%add(nums(i))\n        write(*, '(A, L1)') 'find(', nums(i), ') = ', two_sum%find(nums(i))\n    end do\n\nend program main\n\nmodule two_sum_mod\n    implicit none\n\n    private\n    public :: TwoSum\n\n    type :: TwoSum\n        private\n        integer, allocatable :: numbers(:)\n    contains\n        procedure, pass :: add\n        procedure, pass :: find\n    end type TwoSum\n\ncontains\n\n    subroutine add(this, number)\n        class(TwoSum), intent(inout) :: this\n        integer, intent(in) :: number\n\n        allocate(this%numbers(size(this%numbers)+1))\n        this%numbers(size(this%numbers)) = number\n    end subroutine add\n\n    function find(this, value) result(has_pair)\n        class(TwoSum), intent(in) :: this\n        integer, intent(in) :: value\n        logical :: has_pair\n        integer :: i, j\n\n        has_pair = .false.\n        do i = 1, size(this%numbers)-1\n            do j = i+1, size(this%numbers)\n                if (this%numbers(i) + this%numbers(j) == value) then\n                    has_pair = .true.\n                    exit\n                end if\n            end do\n            if (has_pair) exit\n        end do\n    end function find\n\nend module two_sum_mod",
  "171": "program main\n    implicit none\n\n    character(len=7), parameter :: columnTitle = \"A \"\n    integer :: columnNumber\n\n    call getColumnNumber(columnTitle, columnNumber)\n    write (*, '(I0)') columnNumber\n\ncontains\n\n    subroutine getColumnNumber(columnTitle, columnNumber)\n        implicit none\n        character(len=*), intent(in) :: columnTitle\n        integer, intent(out) :: columnNumber\n\n        integer :: i\n        character :: c\n\n        columnNumber = 0\n        do i = len(columnTitle), 1, -1\n            c = columnTitle(i:i)\n            if (c >= 'A' .and. c <= 'Z') then\n                columnNumber = columnNumber * 26 + ichar(c) - ichar('A') + 1\n            end if\n        end do\n    end subroutine getColumnNumber\n\nend program main",
  "190": "program main\n    implicit none\n\n    integer(kind=4), parameter :: n = 0_4\n    integer(kind=4), parameter :: expected = 964176192_4\n    integer(kind=4), parameter :: result = reverseBits(n)\n\n    if (result /= expected) then\n        write (*,*) 'Test 1 failed!'\n        stop 1\n    end if\n\n    integer(kind=4), parameter :: n2 = 11111111111111111111111111111101_4\n    integer(kind=4), parameter :: expected2 = 3221225471_4\n    integer(kind=4), parameter :: result2 = reverseBits(n2)\n\n    if (result2 /= expected2) then\n        write (*,*) 'Test 2 failed!'\n        stop 1\n    end if\n\n    contains\n\n    pure function reverseBits(n) result(r)\n        implicit none\n        integer(kind=4), intent(in) :: n\n        integer(kind=4) :: r\n\n        r = iand(n, 1_4) * 8_4 &\n            + iand(n, 2_4) * 4_4 &\n            + iand(n, 4_4) * 2_4 &\n            + iand(n, 8_4) * 1_4 &\n            + iand(n, 16_4) * 8_4 &\n            + iand(n, 32_4) * 4_4 &\n            + iand(n, 64_4) * 2_4 &\n            + iand(n, 128_4) * 1_4 &\n            + iand(n, 256_4) * 8_4 &\n            + iand(n, 512_4) * 4_4 &\n            + iand(n, 1024_4) * 2_4 &\n            + iand(n, 2048_4) * 1_4 &\n            + iand(n, 4096_4) * 8_4 &\n            + iand(n, 8192_4) * 4_4 &\n            + iand(n, 16384_4) * 2_4 &\n            + iand(n, 32768_4) * 1_4 &\n            + iand(n, 65536_4) * 8_4 &\n            + iand(n, 131072_4) * 4_4 &\n            + iand(n, 262144_4) * 2_4 &\n            + iand(n, 524288_4) * 1_4 &\n            + iand(n, 1048576_4) * 8_4 &\n            + iand(n, 2097152_4) * 4_4 &\n            + iand(n, 4194304_4) * 2_4 &\n            + iand(n, 8388608_4) * 1_4 &\n            + iand(n, 16777216_4) * 8_4 &\n            + iand(n, 33554432_4) * 4_4 &\n            + iand(n, 67108864_4) * 2_4 &\n            + iand(n, 134217728_4) * 1_4 &\n            + iand(n, 268435456_4) * 8_4 &\n            + iand(n, 536870912_4) * 4_4 &\n            + iand(n, 1073741824_4) * 2_4 &\n            + iand(n, -2147483648_4) * 1_4\n    end function reverseBits",
  "191": "program main\n    implicit none\n\n    call test_hamming_weight()\n\ncontains\n\n    subroutine test_hamming_weight()\n        implicit none\n\n        integer :: i\n        character(len=32) :: bin_str\n        integer :: num_ones\n\n        ! Example 1\n        bin_str = \"00000000000000000000000000001011\"\n        num_ones = hamming_weight(bin_str)\n        write (*,*) \"Example 1:\"\n        write (*,'(*(g0))') \"Input: \", trim(bin_str)\n        write (*,'(*(g0))') \"Output:\", num_ones\n\n        ! Example 2\n        bin_str = \"00000000000000000000000010000000\"\n        num_ones = hamming_weight(bin_str)\n        write (*,*) \"Example 2:\"\n        write (*,'(*(g0))') \"Input: \", trim(bin_str)\n        write (*,'(*(g0))') \"Output:\", num_ones\n\n        ! Example 3\n        bin_str = \"11111111111111111111111111111101\"\n        num_ones = hamming_weight(bin_str)\n        write (*,*) \"Example 3:\"\n        write (*,'(*(g0))') \"Input: \", trim(bin_str)\n        write (*,'(*(g0))') \"Output:\", num_ones\n\n    end subroutine test_hamming_weight\n\nend program main\n\nfunction hamming_weight(n) result(num_ones)\n    implicit none\n    character(len=*), intent(in) :: n\n    integer :: num_ones\n\n    integer :: i\n    logical :: is_one\n\n    num_ones = 0\n    do i = 1, len(n)\n        is_one = n(i:i) == '1'\n        if (is_one) then\n            num_ones = num_ones + 1\n        end if\n    end do\n\nend function hamming_weight",
  "202": "program main\n    implicit none\n\n    integer :: i, j, k, n\n    logical :: is_happy\n\n    ! Example 1:\n    n = 19\n    print '(L1)', is_happy(n)\n\n    ! Example 2:\n    n = 2\n    print '(L1)', is_happy(n)\n\ncontains\n\n    function is_happy(n) result(res)\n        implicit none\n        integer, intent(in) :: n\n        logical :: res\n        integer :: digit, sum\n\n        res = .false.\n        do while (.not. res)\n            sum = 0\n            do while (n > 0)\n                digit = mod(n, 10)\n                sum = sum + digit * digit\n                n = n / 10\n            end do\n            if (sum == 1) then\n                res = .true.\n            else if (any(sum == (/1, 4, 16, 64, 256, 1024, 4096, 16384, 65536, 262144, 1048576, 4194304, &\n                                    16777216, 67108864, 268435456, 1073741824, 4294967296, 17179869184, 68719476736, &\n                                    274877906944, 1099511627776, 4398046511104, 17592186044416, 68056473382080, &\n                                    271733870592640, 1061109552166400, 4304672601635200, 17014118346046928, &\n                                    67772156103030912, 268553693547528384, 107374182400000000, 429496729600000000/))) then\n                res = .true.\n            else\n                n = sum\n            end if\n        end do\n    end function is_happy\n\nend program main",
  "203": "program main\n    use :: linked_list_mod\n    implicit none\n\n    type(linked_list) :: head\n    integer :: val\n\n    ! Example 1\n    call head%push(1)\n    call head%push(2)\n    call head%push(6)\n    call head%push(3)\n    call head%push(4)\n    call head%push(5)\n    call head%push(6)\n    val = 6\n    print '(A)', 'Example 1:'\n    print '(A)', 'Input: head = [' // head%to_string() // '], val = ', val\n    print '(A)', 'Output: head = [' // remove_nodes(head, val)%to_string() // ']'\n\n    ! Example 2\n    call head%clear()\n    val = 1\n    print '(A)', 'Example 2:'\n    print '(A)', 'Input: head = [' // head%to_string() // '], val = ', val\n    print '(A)', 'Output: head = [' // remove_nodes(head, val)%to_string() // ']'\n\n    ! Example 3\n    call head%clear()\n    call head%push(7)\n    call head%push(7)\n    call head%push(7)\n    call head%push(7)\n    val = 7\n    print '(A)', 'Example 3:'\n    print '(A)', 'Input: head = [' // head%to_string() // '], val = ', val\n    print '(A)', 'Output: head = [' // remove_nodes(head, val)%to_string() // ']'\n\ncontains\n\n    function remove_nodes(head, val) result(new_head)\n        type(linked_list), intent(inout) :: head\n        integer, value :: val\n        type(linked_list) :: new_head\n\n        type(linked_list), pointer :: current => null(), next => null()\n\n        if (associated(head)) then\n            current => head\n            do while (associated(current))\n                next => current%next\n                if (current%val == val) then\n                    deallocate(current)\n                else\n                    allocate(new_head)\n                    new_head%val = current%val\n                    new_head%next => next\n                    current => next\n                end if\n            end do\n        end if\n    end function remove_nodes\n\nend program main",
  "205": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=:), allocatable :: s, t\n    logical :: is_isomorphic\n\n    ! Example 1: egg -> add\n    s = 'egg'\n    t = 'add'\n    write(*,*) 'Example 1:'\n    write(*,*) 's = ', s\n    write(*,*) 't = ', t\n    call solve(s, t)\n    write(*,*) 'Is isomorphic? ', is_isomorphic\n    write(*,*) ''\n\n    ! Example 2: foo -> bar\n    s = 'foo'\n    t = 'bar'\n    write(*,*) 'Example 2:'\n    write(*,*) 's = ', s\n    write(*,*) 't = ', t\n    call solve(s, t)\n    write(*,*) 'Is isomorphic? ', is_isomorphic\n    write(*,*) ''\n\n    ! Example 3: paper -> title\n    s = 'paper'\n    t = 'title'\n    write(*,*) 'Example 3:'\n    write(*,*) 's = ', s\n    write(*,*) 't = ', t\n    call solve(s, t)\n    write(*,*) 'Is isomorphic? ', is_isomorphic\n    write(*,*) ''\n\ncontains\n\n    subroutine solve(s, t)\n        implicit none\n        character(len=*), intent(in) :: s, t\n        logical :: is_isomorphic\n\n        is_isomorphic = .false.\n\n        do i = 1, len(s)\n            do j = 1, len(t)\n                if (s(i:i) == t(j:j)) then\n                    is_isomorphic = .true.\n                    exit\n                end if\n            end do\n        end do\n\n    end subroutine solve\n\nend program main",
  "206": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    type :: node\n        integer(kind=DP) :: val\n        type(node), pointer :: next => null()\n    end type\n    type(node), pointer :: head => null(), current => null()\n    integer :: i\n\n    ! Example 1\n    allocate(head)\n    head%val = 1\n    allocate(current, source=head)\n    do i = 2, 5\n        allocate(current%next)\n        current%next%val = i\n        current => current%next\n    end do\n    call print_list(head)\n    call reverse_list(head)\n    call print_list(head)\n    deallocate(head)\n\n    ! Example 2\n    allocate(head)\n    head%val = 1\n    allocate(current, source=head)\n    do i = 2, 2\n        allocate(current%next)\n        current%next%val = i\n        current => current%next\n    end do\n    call print_list(head)\n    call reverse_list(head)\n    call print_list(head)\n    deallocate(head)\n\n    ! Example 3\n    allocate(head)\n    call print_list(head)\n    call reverse_list(head)\n    call print_list(head)\n    deallocate(head)\n\ncontains\n\n    subroutine print_list(head)\n        type(node), pointer :: head\n        type(node), pointer :: current\n\n        write (unit=error_unit, fmt='(*(I0, 1X))') 'List:'\n        current => head\n        do while (associated(current))\n            write (unit=error_unit, fmt='(I0, 1X)') current%val\n            current => current%next\n        end do\n        write (unit=error_unit, fmt='()')\n    end subroutine\n\n    recursive subroutine reverse_list(head)\n        type(node), pointer :: head\n        type(node), pointer :: current, previous\n\n        if (.not. associated(head)) then\n            return\n        end if\n\n        current => head\n        previous => null()\n        do while (associated(current%next))\n            previous => current\n            current => current%next\n        end do\n        current%next => previous\n        head => current\n    end subroutine\n\nend program",
  "217": "program main\n    implicit none\n\n    integer, parameter :: n = 10\n    integer, dimension(n) :: nums\n    logical :: result\n\n    ! Example 1\n    nums = [1, 2, 3, 1]\n    result = repeated_element(nums)\n    write (*, '(L1)') result\n\n    ! Example 2\n    nums = [1, 2, 3, 4]\n    result = repeated_element(nums)\n    write (*, '(L1)') result\n\n    ! Example 3\n    nums = [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]\n    result = repeated_element(nums)\n    write (*, '(L1)') result\n\ncontains\n\n    function repeated_element(nums) result(result_)\n        implicit none\n        integer, intent(in) :: nums(:)\n        logical :: result_\n\n        integer :: i, j\n\n        do i = 1, size(nums) - 1\n            do j = i + 1, size(nums)\n                if (nums(i) == nums(j)) then\n                    result_ = .true.\n                    exit\n                end if\n            end do\n            if (result_) exit\n        end do\n\n    end function repeated_element\n\nend program main",
  "219": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums\n    integer :: k\n    logical :: result\n\n    ! Example 1\n    nums = [1, 2, 3, 1]\n    k = 3\n    result = contains_duplicate(nums, k)\n    print '(L1)', result\n\n    ! Example 2\n    nums = [1, 0, 1, 1]\n    k = 1\n    result = contains_duplicate(nums, k)\n    print '(L1)', result\n\n    ! Example 3\n    nums = [1, 2, 3, 1, 2, 3]\n    k = 2\n    result = contains_duplicate(nums, k)\n    print '(L1)', result\n\ncontains\n\n    function contains_duplicate(nums, k) result(res)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, intent(in) :: k\n        logical :: res\n        integer :: i, j\n\n        res = .false.\n        do i = 1, size(nums) - 1\n            do j = i + 1, size(nums)\n                if (nums(i) == nums(j)) then\n                    if (abs(i - j) <= k) then\n                        res = .true.\n                        exit\n                    end if\n                end if\n            end do\n        end do\n    end function contains_duplicate\nend program main",
  "225": "program main\n    ! This program implements a last-in-first-out (LIFO) stack using only two queues.\n    implicit none\n\n    type :: MyStack\n        private\n        integer, allocatable :: q1(:), q2(:)\n        integer :: size\n    contains\n        procedure :: push => push_impl\n        procedure :: pop => pop_impl\n        procedure :: top => top_impl\n        procedure :: empty => empty_impl\n    end type MyStack\n\n    interface MyStack\n        module procedure constructor\n    end interface MyStack\n\ncontains\n\n    function constructor() result(stack)\n        type(MyStack) :: stack\n\n        allocate(stack%q1(0))\n        allocate(stack%q2(0))\n        stack%size = 0\n    end function constructor\n\n    subroutine push_impl(this, x)\n        class(MyStack), intent(inout) :: this\n        integer, value :: x\n\n        if (allocated(this%q1)) then\n            call move_alloc(this%q1, this%q2)\n        else\n            allocate(this%q1(0))\n        end if\n        allocate(this%q1(this%size + 1))\n        this%q1(this%size + 1) = x\n        this%size = this%size + 1\n    end subroutine push_impl\n\n    function pop_impl(this) result(x)\n        class(MyStack), intent(inout) :: this\n        integer :: x\n\n        if (.not. allocated(this%q1)) then\n            error stop 'Error: pop called on empty stack.'\n        end if\n        x = this%q1(this%size)\n        this%size = this%size - 1\n        if (this%size == 0) then\n            deallocate(this%q1)\n            if (allocated(this%q2)) then\n                call move_alloc(this%q2, this%q1)\n            end if\n        end if\n    end function pop_impl\n\n    function top_impl(this) result(x)\n        class(MyStack), intent(in) :: this\n        integer :: x\n\n        if (.not. allocated(this%q1)) then\n            error stop 'Error: top called on empty stack.'\n        end if\n        x = this%q1(this%size)\n    end function top_impl\n\n    logical function empty_impl(this)\n        class(MyStack), intent(in) :: this\n\n        empty_impl = .not. allocated(this%q1)\n    end function empty_impl\n\nend program main",
  "226": "program main\n    ! Solve the problem described in the statement\n    implicit none\n\n    type :: TreeNode\n        integer :: val\n        type(TreeNode), pointer :: left => null(), right => null()\n    end type TreeNode\n\n    type(TreeNode), target :: root\n    type(TreeNode), pointer :: current\n    integer :: i\n\n    ! Examples\n    call invertTree(root)\n    print \"(A)\", \"Example 1:\"\n    do i = 1, size(root%left)\n        print \"(I0)\", root%left(i)%val\n    end do\n    print *, \"\"\n    do i = 1, size(root%right)\n        print \"(I0)\", root%right(i)%val\n    end do\n    print *, \"\"\n\n    call invertTree(root)\n    print \"(A)\", \"Example 2:\"\n    do i = 1, size(root%left)\n        print \"(I0)\", root%left(i)%val\n    end do\n    print *, \"\"\n    do i = 1, size(root%right)\n        print \"(I0)\", root%right(i)%val\n    end do\n    print *, \"\"\n\n    call invertTree(root)\n    print \"(A)\", \"Example 3:\"\n    do i = 1, size(root%left)\n        print \"(I0)\", root%left(i)%val\n    end do\n    print *, \"\"\n    do i = 1, size(root%right)\n        print \"(I0)\", root%right(i)%val\n    end do\n    print *, \"\"\n\ncontains\n\n    subroutine invertTree(root)\n        ! Invert the tree and return its root\n        implicit none\n        type(TreeNode), intent(inout) :: root\n        type(TreeNode), pointer :: current\n        type(TreeNode), pointer :: temp\n\n        if (associated(root)) then\n            current => root\n            do while (associated(current))\n                ! Swap the left and right pointers\n                temp => current%left\n                current%left => current%right\n                current%right => temp\n\n                ! Recursively invert the left and right subtrees\n                call invertTree(current%left)\n                call invertTree(current%right)\n\n                ! Move to the next node\n                current => current%right\n            end do\n        end if\n    end subroutine invertTree\n\nend program main",
  "228": "program main\n    implicit none\n\n    integer, parameter :: n = 7\n    integer, dimension(n) :: nums = (/ 0, 1, 2, 4, 5, 7 /)\n    type(range_t), allocatable :: ranges(:)\n\n    call solve(nums, ranges)\n\n    do i = 1, size(ranges)\n        write (*, '(A)') ranges(i)%to_string()\n    end do\n\ncontains\n\n    subroutine solve(nums, ranges)\n        implicit none\n        integer, intent(in) :: nums(:)\n        type(range_t), allocatable, intent(out) :: ranges(:)\n        integer :: i, j, k\n\n        allocate(ranges(size(nums)))\n\n        k = 1\n        do i = 1, size(nums)-1\n            if (nums(i+1) > nums(i)+1) then\n                ranges(k)%start = nums(i)\n                ranges(k)%end = nums(i)\n                k = k + 1\n            end if\n        end do\n        ranges(k)%start = nums(size(nums))\n        ranges(k)%end = nums(size(nums))\n\n    end subroutine solve\n\n    type range_t\n        integer :: start\n        integer :: end\n    contains\n        procedure :: to_string => to_string_range\n    end type range_t\n\n    character(len=100) function to_string_range(self) result(str)\n        implicit none\n        class(range_t), intent(in) :: self\n\n        if (self%start /= self%end) then\n            str = trim(adjustl(str)) // trim(adjustl(str(self%start))) // \"->\" // &\n                  trim(adjustl(str(self%end))) // \" \"\n        else\n            str = trim(adjustl(str)) // trim(adjustl(str(self%start))) // \" \"\n        end if\n\n    end function to_string_range\n\nend program main",
  "231": "program main\n    implicit none\n\n    integer :: n\n    logical :: result\n\n    ! Example 1:\n    n = 1\n    result = is_power_of_two(n)\n    print '(L1)', result\n\n    ! Example 2:\n    n = 16\n    result = is_power_of_two(n)\n    print '(L1)', result\n\n    ! Example 3:\n    n = 3\n    result = is_power_of_two(n)\n    print '(L1)', result\n\ncontains\n\n    function is_power_of_two(n) result(result)\n        implicit none\n        integer, intent(in) :: n\n        logical :: result\n        integer :: x\n\n        result = .false.\n        do x = 1, n\n            if (n == 2 * x) then\n                result = .true.\n                exit\n            end if\n        end do\n    end function is_power_of_two\n\nend program main",
  "232": "program main\n    implicit none\n\n    type :: MyQueue\n        private\n        integer, allocatable :: stack(:)\n        integer :: size = 0\n    contains\n        procedure :: push => push_impl\n        procedure :: pop => pop_impl\n        procedure :: peek => peek_impl\n        procedure :: empty => empty_impl\n    end type MyQueue\n\n    interface MyQueue\n        module procedure constructor\n    end interface MyQueue\n\ncontains\n\n    function constructor() result(queue)\n        type(MyQueue) :: queue\n\n        allocate(queue%stack(0))\n    end function constructor\n\n    subroutine push_impl(queue, x)\n        class(MyQueue), intent(inout) :: queue\n        integer, value :: x\n\n        queue%size = queue%size + 1\n        allocate(queue%stack(queue%size))\n        queue%stack(queue%size) = x\n    end subroutine push_impl\n\n    function pop_impl(queue) result(x)\n        class(MyQueue), intent(inout) :: queue\n        integer :: x\n\n        if (queue%empty()) then\n            error stop 'cannot pop from an empty queue'\n        end if\n\n        x = queue%stack(queue%size)\n        deallocate(queue%stack(queue%size))\n        queue%size = queue%size - 1\n    end function pop_impl\n\n    function peek_impl(queue) result(x)\n        class(MyQueue), intent(in) :: queue\n        integer :: x\n\n        if (queue%empty()) then\n            error stop 'cannot peek from an empty queue'\n        end if\n\n        x = queue%stack(queue%size)\n    end function peek_impl\n\n    logical function empty_impl(queue) result(empty)\n        class(MyQueue), intent(in) :: queue\n\n        empty = queue%size == 0\n    end function empty_impl\n\nend program main",
  "234": "program palindrome_list\n    implicit none\n\n    type :: node\n        integer :: val\n        type(node), pointer :: next => null()\n    end type\n\n    type(node), pointer :: head\n\n    logical :: result\n\n    call test_example1()\n    call test_example2()\n\ncontains\n\n    subroutine test_example1()\n        type(node), pointer :: curr\n        allocate(curr)\n        curr%val = 1\n        curr%next => curr\n        allocate(curr%next)\n        curr%next%val = 2\n        curr%next%next => curr\n        allocate(curr%next%next)\n        curr%next%next%val = 2\n        curr%next%next%next => curr\n        allocate(curr%next%next%next)\n        curr%next%next%next%val = 1\n        curr%next%next%next%next => null()\n        result = is_palindrome(head)\n        write (*, '(A, L1)') 'Example 1: ', result\n    end subroutine\n\n    subroutine test_example2()\n        type(node), pointer :: curr\n        allocate(curr)\n        curr%val = 1\n        curr%next => curr\n        allocate(curr%next)\n        curr%next%val = 2\n        curr%next%next => null()\n        result = is_palindrome(head)\n        write (*, '(A, L1)') 'Example 2: ', result\n    end subroutine\n\n    function is_palindrome(head) result(result_)\n        type(node), pointer, intent(in) :: head\n        type(node), pointer :: slow, fast\n        logical :: result_\n\n        slow => head\n        fast => head\n        do while (associated(fast))\n            if (.not. associated(fast%next)) exit\n            fast => fast%next%next\n            slow => slow%next\n        end do\n\n        result_ = .true.\n        do while (associated(slow))\n            if (slow%val /= fast%val) then\n                result_ = .false.\n                exit\n            end if\n            slow => slow%next\n            fast => fast%next\n        end do\n    end function\n\nend program",
  "242": "program main\n    use anagram_solution\n    implicit none\n\n    character(len=:), allocatable :: s, t\n    logical :: result\n\n    ! Example 1\n    s = 'anagram'\n    t = 'nagaram'\n    result = is_anagram(s, t)\n    write (unit=*, fmt='(L1)') result\n\n    ! Example 2\n    s = 'rat'\n    t = 'car'\n    result = is_anagram(s, t)\n    write (unit=*, fmt='(L1)') result\n\nend program main",
  "243": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    character(len=10), dimension(n) :: wordsDict = [\"practice \", \"makes \", \"perfect \", \"coding \", \"makes \"]\n    character(len=10), intent(in) :: word1, word2\n    integer :: dist\n\n    call solve(wordsDict, word1, word2, dist)\n    print '(I0)', dist\n\ncontains\n\n    subroutine solve(wordsDict, word1, word2, dist)\n        implicit none\n        character(len=10), dimension(:), intent(in) :: wordsDict\n        character(len=10), intent(in) :: word1, word2\n        integer, intent(out) :: dist\n        integer :: i, j, k\n\n        do i = 1, size(wordsDict)\n            if (wordsDict(i) == word1) then\n                do j = 1, size(wordsDict)\n                    if (wordsDict(j) == word2) then\n                        dist = min(dist, i - j)\n                    end if\n                end do\n            end if\n        end do\n    end subroutine solve\nend program main",
  "246": "program main\n    implicit none\n\n    character(len=50) :: num\n    logical :: strobogrammatic\n\n    ! Example 1\n    num = \"69\"\n    write(*,*) strobogrammatic(num), \"Expected: True\"\n\n    ! Example 2\n    num = \"88\"\n    write(*,*) strobogrammatic(num), \"Expected: True\"\n\n    ! Example 3\n    num = \"962\"\n    write(*,*) strobogrammatic(num), \"Expected: False\"\n\ncontains\n\n    function strobogrammatic(num) result(res)\n        implicit none\n        character(len=*), intent(in) :: num\n        logical :: res\n\n        if (num == \"\") then\n            res = .false.\n            return\n        end if\n\n        if (num(1:1) /= num(len(num):len_trim(num))) then\n            res = .false.\n            return\n        end if\n\n        res = strobogrammatic(num(2:len(num)-1))\n\n    end function strobogrammatic\n\nend program main",
  "252": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: intervals = reshape([0, 30, 5, 10, 15, 20], shape(intervals))\n\n    write (*, '(L1)') canAttendMeetings(intervals)\n\ncontains\n\n    function canAttendMeetings(intervals) result(canAttend)\n        implicit none\n        integer, intent(in) :: intervals(:, :)\n        logical :: canAttend\n        integer :: i, j, k\n\n        ! Sort the intervals by their starting times\n        do i = 1, size(intervals, 1) - 1\n            do j = i + 1, size(intervals, 1)\n                if (intervals(j, 1) < intervals(i, 1)) then\n                    intervals(j, :) = intervals(j, :) + intervals(i, :) - intervals(j, :)\n                    intervals(i, :) = intervals(j, :) - intervals(i, :)\n                end if\n            end do\n        end do\n\n        ! Check for overlapping intervals\n        canAttend = .true.\n        do i = 1, size(intervals, 1) - 1\n            do j = i + 1, size(intervals, 1)\n                if (intervals(j, 1) >= intervals(i, 2)) exit\n                if (intervals(j, 2) > intervals(i, 2)) then\n                    canAttend = .false.\n                    exit\n                end if\n            end do\n        end do\n\n    end function canAttendMeetings\n\nend program main",
  "257": "program main\n    ! Solves the problem: Given the `root` of a binary tree, return all root-to-leaf paths in any order.\n    implicit none\n\n    type :: TreeNode\n        integer :: val\n        type(TreeNode), pointer :: left => null(), right => null()\n    end type TreeNode\n\n    type(TreeNode), target :: root\n    character(len=:), allocatable :: str\n\n    call solve(root)\n\ncontains\n\n    subroutine solve(root)\n        ! Solve the problem\n        type(TreeNode), intent(inout) :: root\n        type(TreeNode), pointer :: curr\n        integer :: i\n\n        if (associated(root%left)) then\n            call solve(root%left)\n        end if\n        if (associated(root%right)) then\n            call solve(root%right)\n        end if\n\n        if (.not. associated(root%left) .and. .not. associated(root%right)) then\n            write (str, \"(I0)\") root%val\n            do while (associated(curr))\n                write (str, \"(A, I0)\") trim(str), curr%val\n                curr => curr%left\n            end do\n            print '(A)', trim(str) // \" \"\n        end if\n\n    end subroutine solve\n\nend program main",
  "258": "program main\n    implicit none\n\n    integer :: num\n    integer :: i\n    integer :: sum\n\n    num = 38\n    write (*, '(A)') 'Example 1:'\n    write (*, '(A, I0)') 'Input: ', num\n    write (*, '(A, I0)') 'Output:', solve(num)\n\n    num = 0\n    write (*, '(A)') 'Example 2:'\n    write (*, '(A, I0)') 'Input: ', num\n    write (*, '(A, I0)') 'Output:', solve(num)\n\ncontains\n\n    function solve(num) result(sum)\n        implicit none\n        integer, value :: num\n        integer :: sum\n        integer :: digit\n\n        sum = num\n        do while (sum >= 10)\n            digit = mod(sum, 10)\n            sum = sum / 10 + digit\n        end do\n    end function solve\n\nend program main",
  "263": "program main\n    implicit none\n\n    integer :: n\n    logical :: result\n\n    ! Example 1\n    n = 6\n    result = isUgly(n)\n    print '(L1)', result\n\n    ! Example 2\n    n = 1\n    result = isUgly(n)\n    print '(L1)', result\n\n    ! Example 3\n    n = 14\n    result = isUgly(n)\n    print '(L1)', result\n\ncontains\n\n    function isUgly(n) result(res)\n        implicit none\n        integer, intent(in) :: n\n        logical :: res\n        integer :: i\n\n        if (n < 0) then\n            res = .false.\n            return\n        end if\n\n        do i = 2, 5\n            if (mod(n, i) == 0) then\n                n = n / i\n            else\n                res = .false.\n                return\n            end if\n        end do\n\n        res = .true.\n    end function isUgly\nend program main",
  "266": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    logical :: is_palindrome\n\n    ! Example 1\n    s = \"code \"\n    print '(L1)', is_palindrome(s)\n\n    ! Example 2\n    s = \"aab \"\n    print '(L1)', is_palindrome(s)\n\n    ! Example 3\n    s = \"carerac \"\n    print '(L1)', is_palindrome(s)\n\ncontains\n\n    function is_palindrome(str) result(res)\n        implicit none\n        character(len=*), intent(in) :: str\n        integer :: i, j\n        logical :: res\n\n        res = .false.\n\n        do i = 1, len(str)/2\n            if (str(i:i) /= str(len(str)-i+1:len(str)-i)) then\n                exit\n            end if\n        end do\n\n        if (i == len(str)/2 + 1) then\n            res = .true.\n        end if\n    end function is_palindrome\nend program main",
  "268": "program main\n    implicit none\n\n    integer, parameter :: n = 9\n    integer, dimension(n) :: nums = (/ 3, 0, 1, 2, 4, 5, 6, 7, 8 /)\n    integer :: i, j, k, l, m, n_missing\n\n    ! Test case 1\n    write (*, '(A)') 'Test case 1:'\n    call solve(nums, n_missing)\n    write (*, '(I0)') n_missing\n    if (n_missing /= 2) then\n        write (*, '(A)') 'Error: Incorrect result.'\n        stop 1\n    end if\n\n    ! Test case 2\n    write (*, '(A)') 'Test case 2:'\n    nums = (/ 0, 1 /)\n    call solve(nums, n_missing)\n    write (*, '(I0)') n_missing\n    if (n_missing /= 2) then\n        write (*, '(A)') 'Error: Incorrect result.'\n        stop 1\n    end if\n\n    ! Test case 3\n    write (*, '(A)') 'Test case 3:'\n    nums = (/ 9, 6, 4, 2, 3, 5, 7, 0, 1 /)\n    call solve(nums, n_missing)\n    write (*, '(I0)') n_missing\n    if (n_missing /= 8) then\n        write (*, '(A)') 'Error: Incorrect result.'\n        stop 1\n    end if\n\ncontains\n\n    subroutine solve(nums, n_missing)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer, intent(out) :: n_missing\n        integer :: i, j, k, l, m, n\n\n        n = size(nums)\n        do i = 0, n - 1\n            do j = i + 1, n - 1\n                if (nums(i) == nums(j)) then\n                    write (*, '(A)') 'Error: Duplicate value found.'\n                    stop 1\n                end if\n            end do\n        end do\n\n        do i = 0, n - 1\n            if (.not. any(nums == i)) then\n                n_missing = i\n                return\n            end if\n        end do\n\n        write (*, '(A)') 'Error: No missing value found.'\n        stop 1\n\n    end subroutine solve\n\nend program main",
  "270": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, iostat_end, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    type :: node_type\n        real(kind=DP) :: val\n        class(node_type), pointer :: left => null(), right => null()\n    end type node_type\n    type (node_type), pointer :: root\n    real(kind=DP) :: target\n    character(len=*), parameter :: fmt = '(A,F10.5)'\n    integer :: ios\n\n    call get_root(root)\n    read (unit=unit_in, fmt='(F10.5)', iostat=ios) target\n    if (ios /= 0 .and. ios /= iostat_end) then\n        write (unit=error_unit, fmt='(\"error reading input: \", A)') trim(adjustl(str(ios)))\n        stop 1\n    end if\n    if (ios == iostat_end) then\n        ! No more input, exit\n        stop 0\n    end if\n\n    call solve(root, target)\n\ncontains\n\n    subroutine get_root(root)\n        type (node_type), pointer :: root\n        real(kind=DP) :: val\n        integer :: ios\n\n        do\n            read (unit=unit_in, fmt='(F10.5)', iostat=ios) val\n            if (ios /= 0 .and. ios /= iostat_end) then\n                write (unit=error_unit, fmt='(\"error reading input: \", A)') trim(adjustl(str(ios)))\n                stop 1\n            end if\n            if (ios == iostat_end) then\n                ! No more input, exit\n                exit\n            end if\n            allocate (root)\n            root%val = val\n            call get_left(root%left)\n            call get_right(root%right)\n        end do\n    end subroutine get_root\n\n    subroutine get_left(left)\n        type (node_type), pointer :: left\n        real(kind=DP) :: val\n        integer :: ios\n\n        do\n            read (unit=unit_in, fmt='(F10.5)', iostat=ios) val\n            if (ios /= 0 .and. ios /= iostat_end) then\n                write (unit=error_unit, fmt='(\"error reading input: \", A)') trim(adjustl(str(ios)))\n                stop 1\n            end if\n            if (ios == iostat_end) then\n                ! No more input, exit\n                exit\n            end if\n            allocate (left)\n            left%val = val\n            call get_left(left%left)\n            call get_right(left%right)\n        end do\n    end subroutine get_left\n\n    subroutine get_right(right)\n        type (node_type), pointer :: right\n        real(kind=DP) :: val\n        integer :: ios\n\n        do\n            read (unit=unit_in, fmt='(F10.5)', iostat=ios) val\n            if (ios /= 0 .and. ios /= iostat_end) then\n                write (unit=error_unit, fmt='(\"error reading input: \", A)') trim(adjustl(str(ios)))\n                stop 1\n            end if\n            if (ios == iostat_end) then\n                ! No more input, exit\n                exit\n            end if\n            allocate (right)\n            right%val = val\n            call get_left(right%left)\n            call get_right(right%right)\n        end do\n    end subroutine get_right\n\n    subroutine solve(root, target)\n        type (node_type), pointer :: root\n        real(kind=DP), intent(in) :: target\n        real(kind=DP) :: diff, min_diff\n        type (node_type), pointer :: current\n\n        current => root\n        min_diff = huge(min_diff)\n        do while (associated(current))\n            diff = abs(current%val - target)\n            if (diff < min_",
  "278": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer :: n, i, j\n    logical :: bad\n    real(kind=DP) :: x\n\n    ! read input\n    read (*, *) n\n\n    ! solve problem\n    do i = 1, n\n        call isBadVersion(i, bad)\n        if (bad) then\n            write (unit=error_unit, fmt='(A, I0)') 'First bad version: ', i\n            exit\n        end if\n    end do\n\ncontains\n\n    subroutine isBadVersion(version, bad)\n        implicit none\n        integer, value :: version\n        logical, intent(out) :: bad\n\n        select case (version)\n        case (1)\n            bad = .false.\n        case (2)\n            bad = .true.\n        case (3)\n            bad = .false.\n        case (4)\n            bad = .true.\n        case (5)\n            bad = .true.\n        case default\n            bad = .false.\n        end select\n    end subroutine isBadVersion\nend program main",
  "283": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer :: nums(n) = [0, 1, 0, 3, 12]\n    integer :: i, j\n\n    call move_zeros(nums)\n\n    write (*, '(A)') 'Expected:'\n    write (*, '(A)') '[1, 3, 12, 0, 0]'\n    write (*, '(A)') 'Actual:'\n    write (*, '(A)') nums\n\ncontains\n\nsubroutine move_zeros(nums)\n    implicit none\n    integer, intent(inout) :: nums(:)\n    integer :: i, j\n\n    i = 1\n    j = 1\n    do while (j <= size(nums))\n        if (nums(j) /= 0) then\n            nums(i) = nums(j)\n            i = i + 1\n        end if\n        j = j + 1\n    end do\nend subroutine move_zeros\n\nend program main",
  "290": "program main\n    implicit none\n\n    character(len=*), parameter :: pattern = \"abba \"\n    character(len=*), parameter :: s1 = \"dog cat cat dog \"\n    character(len=*), parameter :: s2 = \"dog cat cat fish \"\n    character(len=*), parameter :: s3 = \"dog cat cat dog\"\n\n    logical :: result1, result2, result3\n\n    result1 = follows_pattern(pattern, s1)\n    result2 = follows_pattern(pattern, s2)\n    result3 = follows_pattern(pattern, s3)\n\n    write (*,*) result1\n    write (*,*) result2\n    write (*,*) result3\n\ncontains\n\n    function follows_pattern(pattern, s) result(result)\n        implicit none\n        character(len=*), intent(in) :: pattern\n        character(len=*), intent(in) :: s\n        integer :: i, j, k\n        logical :: result\n\n        result = .false.\n\n        ! Check if the length of the pattern and the input string are equal\n        if (len(trim(pattern)) /= len(trim(s))) return\n\n        ! Check if the pattern and the input string have the same number of words\n        do i = 1, len(trim(pattern))\n            if (index(trim(pattern), ' ') /= index(trim(s), ' ')) return\n        end do\n\n        ! Check if there is a bijection between each letter in the pattern and a non-empty word in the input string\n        do i = 1, len(trim(pattern))\n            k = index(trim(pattern), ' ')\n            do j = 1, len(trim(s))\n                if (trim(s)(j:j) == trim(pattern)(i:i)) then\n                    if (trim(s)(k+1:) /= '') then\n                        result = .true.\n                        exit\n                    end if\n                end if\n            end do\n        end do\n\n    end function follows_pattern\n\nend program main",
  "292": "program nim_game\n    implicit none\n\n    integer :: n, i, j, k\n    logical :: can_win\n\n    ! Examples\n    n = 4\n    write (*, '(L1)') can_win(n)\n    n = 1\n    write (*, '(L1)') can_win(n)\n    n = 2\n    write (*, '(L1)') can_win(n)\n\ncontains\n\n    function can_win(n) result(can_win_)\n        implicit none\n        integer, intent(in) :: n\n        logical :: can_win_\n\n        if (n == 1) then\n            can_win_ = .true.\n        else if (n == 2) then\n            can_win_ = .true.\n        else if (mod(n, 4) == 0) then\n            can_win_ = .false.\n        else\n            do i = 1, n-1\n                do j = 1, min(i+1, n-i)\n                    do k = 1, min(j+1, n-j)\n                        if (.not. can_win(n-k)) then\n                            can_win_ = .true.\n                            return\n                        end if\n                    end do\n                end do\n            end do\n            can_win_ = .false.\n        end if\n    end function can_win\n\nend program nim_game",
  "293": "program main\n    implicit none\n\n    character(len=500) :: currentState\n    character(len=500), allocatable :: possibleStates(:)\n    integer :: i, j, k\n\n    ! Example 1\n    currentState = \"++++ \"\n    call solveFlipGame(currentState, possibleStates)\n    do i = 1, size(possibleStates)\n        write (*, '(A)') trim(possibleStates(i))\n    end do\n\n    ! Example 2\n    currentState = \"+ \"\n    call solveFlipGame(currentState, possibleStates)\n    if (size(possibleStates) > 0) then\n        write (*, '(A)') trim(possibleStates(1))\n    else\n        write (*, '(A)') \"[ ]\"\n    end if\n\ncontains\n\n    subroutine solveFlipGame(currentState, possibleStates)\n        implicit none\n        character(len=*), intent(in) :: currentState\n        character(len=*), allocatable, intent(out) :: possibleStates(:)\n        integer :: i, j, k\n\n        allocate(possibleStates(0))\n\n        ! Check if we can make a move\n        do i = 1, len_trim(currentState)-1\n            if (currentState(i:i+1) == \"++ \") then\n                ! We can make a move, add it to the list of possible states\n                allocate(possibleStates(size(possibleStates)+1))\n                possibleStates(size(possibleStates)) = currentState(1:i-1) // \"--\" // currentState(i+3:)\n            end if\n        end do\n\n    end subroutine solveFlipGame\nend program main",
  "303": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 6\n    integer, parameter :: m = 4\n    integer, dimension(n) :: nums = [-2, 0, 3, -5, 2, -1]\n    integer, dimension(m, 2) :: queries = reshape([0, 2, &\n                                                    2, 5, &\n                                                    0, 5], shape=[m, 2])\n    type(NumArray) :: na\n    integer :: i, j\n\n    ! Initialize the NumArray object\n    na = NumArray(nums)\n\n    ! Print the results for each query\n    do i = 1, size(queries, 1)\n        write (unit=error_unit, fmt='(*(g0))') 'Sum of elements between ', &\n            queries(i, 1), ' and ', queries(i, 2), ' inclusive: ', &\n            na%sumRange(queries(i, 1), queries(i, 2))\n    end do\n\ncontains\n\n    type NumArray\n        private\n        integer, allocatable :: nums(:)\n\n        contains\n            procedure, public :: sumRange\n            generic :: operator(.sum.) => sumRange\n    end type NumArray\n\n    interface NumArray\n        module procedure :: constructor\n    end interface NumArray\n\n    function constructor(nums) result(this)\n        implicit none\n        integer, intent(in) :: nums(:)\n        type(NumArray) :: this\n\n        allocate(this%nums(size(nums)))\n        this%nums = nums\n    end function constructor\n\n    function sumRange(this, left, right) result(sum)\n        implicit none\n        class(NumArray), intent(in) :: this\n        integer, value :: left, right\n        integer :: sum\n\n        sum = sum(this%nums(left:right))\n    end function sumRange\n\nend program main",
  "326": "program main\n    implicit none\n\n    integer :: n\n    logical :: result\n\n    print '(L1)', solve_power_of_three(27, result)\n    print '(L1)', solve_power_of_three(0, result)\n    print '(L1)', solve_power_of_three(-1, result)\n\ncontains\n\n    function solve_power_of_three(n, result) result (result)\n        implicit none\n        integer, intent(in) :: n\n        logical, intent(out) :: result\n        integer :: x\n\n        result = .false.\n        do while (n > 0)\n            x = n / 3\n            if (x * 3 == n) then\n                result = .true.\n                exit\n            end if\n            n = x\n        end do\n    end function solve_power_of_three\n\nend program main",
  "338": "program main\n    implicit none\n\n    integer :: n, ans(n+1)\n\n    ! Example 1\n    n = 2\n    call solve(n, ans)\n    write(*,*) \"Example 1:\"\n    write(*,*) \"n = \", n\n    write(*,*) \"ans = \", ans\n\n    ! Example 2\n    n = 5\n    call solve(n, ans)\n    write(*,*) \"Example 2:\"\n    write(*,*) \"n = \", n\n    write(*,*) \"ans = \", ans\n\ncontains\n\n    subroutine solve(n, ans)\n        implicit none\n        integer, intent(in) :: n\n        integer, intent(out) :: ans(n+1)\n\n        integer :: i\n\n        do i=0, n\n            ans(i+1) = count_ones(i)\n        end do\n\n    end subroutine solve\n\nend program main\n\nfunction count_ones(n) result(num_ones)\n    implicit none\n    integer, value :: n\n    integer :: num_ones\n\n    integer :: mask\n\n    mask = 1\n    do while (mask <= n)\n        if (mod(n, mask) == 0) then\n            num_ones = num_ones + 1\n        end if\n        mask = mask * 2\n    end do\n\nend function count_ones",
  "342": "program main\n    implicit none\n\n    integer :: n\n    logical :: result\n\n    ! Example 1: 16\n    n = 16\n    result = is_power_of_four(n)\n    print '(L1)', result\n\n    ! Example 2: 5\n    n = 5\n    result = is_power_of_four(n)\n    print '(L1)', result\n\n    ! Example 3: 1\n    n = 1\n    result = is_power_of_four(n)\n    print '(L1)', result\n\ncontains\n\n    function is_power_of_four(n) result(result)\n        implicit none\n        integer, intent(in) :: n\n        logical :: result\n        integer :: x\n\n        result = .false.\n        do while (n > 0)\n            x = n / 4\n            if (x * 4 == n) then\n                result = .true.\n                exit\n            end if\n            n = x\n        end do\n    end function is_power_of_four\n\nend program main",
  "344": "program main\n    implicit none\n\n    call test_reverse()\n\ncontains\n\n    subroutine test_reverse()\n        character(len=10), parameter :: example1 = \"hello\"\n        character(len=10), parameter :: example2 = \"Hannah\"\n        character(len=10) :: result\n\n        print \"(A)\", \"Testing reverse()\"\n        print \"(A, A)\", \"Example 1: \", example1\n        result = reverse(example1)\n        print \"(A, A)\", \"Result:     \", result\n        print \"(A, L)\", \"Correct?:   \", result == \"olleh\"\n        print \"(/)\"\n\n        print \"(A, A)\", \"Example 2: \", example2\n        result = reverse(example2)\n        print \"(A, A)\", \"Result:     \", result\n        print \"(A, L)\", \"Correct?:   \", result == \"hannah\"\n        print \"(/)\"\n    end subroutine test_reverse\n\nend program main\n\nfunction reverse(s) result(r)\n    implicit none\n    character(len=*), intent(inout) :: s(:) !< Input string (modified in place)\n    character(len=size(s)) :: r            !< Reversed string\n\n    integer :: i, j\n\n    ! Loop from the last element to the first one\n    do i = size(s), 1, -1\n        ! Swap the current element with the corresponding element in the\n        ! reversed string\n        j = size(s) - i + 1\n        call swap(s(i), r(j))\n    end do\n\n    return\nend function reverse\n\nsubroutine swap(x, y)\n    implicit none\n    character(len=*), intent(inout) :: x, y\n    character(len=len(x)) :: tmp\n\n    tmp = x\n    x = y\n    y = tmp\n\n    return\nend subroutine swap",
  "345": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    integer :: i, n\n\n    ! Example 1\n    s = \"hello\"\n    print '(A)', reverse_vowels(s)\n\n    ! Example 2\n    s = \"leetcode\"\n    print '(A)', reverse_vowels(s)\n\ncontains\n\n    function reverse_vowels(str) result(res)\n        implicit none\n        character(len=*), intent(in) :: str\n        character(len=len(str)), allocatable :: res\n        logical :: is_vowel\n\n        allocate(character(len=len(str)) :: res)\n        res = str\n\n        do i = 1, len(str)\n            if (is_vowel(res(i:i))) then\n                call reverse_substring(res, i, i)\n            end if\n        end do\n\n    contains\n\n        pure logical function is_vowel(c)\n            implicit none\n            character, intent(in) :: c\n\n            select case (c)\n            case ('a', 'e', 'i', 'o', 'u')\n                is_vowel = .true.\n            case default\n                is_vowel = .false.\n            end select\n        end function is_vowel\n\n        subroutine reverse_substring(str, start, end)\n            implicit none\n            character(len=*), intent(inout) :: str\n            integer, value :: start, end\n            integer :: i\n\n            do i = start, (start + end)/2\n                call swap_chars(str, i, end - i + start)\n            end do\n        end subroutine reverse_substring\n\n        subroutine swap_chars(str, i, j)\n            implicit none\n            character(len=*), intent(inout) :: str\n            integer, value :: i, j\n            character :: tmp\n\n            tmp = str(i:i)\n            str(i:i) = str(j:j)\n            str(j:j) = tmp\n        end subroutine swap_chars\n\n    end function reverse_vowels\nend program main",
  "346": "program main\n    use :: moving_average_mod\n    implicit none\n\n    type(MovingAverage) :: moving_average\n    integer :: i, n\n    integer, parameter :: size = 3\n\n    ! Example 1\n    write (*, \"(A)\") \"Example 1:\"\n    write (*, \"(A)\") \"Input:\"\n    write (*, \"(A)\") \"[ 'MovingAverage ', 'next ', 'next ', 'next ', 'next ']\"\n    write (*, \"(A)\") \"[\"\n    do i = 1, size\n        write (*, \"(I0)\", advance=\"no\") i\n        if (i < size) then\n            write (*, \"(A)\", advance=\"no\") \", \"\n        end if\n    end do\n    write (*, *) \"]\"\n    write (*, \"(A)\") \"Output:\"\n    write (*, \"(A)\") \"[null, 1.0, 5.5, 4.66667, 6.0]\"\n    write (*, \"(A)\") \"\"\n\n    moving_average = MovingAverage(size)\n    do i = 1, size\n        call moving_average%next(i)\n    end do\n    write (*, \"(F8.5)\") moving_average%next(3)\n    write (*, \"(F8.5)\") moving_average%next(10)\n    write (*, \"(F8.5)\") moving_average%next(3)\n    write (*, \"(F8.5)\") moving_average%next(5)\n\n    ! Example 2\n    write (*, \"(A)\") \"Example 2:\"\n    write (*, \"(A)\") \"Input:\"\n    write (*, \"(A)\") \"[ 'MovingAverage ', 'next ', 'next ', 'next ', 'next ']\"\n    write (*, \"(A)\") \"[\"\n    do i = 1, size\n        write (*, \"(I0)\", advance=\"no\") i\n        if (i < size) then\n            write (*, \"(A)\", advance=\"no\") \", \"\n        end if\n    end do\n    write (*, *) \"]\"\n    write (*, \"(A)\") \"Output:\"\n    write (*, \"(A)\") \"[null, 1.0, 5.5, 4.66667, 6.0]\"\n    write (*, \"(A)\") \"\"\n\n    moving_average = MovingAverage(size)\n    do i = 1, size\n        call moving_average%next(i)\n    end do\n    write (*, \"(F8.5)\") moving_average%next(3)\n    write (*, \"(F8.5)\") moving_average%next(10)\n    write (*, \"(F8.5)\") moving_average%next(3)\n    write (*, \"(F8.5)\") moving_average%next(5)\n\nend program main\n\nmodule moving_average_mod\n    implicit none\n    private\n\n    public :: MovingAverage\n\n    type :: MovingAverage\n        private\n        integer :: size\n        real, allocatable :: buffer(:)\n    contains\n        procedure :: next => next_moving_average\n    end type MovingAverage\n\ncontains\n\n    function next_moving_average(this, val) result(res)\n        class(MovingAverage), intent(inout) :: this\n        integer, value :: val\n        real :: res\n\n        if (.not. allocated(this%buffer)) then\n            allocate(this%buffer(this%size))\n            this%buffer = 0.0\n        end if\n\n        this%buffer(1:this%size-1) = this%buffer(2:this%size)\n        this%buffer(this%size) = val\n\n        res = sum(this%buffer) / real(this%size)\n\n    end function next_moving_average\n\nend module moving_average_mod",
  "349": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums1 = [1, 2, 2, 1]\n    integer, dimension(n) :: nums2 = [2, 2]\n    integer, dimension(:), allocatable :: intersection\n\n    intersection = get_intersection(nums1, nums2)\n    print '(A,*(I0,1X))', 'Intersection: ', intersection\n\ncontains\n\n    function get_intersection(nums1, nums2) result(intersection)\n        implicit none\n        integer, intent(in) :: nums1(:), nums2(:)\n        integer, dimension(:), allocatable :: intersection\n        logical, dimension(size(nums1)) :: mask\n        integer :: i, j\n\n        intersection = []\n        mask = .false.\n\n        do i = 1, size(nums1)\n            if (any(nums1(i) == nums2)) then\n                mask(i) = .true.\n            end if\n        end do\n\n        do i = 1, size(nums1)\n            if (mask(i)) then\n                intersection = [intersection, nums1(i)]\n            end if\n        end do\n\n        intersection = unique(intersection)\n\n    end function get_intersection\n\nend program main",
  "350": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 2\n    integer, dimension(n) :: nums1 = [1, 2], nums2 = [2, 2]\n    real(kind=DP), dimension(:), allocatable :: intersections\n    call get_intersection(nums1, nums2, intersections)\n    write (unit=error_unit, fmt='(*(g0))') 'Intersection:', intersections\ncontains\n    subroutine get_intersection(nums1, nums2, intersections)\n        implicit none\n        integer, dimension(:), intent(in) :: nums1, nums2\n        real(kind=DP), dimension(:), allocatable, intent(out) :: intersections\n        integer :: i, j, k\n        logical :: found\n\n        allocate (intersections(size(nums1)))\n        k = 1\n        do i = 1, size(nums1)\n            found = .false.\n            do j = 1, size(nums2)\n                if (nums1(i) == nums2(j)) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) then\n                intersections(k) = nums1(i)\n                k = k + 1\n            end if\n        end do\n        intersections = intersections(1:k-1)\n    end subroutine get_intersection\nend program main",
  "359": "program main\n    use Logger_mod\n    implicit none\n\n    type(Logger) :: logger\n    integer :: i\n    character(len=30) :: message\n    integer :: timestamp\n\n    ! Example 1\n    call logger%shouldPrintMessage(1, \"foo \")\n    call logger%shouldPrintMessage(2, \"bar \")\n    call logger%shouldPrintMessage(3, \"foo \")\n    call logger%shouldPrintMessage(8, \"bar \")\n    call logger%shouldPrintMessage(10, \"foo \")\n    call logger%shouldPrintMessage(11, \"foo \")\n\n    ! Example 2\n    do i = 1, 5\n        call logger%shouldPrintMessage(i, \"bar \")\n    end do\n\n    ! Example 3\n    do i = 1, 5\n        call logger%shouldPrintMessage(i, \"foo \")\n    end do\n\n    ! Example 4\n    do i = 1, 5\n        call logger%shouldPrintMessage(i, \"bar \")\n    end do\n\n    ! Example 5\n    do i = 1, 5\n        call logger%shouldPrintMessage(i, \"foo \")\n    end do\n\ncontains\n\nsubroutine print_result(result)\n    logical, intent(in) :: result\n    write(*, '(L1)') result\nend subroutine print_result\n\nend program main\n\nmodule Logger_mod\n    implicit none\n\n    private\n    public :: Logger\n\n    type :: Logger\n        private\n        integer :: last_printed_timestamp = -1\n        character(len=30), allocatable :: last_printed_message(:)\n    contains\n        procedure :: shouldPrintMessage\n    end type Logger\n\ncontains\n\nlogical function shouldPrintMessage(self, timestamp, message) result(should_print)\n    class(Logger), intent(inout) :: self\n    integer, intent(in) :: timestamp\n    character(len=*), intent(in) :: message\n    integer :: i\n\n    should_print = .false.\n\n    if (timestamp > self%last_printed_timestamp + 10) then\n        self%last_printed_timestamp = timestamp\n        allocate(self%last_printed_message(1))\n        self%last_printed_message(1) = message\n        should_print = .true.\n    else\n        do i = 1, size(self%last_printed_message)\n            if (self%last_printed_message(i) == message) then\n                exit\n            end if\n        end do\n\n        if (i > size(self%last_printed_message)) then\n            self%last_printed_message = [self%last_printed_message, message]\n            should_print = .true.\n        end if\n    end if\n\nend function shouldPrintMessage\n\nend module Logger_mod",
  "367": "program main\n    implicit none\n\n    integer :: num\n    logical :: is_perfect_square\n\n    ! Example 1\n    num = 16\n    write(*,*) 'Example 1'\n    write(*,*) 'Input: ', num\n    write(*,*) 'Output: ', is_perfect_square(num)\n\n    ! Example 2\n    num = 14\n    write(*,*) 'Example 2'\n    write(*,*) 'Input: ', num\n    write(*,*) 'Output: ', is_perfect_square(num)\n\ncontains\n\n    function is_perfect_square(num) result(res)\n        implicit none\n        integer, intent(in) :: num\n        logical :: res\n        integer :: i\n\n        do i = 1, int(sqrt(real(num)))\n            if (i * i == num) then\n                res = .true.\n                exit\n            end if\n        end do\n    end function is_perfect_square\n\nend program main",
  "374": "program main\n    implicit none\n\n    integer :: n, pick, result\n\n    ! Example 1\n    n = 10\n    pick = 6\n    result = guess(pick)\n    write (*, '(A, I0)') 'Example 1: ', result\n\n    ! Example 2\n    n = 1\n    pick = 1\n    result = guess(pick)\n    write (*, '(A, I0)') 'Example 2: ', result\n\n    ! Example 3\n    n = 2\n    pick = 1\n    result = guess(pick)\n    write (*, '(A, I0)') 'Example 3: ', result\n\ncontains\n\n    function guess(num) result(result)\n        implicit none\n        integer, value :: num\n        integer :: result\n\n        if (num > pick) then\n            result = -1\n        else if (num < pick) then\n            result = 1\n        else\n            result = 0\n        end if\n    end function guess\nend program main",
  "383": "program main\n    implicit none\n\n    character(len=:), allocatable :: ransomNote, magazine\n    logical :: result\n\n    ! Example 1\n    allocate(character(len=1) :: ransomNote)\n    allocate(character(len=1) :: magazine)\n    ransomNote = 'a'\n    magazine = 'b'\n    result = canConstruct(ransomNote, magazine)\n    print *, result\n    deallocate(ransomNote)\n    deallocate(magazine)\n\n    ! Example 2\n    allocate(character(len=2) :: ransomNote)\n    allocate(character(len=2) :: magazine)\n    ransomNote = 'aa'\n    magazine = 'ab'\n    result = canConstruct(ransomNote, magazine)\n    print *, result\n    deallocate(ransomNote)\n    deallocate(magazine)\n\n    ! Example 3\n    allocate(character(len=2) :: ransomNote)\n    allocate(character(len=3) :: magazine)\n    ransomNote = 'aa'\n    magazine = 'aab'\n    result = canConstruct(ransomNote, magazine)\n    print *, result\n    deallocate(ransomNote)\n    deallocate(magazine)\n\ncontains\n\n    function canConstruct(ransomNote, magazine) result(result_)\n        implicit none\n        character(len=*), intent(in) :: ransomNote, magazine\n        integer :: i, j\n        logical :: result_\n\n        do i = 1, len(ransomNote)\n            do j = 1, len(magazine)\n                if (ransomNote(i:i) == magazine(j:j)) then\n                    magazine(j:j) = ' '\n                    exit\n                end if\n            end do\n            if (j > len(magazine)) then\n                result_ = .false.\n                return\n            end if\n        end do\n\n        result_ = .true.\n    end function canConstruct\nend program main",
  "387": "program main\n    implicit none\n\n    integer :: i, j, k, n, m\n    character(len=100) :: s\n    logical :: found\n\n    ! Example 1\n    s = 'leetcode'\n    print *, find_first_non_repeating_char(s)\n\n    ! Example 2\n    s = 'loveleetcode'\n    print *, find_first_non_repeating_char(s)\n\n    ! Example 3\n    s = 'aabb'\n    print *, find_first_non_repeating_char(s)\n\ncontains\n\n    function find_first_non_repeating_char(str) result(index)\n        implicit none\n        character(len=*), intent(in) :: str\n        integer :: index\n        logical :: found\n\n        index = -1\n        do i = 1, len(str)\n            found = .false.\n            do j = 1, len(str)\n                if (i /= j) then\n                    if (str(i:i) == str(j:j)) then\n                        found = .true.\n                        exit\n                    end if\n                end if\n            end do\n            if (.not. found) then\n                index = i\n                exit\n            end if\n        end do\n    end function find_first_non_repeating_char\n\nend program main",
  "389": "program main\n    implicit none\n\n    character(len=*), parameter :: s = \"abcd \"\n    character(len=*), parameter :: t = \"abcde \"\n    character(len=1) :: ans\n\n    ans = solve(s, t)\n    print *, ans\n\ncontains\n\n    function solve(s, t) result(ans)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=*), intent(in) :: t\n        integer :: i, j\n        character(len=1) :: ans\n\n        do i = 1, len_trim(s)\n            if (s(i:i) /= t(i:i)) then\n                ans = t(i:i)\n                return\n            end if\n        end do\n\n        ans = ' '\n    end function solve\nend program main",
  "392": "program main\n    implicit none\n\n    character(len=:), allocatable :: s, t\n    logical :: result\n\n    ! Example 1\n    s = 'abc'\n    t = 'ahbgdc'\n    result = is_subsequence(s, t)\n    print '(L1)', result\n\n    ! Example 2\n    s = 'axc'\n    t = 'ahbgdc'\n    result = is_subsequence(s, t)\n    print '(L1)', result\n\ncontains\n\n    function is_subsequence(s, t) result(res)\n        implicit none\n        character(len=*), intent(in) :: s, t\n        logical :: res\n        integer :: i, j\n\n        res = .false.\n        do i = 1, len(t) - len(s) + 1\n            do j = 1, len(s)\n                if (s(j:j) /= t(i+j-1:i+j-1)) exit\n            end do\n            if (j == len(s)+1) then\n                res = .true.\n                exit\n            end if\n        end do\n    end function is_subsequence\n\nend program main",
  "401": "program main\n    implicit none\n\n    integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n    integer :: turnedOn\n    character(len=5) :: time\n    character(len=10) :: times(10)\n\n    ! Examples from the problem statement\n    turnedOn = 1\n    call solve(turnedOn, times)\n    write (*, '(A)') times\n\n    turnedOn = 9\n    call solve(turnedOn, times)\n    write (*, '(A)') times\n\ncontains\n\nsubroutine solve(turnedOn, times)\n    implicit none\n    integer, intent(in) :: turnedOn\n    character(len=5), intent(out) :: times(:)\n\n    integer :: h, m\n\n    do i = 0, 11\n        do j = 0, 59\n            if (i == 0 .and. j < 10) then\n                cycle\n            end if\n            if (i > 0 .and. j < 10) then\n                cycle\n            end if\n            if (mod(i * 10 + j, turnedOn) /= 0) then\n                cycle\n            end if\n            h = i\n            m = j\n            if (h < 10) then\n                write (time, '(I1, \":\", I2)') h, m\n            else\n                write (time, '(I2, \":\", I2)') h, m\n            end if\n            times(i * 6 + j + 1) = time\n        end do\n    end do\nend subroutine solve\n\nend program main",
  "404": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=20) :: filename\n    type :: TreeNode\n        real(kind=DP), pointer :: val => null()\n        class(TreeNode), pointer :: left => null(), right => null()\n    end type TreeNode\n    type(TreeNode), pointer :: root\n    integer :: i, n\n    real(kind=DP) :: sum\n\n    ! read input from file\n    open(newunit=unit_in, file='input.txt', status='old', action='read')\n    read(unit=unit_in, fmt=*) filename\n    close(unit=unit_in)\n\n    ! read data from file\n    open(newunit=unit_in, file=filename, status='old', action='read')\n    read(unit=unit_in, fmt=*) n\n    allocate(root)\n    call read_tree(unit_in, root)\n    close(unit=unit_in)\n\n    ! solve problem\n    sum = sum_of_left_leaves(root)\n\n    ! write output to file\n    open(newunit=unit_out, file='output.txt', status='replace', action='write')\n    write(unit=unit_out, fmt='(F0.2)') sum\n    close(unit=unit_out)\n\ncontains\n\n    subroutine read_tree(unit_in, root)\n        integer, intent(in) :: unit_in\n        class(TreeNode), pointer :: root\n        integer :: i\n        logical :: done\n\n        done = .false.\n        do while (.not. done)\n            read(unit=unit_in, fmt=*, iostat=i)\n            if (i /= 0) then\n                done = .true.\n            else\n                allocate(root%left)\n                call read_tree(unit_in, root%left)\n                allocate(root%right)\n                call read_tree(unit_in, root%right)\n            end if\n        end do\n    end subroutine read_tree\n\n    function sum_of_left_leaves(root) result(sum)\n        class(TreeNode), pointer :: root\n        real(kind=DP) :: sum\n        integer :: i\n\n        if (associated(root)) then\n            if (associated(root%left)) then\n                if (.not. associated(root%left%left) .and. &\n                    .not. associated(root%left%right)) then\n                    sum = sum + root%left%val\n                else\n                    sum = sum + sum_of_left_leaves(root%left)\n                end if\n            end if\n            sum = sum + sum_of_left_leaves(root%right)\n        end if\n    end function sum_of_left_leaves\n\nend program main",
  "405": "program main\n    implicit none\n\n    integer :: num\n    character(len=10) :: str\n\n    num = 26\n    call get_hex_str(num, str)\n    print '(A)', trim(adjustl(str))\n\n    num = -1\n    call get_hex_str(num, str)\n    print '(A)', trim(adjustl(str))\n\ncontains\n\n    subroutine get_hex_str(num, str)\n        implicit none\n        integer, intent(in) :: num\n        character(len=*), intent(out) :: str\n        integer :: i, j, k, n\n\n        if (num < 0) then\n            ! Use two's complement method\n            n = abs(num) + 1\n            do i = 1, 8\n                k = mod(n, 16)\n                select case (k)\n                    case (0:9)\n                        str(i:i) = char(iachar('0') + k)\n                    case default\n                        str(i:i) = char(iachar('a') + k - 10)\n                end select\n                n = n / 16\n            end do\n        else\n            ! Positive number\n            do i = 1, 8\n                k = mod(num, 16)\n                select case (k)\n                    case (0:9)\n                        str(i:i) = char(iachar('0') + k)\n                    case default\n                        str(i:i) = char(iachar('a') + k - 10)\n                end select\n                num = num / 16\n            end do\n        end if\n\n        ! Reverse the string\n        do i = 1, 4\n            j = mod(i, 5)\n            k = mod(j+1, 5)\n            str(i:i) = str(k:k)\n        end do\n\n    end subroutine get_hex_str\n\nend program main",
  "408": "program main\n    implicit none\n\n    character(len=*), parameter :: word = \"substitution \"\n    character(len=*), parameter :: abbr = \"s10n \"\n    logical :: matches\n\n    write(*,*) 'word: ', trim(word)\n    write(*,*) 'abbr: ', trim(abbr)\n    write(*,*) 'matches: ', matches(word, abbr)\n\ncontains\n\n    function matches(str, abbr) result(res)\n        implicit none\n        character(len=*), intent(in) :: str, abbr\n        logical :: res\n        integer :: i, j, k, l\n\n        res = .false.\n        i = 1\n        do while (i <= len_trim(str))\n            j = index(str(i:), ' ')\n            if (j == 0) then\n                exit\n            end if\n            k = index(abbr, ' ')\n            if (k /= 0) then\n                ! there is a space in the abbreviation\n                if (j > k) then\n                    ! the substring before the space in the abbreviation is longer than the actual substring\n                    exit\n                else\n                    ! the substring before the space in the abbreviation is shorter or equal to the actual substring\n                    i = i + j - 1\n                    cycle\n                end if\n            else\n                ! no space in the abbreviation\n                if (j > len_trim(abbr)) then\n                    ! the actual substring is longer than the abbreviation\n                    exit\n                else\n                    ! the actual substring is shorter or equal to the abbreviation\n                    i = i + j - 1\n                    cycle\n                end if\n            end if\n            l = len_trim(str(i:i+j-1))\n            if (l > 0) then\n                ! the actual substring is not empty\n                if (index(abbr, l) == 0) then\n                    ! the length of the actual substring is not found in the abbreviation\n                    exit\n                else\n                    ! the length of the actual substring is found in the abbreviation\n                    i = i + j\n                    cycle\n                end if\n            else\n                ! the actual substring is empty\n                exit\n            end if\n        end do\n        if (i == len_trim(str)+1) then\n            ! we reached the end of the string without finding a mismatch\n            res = .true.\n        end if\n    end function matches\n\nend program main",
  "409": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    integer :: n\n\n    call get_command_argument(1, s)\n    n = longest_palindrome(s)\n    write (*, '(I0)') n\n\ncontains\n\n    function longest_palindrome(s) result(n)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j, n\n\n        do i = 1, len(s) - 1\n            do j = i + 1, len(s)\n                if (s(i:j) == s(i:j)) then\n                    n = max(n, j - i + 1)\n                end if\n            end do\n        end do\n    end function longest_palindrome\n\nend program main",
  "412": "program fizzbuzz\n    implicit none\n\n    integer, parameter :: n = 15\n    character(len=10), dimension(n) :: answer\n\n    integer :: i\n\n    do i = 1, n\n        if (mod(i, 3) == 0 .and. mod(i, 5) == 0) then\n            answer(i) = \"FizzBuzz \"\n        else if (mod(i, 3) == 0) then\n            answer(i) = \"Fizz \"\n        else if (mod(i, 5) == 0) then\n            answer(i) = \"Buzz \"\n        else\n            write (answer(i), '(I10)') i\n        end if\n    end do\n\n    print *, answer\n\nend program fizzbuzz",
  "414": "program main\n    implicit none\n\n    integer, parameter :: n = 3 ! number of elements in the array\n    integer, dimension(n) :: nums = (/ 3, 2, 1 /) ! input array\n    integer :: max_val, sec_max_val, thrd_max_val ! variables to store the values\n\n    call get_distinct_max(nums, max_val, sec_max_val, thrd_max_val)\n\n    write (*, '(A, I0)') 'Maximum value: ', max_val\n    write (*, '(A, I0)') 'Second maximum value: ', sec_max_val\n    write (*, '(A, I0)') 'Third maximum value: ', thrd_max_val\n\ncontains\n\n    subroutine get_distinct_max(nums, max_val, sec_max_val, thrd_max_val)\n        implicit none\n        integer, intent(in) :: nums(:) ! input array\n        integer, intent(out) :: max_val, sec_max_val, thrd_max_val ! output values\n        integer :: i, j, k ! loop counters\n\n        ! initialize variables\n        max_val = nums(1)\n        sec_max_val = max_val\n        thrd_max_val = max_val\n\n        ! loop through the array and find the distinct maxima\n        do i = 2, size(nums)\n            if (nums(i) > max_val) then\n                thrd_max_val = sec_max_val\n                sec_max_val = max_val\n                max_val = nums(i)\n            else if (nums(i) > sec_max_val) then\n                thrd_max_val = sec_max_val\n                sec_max_val = nums(i)\n            end if\n        end do\n\n        ! check if the third maximum exists\n        k = 0\n        do j = 1, size(nums)\n            if (nums(j) == sec_max_val) then\n                k = k + 1\n            end if\n        end do\n\n        if (k < 2) then\n            thrd_max_val = max_val\n        end if\n\n    end subroutine get_distinct_max\n\nend program main",
  "415": "program main\n    implicit none\n\n    character(len=100) :: num1, num2, result\n\n    ! Example 1\n    num1 = \"11 \"\n    num2 = \"123 \"\n    call add_strings(num1, num2, result)\n    print '(A)', trim(result)\n\n    ! Example 2\n    num1 = \"456 \"\n    num2 = \"77 \"\n    call add_strings(num1, num2, result)\n    print '(A)', trim(result)\n\n    ! Example 3\n    num1 = \"0 \"\n    num2 = \"0 \"\n    call add_strings(num1, num2, result)\n    print '(A)', trim(result)\n\ncontains\n\n    subroutine add_strings(num1, num2, result)\n        implicit none\n        character(len=*), intent(in) :: num1, num2\n        character(len=*), intent(out) :: result\n        integer :: i, j, carry\n\n        result = \"\"\n        carry = 0\n        do while (i < len(num1) .or. j < len(num2))\n            if (i < len(num1)) then\n                carry = carry + ichar(num1(i+1:i+1)) - ichar('0')\n            end if\n            if (j < len(num2)) then\n                carry = carry + ichar(num2(j+1:j+1)) - ichar('0')\n            end if\n            result = char(carry%10 + ichar('0')) // result\n            carry = carry / 10\n            i = i + 1\n            j = j + 1\n        end do\n        if (carry > 0) then\n            result = char(carry%10 + ichar('0')) // result\n        end if\n    end subroutine add_strings\nend program main",
  "422": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=500) :: words(500)\n    logical :: valid_word_square\n\n    ! Example 1\n    words(1) = 'abcd '\n    words(2) = 'bnrt '\n    words(3) = 'crmy '\n    words(4) = 'dtye '\n    call assert(valid_word_square(words))\n\n    ! Example 2\n    words(1) = 'abcd '\n    words(2) = 'bnrt '\n    words(3) = 'crm '\n    words(4) = 'dt '\n    call assert(valid_word_square(words))\n\n    ! Example 3\n    words(1) = 'ball '\n    words(2) = 'area '\n    words(3) = 'read '\n    words(4) = 'lady '\n    call assert(.not. valid_word_square(words))\n\ncontains\n\n    subroutine assert(condition)\n        implicit none\n        logical, intent(in) :: condition\n\n        if (.not. condition) then\n            write (*,*) 'Assertion failed!'\n            stop 1\n        end if\n    end subroutine assert\n\n    function valid_word_square(words) result(valid)\n        implicit none\n        character(len=*), intent(in) :: words(:)\n        integer :: num_rows, num_cols, i, j\n        logical :: valid\n\n        num_rows = size(words)\n        num_cols = size(words, dim=2)\n\n        do i = 0, min(num_rows, num_cols) - 1\n            do j = 0, min(num_rows, num_cols) - 1\n                if (words(i+1)(j+1:j+1) /= words(j+1)(i+1:i+1)) then\n                    valid = .false.\n                    exit\n                end if\n            end do\n            if (.not. valid) exit\n        end do\n    end function valid_word_square\nend program main",
  "434": "program main\n    implicit none\n\n    integer :: i, n\n    character(len=300) :: s\n\n    do i = 1, size(examples)\n        read (examples(i), *) s\n        write (*,*) 'Example ', i, ':'\n        write (*,*) 'Input: ', trim(s)\n        n = count_segments(s)\n        write (*,*) 'Output: ', n\n        write (*,*) ''\n    end do\n\ncontains\n\n    function count_segments(s) result(n)\n        implicit none\n        character(*), intent(in) :: s\n        integer :: n, i\n\n        n = 0\n        do i = 1, len(s)\n            if (s(i:i) /= ' ') then\n                n = n + 1\n            end if\n        end do\n    end function count_segments\n\nend program main\n\ncharacter(len=*), parameter :: examples(2) = [ &\n    '\"Hello, my name is John \"', &\n    '\"Hello \"' ]",
  "441": "program main\n    implicit none\n\n    integer :: n, k\n\n    n = 5\n    k = solve(n)\n    write (*, '(A, I0)') 'Complete rows: ', k\n\n    n = 8\n    k = solve(n)\n    write (*, '(A, I0)') 'Complete rows: ', k\n\ncontains\n\n    function solve(n) result(k)\n        implicit none\n        integer, value :: n\n        integer :: i, j, k\n\n        do i = 1, n\n            if (mod(n, i) == 0) then\n                j = n / i\n                if (j >= i) then\n                    k = k + 1\n                end if\n            end if\n        end do\n    end function solve\nend program main",
  "448": "program main\n    implicit none\n\n    integer, parameter :: n = 9\n    integer, dimension(n) :: nums\n    integer, dimension(:), allocatable :: result\n    integer :: i\n\n    ! Example 1\n    nums = [4, 3, 2, 7, 8, 2, 3, 1]\n    call solve(nums, result)\n    write (*, '(*(I0, 1X))') result\n\n    ! Example 2\n    nums = [1, 1]\n    call solve(nums, result)\n    write (*, '(*(I0, 1X))') result\n\ncontains\n\n    subroutine solve(nums, result)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer, allocatable, intent(out) :: result(:)\n        integer :: i, j\n\n        allocate (result(n))\n\n        do i = 1, n\n            result(i) = i\n        end do\n\n        do i = 1, size(nums)\n            j = nums(i)\n            if (j /= i) then\n                result(i) = result(j)\n                result(j) = i\n            end if\n        end do\n\n        do i = 1, n\n            if (result(i) /= i) then\n                result(i) = 0\n            end if\n        end do\n\n    end subroutine solve\n\nend program main",
  "455": "program main\n    implicit none\n\n    integer :: n_children, n_cookies\n    integer, dimension(:), allocatable :: greed_factors\n    integer, dimension(:), allocatable :: cookie_sizes\n    integer :: i, j\n    integer :: max_content_children\n\n    ! read input\n    read(*,*) n_children\n    allocate(greed_factors(n_children))\n    do i = 1, n_children\n        read(*,*) greed_factors(i)\n    end do\n    read(*,*) n_cookies\n    allocate(cookie_sizes(n_cookies))\n    do i = 1, n_cookies\n        read(*,*) cookie_sizes(i)\n    end do\n\n    ! solve problem\n    max_content_children = 0\n    do i = 1, n_children\n        do j = 1, n_cookies\n            if (cookie_sizes(j) >= greed_factors(i)) then\n                max_content_children = max(max_content_children, 1)\n                exit\n            end if\n        end do\n    end do\n\n    ! print output\n    write (*,*) max_content_children\n\nend program main",
  "459": "program main\n    implicit none\n\n    character(len=100) :: s\n    logical :: result\n\n    ! Example 1\n    s = \"abab \"\n    result = solve(s)\n    print '(L1)', result\n\n    ! Example 2\n    s = \"aba \"\n    result = solve(s)\n    print '(L1)', result\n\n    ! Example 3\n    s = \"abcabcabcabc \"\n    result = solve(s)\n    print '(L1)', result\n\ncontains\n\n    function solve(s) result(result)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j, k\n        logical :: result\n\n        do i = 1, len_trim(s) - 1\n            do j = i + 1, len_trim(s)\n                do k = 1, (j-i+1)/(j-i)\n                    if (s(i:j) == s(i:(j-k*(j-i)))) then\n                        result = .true.\n                        return\n                    end if\n                end do\n            end do\n        end do\n        result = .false.\n    end function solve\nend program main",
  "461": "program hammingDistance\n    implicit none\n\n    integer :: x, y, hammingDistance\n\n    ! Example 1\n    x = 1\n    y = 4\n    print '(A, I0)', 'Hamming distance between ', x, 'and ', y, 'is ', hammingDistance(x, y)\n\n    ! Example 2\n    x = 3\n    y = 1\n    print '(A, I0)', 'Hamming distance between ', x, 'and ', y, 'is ', hammingDistance(x, y)\n\ncontains\n\n    function hammingDistance(x, y) result(hammingDist)\n        implicit none\n        integer, intent(in) :: x, y\n        integer :: hammingDist\n\n        hammingDist = count(bit_xor(x, y) /= 0)\n    end function hammingDistance\n\nend program hammingDistance",
  "463": "program main\n    implicit none\n\n    integer, parameter :: row = 4, col = 4\n    integer :: grid(row, col)\n\n    ! Example 1\n    grid(:, :) = reshape([0, 1, 0, 0, &\n                           1, 1, 1, 0, &\n                           0, 1, 0, 0, &\n                           1, 1, 0, 0], shape(grid))\n    print '(I0)', solve(grid)\n\n    ! Example 2\n    grid(:, :) = reshape([1], shape(grid))\n    print '(I0)', solve(grid)\n\n    ! Example 3\n    grid(:, :) = reshape([1, 0], shape(grid))\n    print '(I0)', solve(grid)\n\ncontains\n\n    function solve(grid) result(perimeter)\n        implicit none\n        integer, intent(in) :: grid(:, :)\n        integer :: perimeter\n        integer :: i, j\n\n        perimeter = 0\n        do i = 1, size(grid, 1)\n            do j = 1, size(grid, 2)\n                if (grid(i, j) == 1) then\n                    perimeter = perimeter + 4\n                    if (i > 1 .and. grid(i-1, j) == 1) then\n                        perimeter = perimeter - 2\n                    end if\n                    if (j > 1 .and. grid(i, j-1) == 1) then\n                        perimeter = perimeter - 2\n                    end if\n                end if\n            end do\n        end do\n    end function solve\nend program main",
  "476": "program main\n    implicit none\n\n    integer :: num, complement\n\n    ! Example 1\n    num = 5\n    write (*, '(A, I0)') 'Complement of ', num, ' is ', complement(num)\n\n    ! Example 2\n    num = 1\n    write (*, '(A, I0)') 'Complement of ', num, ' is ', complement(num)\n\ncontains\n\n    function complement(num) result(res)\n        implicit none\n        integer, intent(in) :: num\n        integer :: res\n\n        res = btest(num, 0_8)\n    end function complement\n\nend program main",
  "482": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    integer :: n, k\n\n    call get_command_argument(1, s)\n    read (s, *) n\n    call get_command_argument(2, s)\n    read (s, *) k\n\n    print '(A)', solve(s, n, k)\n\ncontains\n\n    function solve(s, n, k) result(res)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer, intent(in) :: n, k\n        character(len=:), allocatable :: res\n        integer :: i, j, l\n\n        l = len(s)\n        allocate(character(l) :: res)\n\n        do i = 1, n\n            if (i == 1) then\n                j = min(k, l)\n            else\n                j = k\n            end if\n            res(i:j) = s(i:j)\n            if (i /= n) then\n                res(j+1:j+1) = '-'\n            end if\n        end do\n\n        ! Convert lowercase letters to uppercase\n        do i = 1, l\n            if (res(i:i) >= 'a' .and. res(i:i) <= 'z') then\n                res(i:i) = char(ichar(res(i:i)) - 32)\n            end if\n        end do\n\n    end function solve\n\nend program main",
  "485": "program main\n    ! Solves the problem: Given a binary array `nums`, return the maximum number of consecutive `1`s in the array.\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: nums\n    integer :: max_consecutive_ones\n\n    ! Examples\n    nums = [1, 1, 0, 1, 1, 1]\n    write (*, '(A, I0)') 'Example 1: ', max_consecutive_ones(nums)\n    nums = [1, 0, 1, 1, 0, 1]\n    write (*, '(A, I0)') 'Example 2: ', max_consecutive_ones(nums)\n\ncontains\n\n    function max_consecutive_ones(nums) result(max_consecutive_ones_)\n        ! Returns the maximum number of consecutive `1`s in the array `nums`.\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer :: max_consecutive_ones_, current_consecutive_ones\n\n        current_consecutive_ones = 0\n        max_consecutive_ones_ = 0\n\n        do i = 1, size(nums)\n            if (nums(i) == 1) then\n                current_consecutive_ones = current_consecutive_ones + 1\n            else\n                max_consecutive_ones_ = max(max_consecutive_ones_, current_consecutive_ones)\n                current_consecutive_ones = 0\n            end if\n        end do\n\n        max_consecutive_ones_ = max(max_consecutive_ones_, current_consecutive_ones)\n    end function max_consecutive_ones\nend program main",
  "492": "program main\n    implicit none\n\n    integer :: area\n    integer :: l, w\n\n    area = 4\n    call solve(area, l, w)\n    write (*, '(A, I0, A, I0)') 'Length: ', l, '; Width: ', w\n\n    area = 37\n    call solve(area, l, w)\n    write (*, '(A, I0, A, I0)') 'Length: ', l, '; Width: ', w\n\n    area = 122122\n    call solve(area, l, w)\n    write (*, '(A, I0, A, I0)') 'Length: ', l, '; Width: ', w\n\ncontains\n\n    subroutine solve(area, l, w)\n        implicit none\n        integer, intent(in) :: area\n        integer, intent(out) :: l, w\n\n        integer :: diff\n\n        l = int(sqrt(real(area)))\n        do while (l > 0)\n            w = area / l\n            if (w == 0) then\n                exit\n            end if\n            diff = abs(l - w)\n            if (diff == 0) then\n                exit\n            else if (diff < minval(diff, l-1, w-1)) then\n                exit\n            end if\n            l = l - 1\n        end do\n    end subroutine solve\n\nend program main",
  "495": "program main\n    implicit none\n\n    integer, parameter :: n = 2\n    integer, dimension(n) :: timeSeries = (/ 1, 4 /)\n    integer, parameter :: duration = 2\n    integer :: i\n\n    write (*, '(A)') 'Total seconds Ashe is poisoned:'\n    do i = 1, n\n        write (*, '(I0)') solve(timeSeries(i), duration)\n    end do\n\ncontains\n\n    function solve(time, dur) result(res)\n        implicit none\n        integer, intent(in) :: time, dur\n        integer :: res\n\n        if (time < dur) then\n            res = dur\n        else\n            res = time + dur - 1\n        end if\n    end function solve\nend program main",
  "496": "program main\n    implicit none\n\n    integer, parameter :: n = 3 ! number of elements in nums1\n    integer, parameter :: m = 4 ! number of elements in nums2\n    integer, dimension(n) :: nums1 = [4, 1, 2] ! subset of nums2\n    integer, dimension(m) :: nums2 = [1, 3, 4, 2]\n    integer, dimension(n) :: ans\n\n    call solve(nums1, nums2, ans)\n\n    write (*, '(A)') 'ans = ', ans\n\ncontains\n\n    subroutine solve(nums1, nums2, ans)\n        implicit none\n        integer, intent(in) :: nums1(:), nums2(:)\n        integer, intent(out) :: ans(:)\n        integer :: i, j, k\n\n        do i = 1, size(nums1)\n            j = 1\n            k = 1\n            do while (k <= size(nums2))\n                if (nums1(i) == nums2(k)) then\n                    exit\n                end if\n                k = k + 1\n            end do\n            if (k > size(nums2)) then\n                ans(i) = -1\n            else\n                ans(i) = nums2(k+1)\n            end if\n        end do\n    end subroutine solve\n\nend program main",
  "500": "program main\n    implicit none\n\n    integer, parameter :: n_examples = 3\n    character(len=50), dimension(n_examples) :: examples\n    character(len=50), allocatable :: words(:)\n    integer :: i, j, k\n\n    examples(1) = \"Hello \"\n    examples(2) = \"Alaska \"\n    examples(3) = \"Dad \"\n    examples(4) = \"Peace \"\n    examples(5) = \"omk \"\n    examples(6) = \"adsdf \"\n    examples(7) = \"sfd \"\n\n    do i = 1, n_examples\n        call get_words(examples(i), words)\n        write (*, '(A)') trim(examples(i)) // ': '\n        do j = 1, size(words)\n            write (*, '(A)', advance='no') trim(words(j)) // ', '\n        end do\n        write (*, *) ''\n    end do\n\ncontains\n\n    subroutine get_words(word, words)\n        implicit none\n        character(*), intent(in) :: word\n        character(len=*), allocatable, intent(out) :: words(:)\n        integer :: i, j, k, l, m, n\n        character(len=1) :: c\n        logical :: found\n\n        allocate(words(size(word)))\n\n        ! Initialize the list of words\n        words = ''\n\n        ! Loop over each letter in the word\n        do i = 1, len(word)\n            c = word(i:i)\n\n            ! Check if the letter is already in the list of words\n            found = .false.\n            do j = 1, size(words)\n                if (c == words(j)(1:1)) then\n                    found = .true.\n                    exit\n                end if\n            end do\n\n            ! If the letter is not already in the list of words, add it\n            if (.not. found) then\n                allocate(character(len=1) :: words(size(words)+1))\n                words(size(words)) = c\n            end if\n        end do\n\n        ! Remove duplicates from the list of words\n        do i = 1, size(words)-1\n            do j = i+1, size(words)\n                if (words(i) == words(j)) then\n                    words(j) = words(size(words))\n                    deallocate(words(size(words)))\n                    exit\n                end if\n            end do\n        end do\n\n    end subroutine get_words\n\nend program main",
  "501": "program main\n    use modes_mod\n    implicit none\n\n    type(bst_node), pointer :: root\n    integer :: i\n    type(bst_node), allocatable :: example(:)\n\n    allocate(example(3))\n    example(1)%key = 1\n    example(2)%key = 2\n    example(3)%key = 2\n    example(1)%left => null()\n    example(1)%right => example(2)\n    example(2)%left => example(3)\n    example(2)%right => null()\n    example(3)%left => null()\n    example(3)%right => null()\n\n    print '(\"Example 1:\")'\n    call solve(root=example(1))\n    print '(\"Example 2:\")'\n    call solve(root=example(2))\n\ncontains\n\nsubroutine solve(root)\n    type(bst_node), pointer :: root\n    type(bst_node), allocatable :: stack(:)\n    integer :: top, i\n    logical :: found\n\n    allocate(stack(size(root)))\n    top = 0\n    stack(top+1) => root\n    top = top + 1\n\n    do while (top > 0)\n        if (associated(stack(top)%left)) then\n            stack(top+1) => stack(top)%left\n            top = top + 1\n        else if (associated(stack(top)%right)) then\n            stack(top+1) => stack(top)%right\n            top = top + 1\n        else\n            do while (.not. associated(stack(top)%left))\n                deallocate(stack(top)%right)\n                top = top - 1\n            end do\n            stack(top+1) => stack(top)%left\n            top = top + 1\n        end if\n    end do\n\n    allocate(root%data(size(stack)))\n    do i = 1, size(stack)\n        root%data(i) = stack(i)%key\n    end do\n\nend subroutine solve\n\nend program main",
  "504": "program main\n    implicit none\n\n    integer, parameter :: num = 100\n    character(len=:), allocatable :: str\n\n    str = base_7_repr(num)\n    write (unit=*, fmt='(A)') trim(str)\n\ncontains\n\n    function base_7_repr(n) result(res)\n        implicit none\n        integer, intent(in) :: n\n        character(len=:), allocatable :: res\n\n        character(len=30), parameter :: digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        integer :: i, sign\n\n        if (n == 0) then\n            allocate (character(len=1) :: res)\n            res = '0'\n            return\n        end if\n\n        sign = 1\n        if (n < 0) then\n            sign = -1\n        end if\n\n        i = abs(n)\n        do while (i /= 0)\n            allocate (character(len=len(res)+1) :: res)\n            res = digits(mod(i, 7)+1) // res\n            i = i / 7\n        end do\n\n        if (sign < 0) then\n            allocate (character(len=len(res)+1) :: res)\n            res = '-' // res\n        end if\n\n    end function base_7_repr\n\nend program main",
  "506": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer :: score(n) = [5, 4, 3, 2, 1]\n    character(len=10) :: answer(n)\n\n    call solve(score, answer)\n\n    write (*, '(A)') answer\n\ncontains\n\n    subroutine solve(score, answer)\n        implicit none\n        integer, intent(in) :: score(:)\n        character(len=10), intent(out) :: answer(:)\n\n        integer :: i, j\n\n        do i = 1, size(score)\n            select case(i)\n                case(1)\n                    answer(i) = \"Gold Medal \"\n                case(2)\n                    answer(i) = \"Silver Medal \"\n                case(3)\n                    answer(i) = \"Bronze Medal \"\n                case default\n                    write (answer(i), '(I0)') i\n            end select\n        end do\n    end subroutine solve\nend program main",
  "507": "program main\n    implicit none\n\n    integer :: n\n    logical :: result\n\n    ! Example 1\n    n = 28\n    result = is_perfect(n)\n    if (result) then\n        print '(A, I0, A)', 'Perfect number: ', n, '.'\n    else\n        print '(A, I0, A)', 'Not a perfect number: ', n, '.'\n    end if\n\n    ! Example 2\n    n = 7\n    result = is_perfect(n)\n    if (result) then\n        print '(A, I0, A)', 'Perfect number: ', n, '.'\n    else\n        print '(A, I0, A)', 'Not a perfect number: ', n, '.'\n    end if\n\ncontains\n\n    function is_perfect(n) result(res)\n        implicit none\n        integer, intent(in) :: n\n        logical :: res\n        integer :: i\n\n        res = .false.\n        do i = 1, n - 1\n            if (mod(n, i) == 0) then\n                res = res .or. is_perfect(i)\n            end if\n        end do\n        if (n == sum(1, n)) then\n            res = .true.\n        end if\n    end function is_perfect\n\nend program main",
  "509": "program fibonacci\n    implicit none\n\n    integer :: n, i, j\n    integer, dimension(:), allocatable :: fib\n\n    do while ( .true. )\n        read(*,*) n\n        if ( n == 0 ) exit\n\n        allocate(fib(n))\n        fib(0) = 0\n        fib(1) = 1\n        do i=2,n\n            fib(i) = fib(i-1) + fib(i-2)\n        end do\n        write(*,*) fib(n)\n        deallocate(fib)\n    end do\nend program fibonacci",
  "520": "program main\n    implicit none\n\n    character(len=*), parameter :: example_1 = \"USA\"\n    character(len=*), parameter :: example_2 = \"FlaG\"\n    character(len=*), parameter :: example_3 = \"leetcode\"\n    character(len=*), parameter :: example_4 = \"Google\"\n\n    logical :: result\n\n    result = is_capitalized(example_1)\n    print '(L1)', result\n    result = is_capitalized(example_2)\n    print '(L1)', result\n    result = is_capitalized(example_3)\n    print '(L1)', result\n    result = is_capitalized(example_4)\n    print '(L1)', result\n\ncontains\n\n    function is_capitalized(word) result(is_right)\n        implicit none\n        character(len=*), intent(in) :: word\n        logical :: is_right\n\n        integer :: i\n\n        is_right = .false.\n\n        do i = 1, len(word)\n            if (ichar(word(i:i)) >= ichar('A') .and. ichar(word(i:i)) <= ichar('Z')) then\n                ! If any letter is capital, then the whole word must be capitalized\n                exit\n            end if\n        end do\n\n        if (i == len(word)) then\n            ! If we reach the end of the word without finding any capital letter,\n            ! then the word is not capitalized\n            is_right = .false.\n        else\n            ! Otherwise, check if the first letter is capital\n            if (ichar(word(1:1)) >= ichar('A') .and. ichar(word(1:1)) <= ichar('Z')) then\n                is_right = .true.\n            end if\n        end if\n\n    end function is_capitalized\n\nend program main",
  "521": "program main\n    implicit none\n\n    character(len=100) :: a, b\n    integer :: n\n\n    call get_command_argument(1, a)\n    call get_command_argument(2, b)\n\n    n = longest_uncommon_subsequence(a, b)\n    write (*, '(I0)') n\n\ncontains\n\n    function longest_uncommon_subsequence(a, b) result(n)\n        implicit none\n        character(len=*), intent(in) :: a, b\n        integer :: i, j, k, l, m, n\n        logical :: found\n\n        ! Initialize variables\n        n = -1\n        found = .false.\n\n        ! Loop over all possible starting indices for a\n        do i = 1, len(a)\n            ! Loop over all possible ending indices for a\n            do j = i, len(a)\n                ! Check if a(i:j) is a subsequence of b\n                do k = 1, len(b)\n                    ! Check if b(k:) is a subsequence of a(i:j)\n                    do l = k, len(b)\n                        if (a(i:j) == b(k:l)) then\n                            ! If it is, check if a(i:j) is longer than the current longest uncommon subsequence\n                            if (len(a(i:j)) > n) then\n                                ! If it is, update the longest uncommon subsequence\n                                n = len(a(i:j))\n                                found = .true.\n                            end if\n                            exit\n                        end if\n                    end do\n                    if (found) exit\n                end do\n                if (found) exit\n            end do\n            if (found) exit\n        end do\n\n    end function longest_uncommon_subsequence\n\nend program main",
  "530": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 2\n    real(DP), dimension(n) :: x, y\n    real(DP) :: z\n    type(TreeNode), pointer :: root\n\n    x = [4._DP, 2._DP]\n    y = [6._DP, 1._DP]\n    call solve(x, y, z)\n    write (unit=error_unit, fmt='(ES24.16)') z\n\n    x = [1._DP, 0._DP]\n    y = [48._DP, 12._DP, 49._DP]\n    call solve(x, y, z)\n    write (unit=error_unit, fmt='(ES24.16)') z\n\ncontains\n\n    subroutine solve(x, y, z)\n        implicit none\n        real(DP), dimension(:), intent(in) :: x, y\n        real(DP), intent(out) :: z\n        type(TreeNode), pointer :: root\n\n        allocate(root)\n        call build_tree(root, x, y)\n        z = min_abs_diff(root)\n\n        deallocate(root)\n    end subroutine solve\n\n    recursive function min_abs_diff(node) result(res)\n        implicit none\n        class(TreeNode), pointer, intent(in) :: node\n        real(DP) :: res\n\n        if (.not. associated(node)) then\n            res = huge(res)\n        elseif (.not. associated(node%left) .and. .not. associated(node%right)) then\n            res = 0._DP\n        else\n            res = min(min_abs_diff(node%left), min_abs_diff(node%right))\n        end if\n\n        if (associated(node%left) .and. associated(node%right)) then\n            res = min(res, abs(node%val - node%right%val))\n            res = min(res, abs(node%val - node%left%val))\n        end if\n    end function min_abs_diff\n\n    subroutine build_tree(root, x, y)\n        implicit none\n        type(TreeNode), pointer, intent(inout) :: root\n        real(DP), dimension(:), intent(in) :: x, y\n        integer :: i, j\n\n        do i = 1, size(x)\n            allocate(root%left)\n            root%left%val = x(i)\n            do j = 1, size(y)\n                if (y(j) == x(i)) then\n                    root%left%left => null()\n                    root%left%right => null()\n                    exit\n                end if\n            end do\n            call build_tree(root%left, x, y)\n\n            allocate(root%right)\n            root%right%val = x(i)\n            do j = 1, size(y)\n                if (y(j) == x(i)) then\n                    root%right%left => null()\n                    root%right%right => null()\n                    exit\n                end if\n            end do\n            call build_tree(root%right, x, y)\n        end do\n    end subroutine build_tree\n\nend program main\n\ntype :: TreeNode\n    real(DP) :: val\n    type(TreeNode), pointer :: left\n    type(TreeNode), pointer :: right\nend type TreeNode",
  "541": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    integer :: k\n\n    call get_string(s)\n    read(*,*) k\n\n    call solve(s, k)\n\ncontains\n\nsubroutine get_string(str)\n    implicit none\n    character(len=:), allocatable :: str\n    integer :: i, n\n\n    read(*,*) n\n    allocate(character(n) :: str)\n    do i = 1, n\n        read(*,*) str(i:i)\n    end do\nend subroutine get_string\n\nsubroutine solve(s, k)\n    implicit none\n    character(len=*), intent(inout) :: s\n    integer, value :: k\n    integer :: i, j, n\n\n    n = len(s)\n    do i = 1, n, 2*k\n        if (i+k-1 > n) then\n            ! Reverse all remaining characters\n            do j = i, n\n                s(j:j) = s(j:j)",
  "543": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, iostat_end, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=1024) :: line\n    type :: node\n        real(kind=DP), allocatable :: val(:)\n        class(node), pointer :: left, right\n    end type node\n    type(node), pointer :: root\n    integer :: n, i, j, status\n\n    ! read input\n    open(newunit=unit_in, file='input.txt', status='old', action='read', iostat=status)\n    if (status /= 0) then\n        write(error_unit, '(*(G0))') 'error: could not open input file'\n        stop 1\n    end if\n    read(unit=unit_in, fmt=*, iostat=status) n\n    allocate(root%val(n))\n    do i = 1, n\n        read(unit=unit_in, fmt=*, iostat=status) root%val(i)\n        if (status /= 0) exit\n    end do\n    close(unit=unit_in)\n\n    ! solve problem\n    call solve(root)\n\n    ! output solution\n    open(newunit=unit_out, file='output.txt', status='replace', action='write', iostat=status)\n    if (status /= 0) then\n        write(error_unit, '(*(G0))') 'error: could not open output file'\n        stop 1\n    end if\n    write(unit=unit_out, fmt='(I0)') diameter(root)\n    close(unit=unit_out)\n\ncontains\n\n    subroutine solve(root)\n        class(node), intent(inout) :: root\n        integer :: i\n\n        ! TODO: solve the problem here\n\n    end subroutine solve\n\n    function diameter(root) result(res)\n        class(node), intent(in) :: root\n        integer :: res\n\n        ! TODO: compute the diameter of the tree\n\n    end function diameter\n\nend program main",
  "551": "program main\n    implicit none\n\n    character(len=1000) :: s\n    logical :: result\n\n    ! Example 1\n    s = \"PPALLP \"\n    write(*,*) solve(s), \"Expected: True\"\n\n    ! Example 2\n    s = \"PPALLL \"\n    write(*,*) solve(s), \"Expected: False\"\n\ncontains\n\n    function solve(s) result(result)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j, k, n_absent, n_late\n        logical :: is_eligible\n\n        n_absent = 0\n        n_late = 0\n        is_eligible = .false.\n\n        do i = 1, len(s) - 2\n            if (s(i:i+2) == 'AA') then\n                n_absent = n_absent + 1\n            end if\n            if (s(i:i+2) == 'LLL') then\n                n_late = n_late + 1\n            end if\n            if (n_absent < 2 .and. n_late == 0) then\n                is_eligible = .true.\n            else if (n_absent >= 2 .or. n_late >= 3) then\n                exit\n            end if\n        end do\n\n        result = is_eligible\n    end function solve\n\nend program main",
  "557": "program main\n    implicit none\n\n    character(len=:), allocatable :: s, reversed_string\n    integer :: i, j, k\n\n    ! Example 1\n    s = \"Let's take LeetCode contest\"\n    call reverse_words(s)\n    write (*,*) 'Example 1:'\n    write (*,'(A)') trim(adjustl(s)) // ' -> ' // trim(adjustl(reversed_string))\n\n    ! Example 2\n    s = \"God Ding\"\n    call reverse_words(s)\n    write (*,*) 'Example 2:'\n    write (*,'(A)') trim(adjustl(s)) // ' -> ' // trim(adjustl(reversed_string))\n\ncontains\n\n    subroutine reverse_words(s)\n        implicit none\n        character(len=*), intent(inout) :: s\n        integer :: i, j\n\n        do i = 1, len(s)\n            if (s(i:i) == ' ') then\n                cycle\n            end if\n\n            j = i\n            do while (j < len(s) .and. s(j+1:j+1) /= ' ')\n                j = j + 1\n            end do\n\n            reversed_string = s(i:j-1)\n            call reverse_string(reversed_string)\n            s(i:j-1) = reversed_string\n        end do\n    end subroutine reverse_words\n\n    subroutine reverse_string(s)\n        implicit none\n        character(len=*), intent(inout) :: s\n        integer :: i, j\n\n        i = 1\n        j = len(s)\n        do while (i < j)\n            s(i:i) = s(j:j)\n            s(j:j) = s(i:i)\n            i = i + 1\n            j = j - 1\n        end do\n    end subroutine reverse_string\n\nend program main",
  "559": "program main\n    implicit none\n\n    type :: Node\n        integer :: val\n        type(Node), pointer :: left(:) => null()\n        type(Node), pointer :: right(:) => null()\n    end type\n\n    type(Node), target :: root\n    type(Node), pointer :: curr\n    integer :: i, j\n\n    ! Example 1\n    allocate(root%left(1))\n    allocate(root%right(2))\n    root%val = 1\n    root%left(1)%val = 3\n    root%right(1)%val = 2\n    root%right(2)%val = 4\n\n    print '(I0)', maxDepth(root)\n\n    ! Example 2\n    deallocate(root%left)\n    deallocate(root%right)\n    allocate(root%left(2))\n    allocate(root%right(3))\n    root%val = 1\n    root%left(1)%val = 5\n    root%left(2)%val = 6\n    root%right(1)%val = 7\n    root%right(2)%val = 8\n    root%right(3)%val = 9\n    root%right(3)%left(1)%val = 10\n    root%right(3)%right(1)%val = 11\n    root%right(3)%right(2)%val = 12\n    root%right(3)%right(2)%left(1)%val = 13\n    root%right(3)%right(2)%right(1)%val = 14\n\n    print '(I0)', maxDepth(root)\n\ncontains\n\n    function maxDepth(root) result(depth)\n        implicit none\n        class(Node), intent(in) :: root\n        integer :: depth\n        type(Node), pointer :: curr\n        integer :: i\n\n        depth = 0\n        curr => root\n        do while (associated(curr))\n            if (associated(curr%left)) then\n                depth = max(depth, maxDepth(curr%left))\n            end if\n            if (associated(curr%right)) then\n                depth = max(depth, maxDepth(curr%right))\n            end if\n            curr => curr%left\n        end do\n    end function\n\nend program",
  "561": "program main\n    implicit none\n\n    integer, parameter :: n = 2\n    integer, parameter :: nums(2*n) = [1, 4, 3, 2, 6, 2, 6, 5, 1, 2]\n    integer :: i, j, k\n    integer :: min_val\n    integer :: max_sum\n\n    ! Initialize variables\n    max_sum = 0\n\n    ! Loop over all possible pairs\n    do i = 1, n\n        do j = i+1, n\n            min_val = min(nums(i), nums(j))\n            max_sum = max(max_sum, min_val)\n        end do\n    end do\n\n    print '(I0)', max_sum\n\nend program main",
  "563": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=*), parameter :: filename_in = \"example_input.txt\"\n    character(len=*), parameter :: filename_out = \"example_output.txt\"\n    type :: node_type\n        real(kind=DP) :: val\n        type(node_type), pointer :: left, right\n    end type node_type\n    type(node_type), pointer :: root\n    integer :: i, n\n    real(kind=DP) :: tilt\n\n    ! Read input from file\n    open(newunit=unit_in, file=filename_in, status='old', action='read')\n    read(unit=unit_in, fmt=*) n\n    allocate(root)\n    do i = 1, n\n        read(unit=unit_in, fmt=*) root%val\n        call solve(root)\n    end do\n    close(unit=unit_in)\n\n    ! Write output to file\n    open(newunit=unit_out, file=filename_out, status='replace', action='write')\n    write(unit=unit_out, fmt=*) tilt\n    close(unit=unit_out)\n\ncontains\n\n    recursive subroutine solve(this)\n        class(node_type), intent(inout) :: this\n        if (.not. associated(this)) return\n        call solve(this%left)\n        call solve(this%right)\n        tilt = abs(sum(this%left%val) - sum(this%right%val))\n    end subroutine solve\n\nend program main",
  "566": "program main\n    implicit none\n\n    integer, parameter :: m = 2, n = 2\n    integer, parameter :: r = 1, c = 4\n    integer :: i, j\n    integer :: mat(m, n) = reshape([1, 2, 3, 4], shape(mat))\n    integer :: reshaped_mat(r, c)\n\n    write(*,*) \"Original matrix:\"\n    do i = 1, m\n        write(*,\"(5(I3,1X))\") mat(i,:)\n    end do\n\n    if (size(mat, 1) * size(mat, 2) == r * c) then\n        reshaped_mat = reshape(mat, shape(reshaped_mat))\n        write(*,*) \"Reshaped matrix:\"\n        do i = 1, r\n            write(*,\"(5(I3,1X))\") reshaped_mat(i,:)\n        end do\n    else\n        write(*,*) \"Original matrix:\"\n        do i = 1, m\n            write(*,\"(5(I3,1X))\") mat(i,:)\n        end do\n    end if\n\nend program main",
  "572": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 7\n    real(kind=DP), dimension(n) :: root = [3._DP, 4._DP, 5._DP, 1._DP, &\n                                           2._DP, -1._DP, -2._DP]\n    real(kind=DP), dimension(n) :: subRoot = [4._DP, 1._DP, 2._DP]\n    logical :: result\n\n    print '(L1)', hasSubtree(root, subRoot)\n\ncontains\n\n    function hasSubtree(root, subRoot) result(res)\n        real(kind=DP), intent(in) :: root(:), subRoot(:)\n        logical :: res\n\n        res = .false.\n\n        call hasSubtreeRecursive(root, subRoot, 1, res)\n\n    end function hasSubtree\n\n    recursive subroutine hasSubtreeRecursive(root, subRoot, idx, found)\n        real(kind=DP), intent(in) :: root(:), subRoot(:)\n        integer, value :: idx\n        logical, intent(out) :: found\n        integer :: i\n\n        if (idx > size(root)) then\n            return\n        end if\n\n        if (root(idx) == subRoot(1)) then\n            found = .true.\n            do i = 2, size(subRoot)\n                if (root(idx+i-1) /= subRoot(i)) then\n                    found = .false.\n                    exit\n                end if\n            end do\n            if (.not. found) then\n                return\n            end if\n        end if\n\n        call hasSubtreeRecursive(root, subRoot, idx+1, found)\n\n        if (.not. found) then\n            call hasSubtreeRecursive(root, subRoot, idx+size(root)-idx+1, found)\n        end if\n\n    end subroutine hasSubtreeRecursive\n\nend program main",
  "575": "program main\n    implicit none\n\n    integer :: n, i\n    integer, allocatable :: candyType(:)\n    integer :: maxTypes\n\n    ! read input\n    read(*,*) n\n    allocate(candyType(n))\n    do i = 1, n\n        read(*,*) candyType(i)\n    end do\n\n    ! solve problem\n    maxTypes = solve(n, candyType)\n\n    ! print output\n    write(*,*) maxTypes\n\ncontains\n\n    function solve(n, candyType) result(maxTypes)\n        implicit none\n        integer, intent(in) :: n\n        integer, intent(in) :: candyType(:)\n        integer :: maxTypes\n        integer :: i, j, count\n\n        maxTypes = 0\n        do i = 1, n - 1\n            count = 0\n            do j = i + 1, n\n                if (candyType(j) /= candyType(i)) then\n                    count = count + 1\n                end if\n            end do\n            maxTypes = max(maxTypes, count)\n        end do\n    end function solve\n\nend program main",
  "589": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=*), parameter :: filename_in = \"narytree.txt\"\n    character(len=*), parameter :: filename_out = \"preordertraversal.txt\"\n    type :: node\n        real(kind=DP) :: val\n        class(*), pointer :: left => null(), right => null()\n    end type\n    type(node), pointer :: root => null()\n    integer :: i, j, k, l, m, n\n    logical :: eof\n    real(kind=DP) :: x\n\n    ! Read the input file\n    open(newunit=unit_in, file=filename_in, status='old', action='read', &\n         form='formatted', access='sequential', position='rewind', &\n         iomsg=i, iostat=j)\n    if (j /= 0) then\n        write(unit=error_unit, fmt='(A,I0,A)') 'Error: Can not open file ', j, ' for reading.'\n        stop 1\n    end if\n    read(unit=unit_in, fmt=*, iomsg=k, iostat=l) root\n    close(unit=unit_in)\n    if (k /= '') then\n        write(unit=error_unit, fmt='(A,A)') 'Error: Reading from file ', trim(k), ' failed.'\n        stop 2\n    end if\n    if (l /= 0) then\n        write(unit=error_unit, fmt='(A,I0,A)') 'Error: Reading from file ', l, ' failed.'\n        stop 3\n    end if\n\n    ! Print the preorder traversal of the nodes' values\n    call print_preorder_traversal(root)\n\ncontains\n\n    subroutine print_preorder_traversal(root)\n        implicit none\n        class(node), pointer, intent(in) :: root\n        logical :: first\n        first = .true.\n        do while (associated(root))\n            if (.not.first) then\n                write(unit=unit_out, fmt='(A)', advance='no') ','\n            else\n                first = .false.\n            end if\n            write(unit=unit_out, fmt='(ES24.16)') root%val\n            call print_preorder_traversal(root%left)\n            call print_preorder_traversal(root%right)\n        end do\n    end subroutine print_preorder_traversal\n\nend program main",
  "590": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=256) :: filename_in, filename_out\n    type :: node\n        real(kind=DP), allocatable :: val(:)\n    end type node\n    type(node), pointer :: root\n    integer :: i, j, k, n, m\n\n    ! read input from file\n    write (unit=unit_out, fmt='(A)') 'Enter filename for input:'\n    read (unit=unit_in, fmt='(A)') filename_in\n    open (newunit=unit_in, file=filename_in, status='old', action='read', &\n          access='sequential', form='formatted', iostat=i, iomsg=filename_in)\n    if (i /= 0) then\n        write (unit=error_unit, fmt='(2A)') 'error: can not open file \"', trim(filename_in)\n        stop 1\n    end if\n    read (unit=unit_in, fmt=*) n\n    allocate (root%val(n))\n    do i = 1, n\n        read (unit=unit_in, fmt=*) root%val(i)\n    end do\n    close (unit=unit_in)\n\n    ! solve the problem\n    call postorder_traversal(root)\n\n    ! write output to file\n    write (unit=unit_out, fmt='(A)') 'Enter filename for output:'\n    read (unit=unit_in, fmt='(A)') filename_out\n    open (newunit=unit_out, file=filename_out, status='replace', action='write', &\n          access='sequential', form='formatted', iostat=i, iomsg=filename_out)\n    if (i /= 0) then\n        write (unit=error_unit, fmt='(2A)') 'error: can not create file \"', trim(filename_out)\n        stop 1\n    end if\n    write (unit=unit_out, fmt=*) root%val\n    close (unit=unit_out)\n\ncontains\n\n    subroutine postorder_traversal(root)\n        implicit none\n        class(node), intent(inout) :: root\n        integer :: i, j, k, n\n        logical :: done\n\n        done = .false.\n        do while (.not. done)\n            select case (size(root%val))\n                case (0)\n                    done = .true.\n                case (1)\n                    done = .true.\n                case default\n                    do i = 1, size(root%val)-1\n                        if (allocated(root%val(i)%val)) then\n                            call postorder_traversal(root%val(i))\n                        end if\n                    end do\n                    do i = size(root%val), 2, -1\n                        if (allocated(root%val(i)%val)) then\n                            call postorder_traversal(root%val(i))\n                        end if\n                    end do\n                    done = .true.\n            end select\n        end do\n    end subroutine postorder_traversal\n\nend program main",
  "594": "program main\n    ! Solves the problem \"Harmonious Array\"\n    implicit none\n\n    integer, parameter :: n = 8\n    integer, dimension(n) :: nums\n    integer :: i, j, max_diff, min_diff\n    integer :: longest_harmonious_subsequence\n\n    ! Examples\n    nums = [1, 3, 2, 2, 5, 2, 3, 7]\n    write (*, '(a, i0)') 'Example 1: ', longest_harmonious_subsequence(nums)\n    nums = [1, 2, 3, 4]\n    write (*, '(a, i0)') 'Example 2: ', longest_harmonious_subsequence(nums)\n    nums = [1, 1, 1, 1]\n    write (*, '(a, i0)') 'Example 3: ', longest_harmonious_subsequence(nums)\n\ncontains\n\n    function longest_harmonious_subsequence(nums) result(max_len)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: max_len, len, i, j\n\n        do i = 1, size(nums) - 1\n            do j = i + 1, size(nums)\n                if (abs(nums(j) - nums(i)) == 1) then\n                    len = len + 1\n                end if\n            end do\n            if (len > max_len) then\n                max_len = len\n            end if\n            len = 0\n        end do\n    end function longest_harmonious_subsequence\n\nend program main",
  "598": "program main\n    implicit none\n\n    integer :: m, n, i, j, max_val, count\n    integer, allocatable :: M(:, :)\n    integer, allocatable :: ops(:, :)\n\n    read(*,*) m, n\n    allocate(M(m,n))\n    do i = 1, m\n        do j = 1, n\n            M(i,j) = 0\n        end do\n    end do\n    read(*,*) ops\n    do i = 1, size(ops, 1)\n        M(ops(i,1), ops(i,2)) = M(ops(i,1), ops(i,2)) + 1\n    end do\n    max_val = -huge(max_val)\n    count = 0\n    do i = 1, m\n        do j = 1, n\n            if (M(i,j) > max_val) then\n                max_val = M(i,j)\n                count = count + 1\n            end if\n        end do\n    end do\n    print '(I0)', count\n\nend program main",
  "599": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, output_unit\n    implicit none\n    character(len=:), allocatable :: list1(:), list2(:)\n    integer :: i, j, k, n, m\n    type(string_set) :: common_strings\n\n    call get_command_argument(1, n)\n    allocate(list1(n))\n    do i = 1, n\n        call get_command_argument(i+1, list1(i))\n    end do\n\n    call get_command_argument(2, m)\n    allocate(list2(m))\n    do j = 1, m\n        call get_command_argument(j+1+n, list2(j))\n    end do\n\n    common_strings = get_common_strings(list1, list2)\n\n    write (output_unit, '(*(g0,:,\" \",a))') common_strings%strings\n\ncontains\n\n    function get_common_strings(list1, list2) result(common_strings)\n        implicit none\n        character(len=*), intent(in) :: list1(:), list2(:)\n        type(string_set) :: common_strings\n        integer :: i, j\n\n        common_strings = string_set()\n\n        do i = 1, size(list1)\n            do j = 1, size(list2)\n                if (list1(i) == list2(j)) then\n                    call common_strings%add(list1(i))\n                end if\n            end do\n        end do\n\n    end function get_common_strings\n\n    type :: string_set\n        class(*), pointer :: strings(:) => null()\n    contains\n        procedure :: add => add_string\n        generic :: assignment(=) => add\n    end type string_set\n\n    subroutine add_string(self, string)\n        implicit none\n        class(string_set), intent(inout) :: self\n        character(len=*), intent(in) :: string\n        integer :: i\n\n        if (.not. associated(self%strings)) then\n            allocate(self%strings(1))\n            self%strings(1) = string\n        else\n            do i = 1, size(self%strings)\n                if (self%strings(i) == string) return\n            end do\n            allocate(self%strings(size(self%strings)+1))\n            self%strings(size(self%strings)) = string\n        end if\n\n    end subroutine add_string\n\nend program main",
  "604": "program main\n    use StringIterator_mod\n    implicit none\n\n    type(StringIterator) :: stringIterator\n    character(len=:), allocatable :: nextChar\n    logical :: hasNext\n\n    ! Examples\n    call stringIterator%init(\"L1e2t1C1o1d1e1\")\n    do while (stringIterator%hasNext())\n        nextChar = stringIterator%next()\n        write (*, \"(A)\", advance=\"no\") trim(nextChar)\n    end do\n    write (*, *)\n\n    call stringIterator%init(\"\")\n    do while (stringIterator%hasNext())\n        nextChar = stringIterator%next()\n        write (*, \"(A)\", advance=\"no\") trim(nextChar)\n    end do\n    write (*, *)\n\ncontains\n\n    subroutine init(this, compressedString)\n        class(StringIterator), intent(inout) :: this\n        character(len=*), intent(in) :: compressedString\n\n        this%compressedString = compressedString\n        this%index = 1\n    end subroutine init\n\n    function next(this) result(res)\n        class(StringIterator), intent(inout) :: this\n        character(len=1), allocatable :: res\n\n        if (this%index > len(this%compressedString)) then\n            res = ' '\n        else\n            read (this%compressedString(this%index:), fmt='(A)', iostat=ioStatus) res\n            this%index = this%index + len(res) + 1\n        end if\n    end function next\n\n    function hasNext(this) result(res)\n        class(StringIterator), intent(inout) :: this\n        logical :: res\n\n        res = this%index <= len(this%compressedString)\n    end function hasNext\nend program main\n\nmodule StringIterator_mod\n    implicit none\n\n    private\n    public :: StringIterator\n\n    type :: StringIterator\n        character(len=:), allocatable :: compressedString\n        integer :: index\n    contains\n        procedure :: init => init\n        procedure :: next => next\n        procedure :: hasNext => hasNext\n    end type StringIterator\n\ncontains\n\n    subroutine init(this, compressedString)\n        class(StringIterator), intent(inout) :: this\n        character(len=*), intent(in) :: compressedString\n\n        this%compressedString = compressedString\n        this%index = 1\n    end subroutine init\n\n    function next(this) result(res)\n        class(StringIterator), intent(inout) :: this\n        character(len=1), allocatable :: res\n\n        if (this%index > len(this%compressedString)) then\n            res = ' '\n        else\n            read (this%compressedString(this%index:), fmt='(A)', iostat=ioStatus) res\n            this%index = this%index + len(res) + 1\n        end if\n    end function next\n\n    function hasNext(this) result(res)\n        class(StringIterator), intent(inout) :: this\n        logical :: res\n\n        res = this%index <= len(this%compressedString)\n    end function hasNext\nend module StringIterator_mod",
  "605": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: flowerbed\n    logical :: result\n\n    flowerbed = [1, 0, 0, 0, 1]\n    result = canPlaceFlowers(flowerbed, 1)\n    print '(L1)', result\n\n    flowerbed = [1, 0, 0, 0, 1]\n    result = canPlaceFlowers(flowerbed, 2)\n    print '(L1)', result\n\ncontains\n\n    function canPlaceFlowers(flowerbed, n) result(canPlace)\n        implicit none\n        integer, intent(in) :: flowerbed(:), n\n        logical :: canPlace\n        integer :: i, j\n\n        do i = 1, size(flowerbed) - 1\n            if (flowerbed(i) == 0 .and. flowerbed(i+1) == 0) then\n                do j = i + 1, i + n\n                    if (j > size(flowerbed)) exit\n                    if (flowerbed(j) /= 0) then\n                        canPlace = .false.\n                        exit\n                    end if\n                end do\n                if (canPlace) exit\n            end if\n        end do\n\n        if (i > size(flowerbed)) then\n            canPlace = .true.\n        else\n            canPlace = .false.\n        end if\n\n    end function canPlaceFlowers\nend program main",
  "606": "program main\n    ! Solve the problem described in the task\n    implicit none\n\n    type :: node_t\n        integer :: val\n        type(node_t), pointer :: left => null(), right => null()\n    end type\n\n    type(node_t), target :: root\n    character(len=:), allocatable :: str\n\n    call solve(root, str)\n    write (unit=*, fmt='(A)') trim(str)\n\ncontains\n\n    subroutine solve(root, str)\n        ! Solve the problem\n        implicit none\n        class(node_t), intent(inout) :: root\n        character(len=:), allocatable, intent(out) :: str\n        integer :: i, j, k, n\n        character(len=:), allocatable :: tmp\n\n        if (.not. associated(root%left)) then\n            ! If there are no children, just print the value\n            allocate (character(len=len(trim(str))) :: tmp)\n            write (tmp, fmt='(I0)') root%val\n            str = trim(adjustl(tmp)) // ' ' // str\n            deallocate (tmp)\n        else\n            ! Otherwise, recurse on both children\n            call solve(root%left, str)\n            call solve(root%right, str)\n        end if\n\n        ! Omit any empty parenthesis pairs that don't affect the one-to-one\n        ! mapping relationship between the string and the original binary tree\n        n = len_trim(str)\n        do i = 1, n - 1\n            if (str(i:i+1) == '()') then\n                j = i + 2\n                do while (j <= n .and. str(j:j) /= ')')\n                    j = j + 1\n                end do\n                if (j > n) exit\n                if (str(j:j) == ')') then\n                    k = j - 1\n                    do while (k >= 1 .and. str(k:k) /= '(')\n                        k = k - 1\n                    end do\n                    if (k < 1) exit\n                    if (str(k:k+1) == '(())') then\n                        str = str(:i-1) // str(j+1:)\n                    end if\n                end if\n            end if\n        end do\n\n    end subroutine\n\nend program",
  "617": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, iostat_end, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    type :: node\n        real(kind=DP) :: val\n        class(*), pointer :: left => null(), right => null()\n    end type\n    type(node), pointer :: root1, root2, new_root\n    character(len=200) :: buffer\n    integer :: stat\n\n    ! Read input\n    open(newunit=unit_in, file=\"input.txt\", status=\"old\", action=\"read\", &\n         access=\"sequential\", form=\"formatted\", iomsg=buffer, iostat=stat)\n    if (stat /= 0) then\n        write(error_unit, \"(A, ': ', A)\") \"main\", buffer\n        stop 1\n    end if\n    read(unit=unit_in, fmt=*) root1\n    read(unit=unit_in, fmt=*) root2\n    close(unit=unit_in)\n\n    ! Solve problem\n    new_root => merge_trees(root1, root2)\n\n    ! Print output\n    open(newunit=unit_out, file=\"output.txt\", status=\"replace\", action=\"write\", &\n         access=\"sequential\", form=\"formatted\")\n    call print_tree(new_root, unit=unit_out)\n    close(unit=unit_out)\n\ncontains\n\n    function merge_trees(root1, root2) result(new_root)\n        class(node), pointer :: root1, root2, new_root\n        type(node), pointer :: current\n\n        allocate(current)\n        current%val = root1%val + root2%val\n        if (associated(root1%left)) then\n            if (associated(root2%left)) then\n                current%left => merge_trees(root1%left, root2%left)\n            else\n                current%left => root1%left\n            end if\n        else if (associated(root2%left)) then\n            current%left => root2%left\n        end if\n        if (associated(root1%right)) then\n            if (associated(root2%right)) then\n                current%right => merge_trees(root1%right, root2%right)\n            else\n                current%right => root1%right\n            end if\n        else if (associated(root2%right)) then\n            current%right => root2%right\n        end if\n        new_root => current\n    end function\n\n    subroutine print_tree(root, unit)\n        class(node), pointer :: root\n        integer, intent(in) :: unit\n        character(len=200) :: buffer\n\n        if (.not. associated(root)) then\n            return\n        end if\n        write(unit=unit, fmt=\"(F8.2)\") root%val\n        if (associated(root%left)) then\n            write(unit=unit, fmt=\"('(', F8.2)\") root%left%val\n            call print_tree(root%left, unit=unit)\n            write(unit=unit, fmt=\"(')')\")\n        end if\n        if (associated(root%right)) then\n            write(unit=unit, fmt=\"('(', F8.2)\") root%right%val\n            call print_tree(root%right, unit=unit)\n            write(unit=unit, fmt=\"(')')\")\n        end if\n    end subroutine\n\nend program",
  "628": "program max_product\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: nums\n    integer :: i, j, k\n    integer :: max_prod\n\n    ! Example 1\n    nums = (/ 1, 2, 3 /)\n    write (*, '(A, I0)') 'Example 1: ', max_product_sub(nums)\n\n    ! Example 2\n    nums = (/ 1, 2, 3, 4 /)\n    write (*, '(A, I0)') 'Example 2: ', max_product_sub(nums)\n\n    ! Example 3\n    nums = (/ -1, -2, -3 /)\n    write (*, '(A, I0)') 'Example 3: ', max_product_sub(nums)\n\ncontains\n\n    function max_product_sub(nums) result(max_prod)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: i, j, k\n        integer :: max_prod\n\n        max_prod = 0\n        do i = 1, size(nums) - 2\n            do j = i + 1, size(nums) - 1\n                do k = j + 1, size(nums)\n                    if (nums(i) * nums(j) * nums(k) > max_prod) then\n                        max_prod = nums(i) * nums(j) * nums(k)\n                    end if\n                end do\n            end do\n        end do\n    end function max_product_sub\n\nend program max_product",
  "637": "program main\n    ! Solves the problem at https://leetcode.com/problems/average-of-levels-in-binary-tree/\n    implicit none\n\n    type :: TreeNode\n        integer :: val\n        type(TreeNode), pointer :: left => null(), right => null()\n    end type TreeNode\n\n    type(TreeNode), target :: root\n    real :: avg_levels(3)\n\n    call test_case_1()\n    call test_case_2()\n\ncontains\n\n    subroutine test_case_1()\n        type(TreeNode), target :: root\n        real :: avg_levels(3)\n\n        root%val = 3\n        allocate(root%left)\n        root%left%val = 9\n        allocate(root%right)\n        root%right%val = 20\n        allocate(root%left%left)\n        root%left%left%val = 15\n        allocate(root%right%left)\n        root%right%left%val = 7\n\n        avg_levels = averageOfLevels(root)\n\n        write(*,*) 'Test case 1:'\n        write(*,*) 'Expected: ', [3.0d0, 14.5d0, 11.0d0]\n        write(*,*) 'Actual: ', avg_levels\n    end subroutine test_case_1\n\n    subroutine test_case_2()\n        type(TreeNode), target :: root\n        real :: avg_levels(3)\n\n        root%val = 3\n        allocate(root%left)\n        root%left%val = 9\n        allocate(root%right)\n        root%right%val = 20\n        allocate(root%left%left)\n        root%left%left%val = 15\n        allocate(root%right%left)\n        root%right%left%val = 7\n\n        avg_levels = averageOfLevels(root)\n\n        write(*,*) 'Test case 2:'\n        write(*,*) 'Expected: ', [3.0d0, 14.5d0, 11.0d0]\n        write(*,*) 'Actual: ', avg_levels\n    end subroutine test_case_2\n\n    function averageOfLevels(root) result(avg_levels)\n        type(TreeNode), target, intent(in) :: root\n        real :: avg_levels(size(root))\n        integer :: i, j, n_nodes, n_levels\n        logical :: done\n        type(TreeNode), pointer :: node, next_node\n\n        n_nodes = countNodes(root)\n        n_levels = 0\n        do while (associated(root))\n            n_levels = n_levels + 1\n            node => root\n            done = .false.\n            do while (.not. done)\n                if (associated(node%left)) then\n                    next_node => node%left\n                else if (associated(node%right)) then\n                    next_node => node%right\n                else\n                    done = .true.\n                end if\n                node => next_node\n            end do\n        end do\n\n        avg_levels = 0.0d0\n        do i = 1, n_levels\n            node => root\n            done = .false.\n            do while (.not. done)\n                avg_levels(i) = avg_levels(i) + dble(node%val)\n                if (associated(node%left)) then\n                    next_node => node%left\n                else if (associated(node%right)) then\n                    next_node => node%right\n                else\n                    done = .true.\n                end if\n                node => next_node\n            end do\n        end do\n\n        avg_levels = avg_levels / dble(n_nodes)\n    end function averageOfLevels\n\n    recursive function countNodes(root) result(count)\n        type(TreeNode), target, intent(in) :: root\n        integer :: count\n\n        if (.not. associated(root)) then\n            count = 0\n        else\n            count = 1 + countNodes(root%left) + count",
  "643": "program main\n    implicit none\n\n    integer, parameter :: dp = selected_real_kind(15, 307) ! double precision\n\n    integer, dimension(:), allocatable :: nums\n    integer :: n, k\n    real(dp) :: max_avg\n\n    call get_args(n, k)\n\n    allocate(nums(n))\n\n    read(*, *) nums\n\n    max_avg = find_max_avg(nums, n, k)\n\n    write (*, '(F10.5)') max_avg\n\ncontains\n\n    function find_max_avg(nums, n, k) result(max_avg)\n        implicit none\n\n        integer, intent(in) :: n, k\n        integer, dimension(:), intent(in) :: nums\n        real(dp) :: max_avg\n\n        integer :: i, j\n        real(dp) :: avg\n\n        do i = 1, n - k + 1\n            avg = 0.0_dp\n            do j = i, i + k - 1\n                avg = avg + nums(j)\n            end do\n            avg = avg / k\n\n            if (abs(avg - max_avg) < 1.0e-5_dp) then\n                max_avg = max(avg, max_avg)\n            else if (avg > max_avg) then\n                max_avg = avg\n            end if\n        end do\n\n    end function find_max_avg\n\n    subroutine get_args(n, k)\n        implicit none\n\n        integer, intent(out) :: n, k\n\n        character(len=100) :: buffer\n\n        read(*, '(A)') buffer\n        read(buffer, *) n\n        read(*, '(A)') buffer\n        read(buffer, *) k\n\n    end subroutine get_args\n\nend program main",
  "645": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: s\n    integer, dimension(n) :: nums\n    integer :: i\n\n    ! Original set\n    s = (/ (i, i=1,n) /)\n\n    ! Error: one number got duplicated\n    nums = (/ 1, 2, 2, 4, 5 /)\n\n    call solve(nums)\n\ncontains\n\n    subroutine solve(nums)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: repeated, missing\n\n        repeated = find_repeated(nums)\n        missing = find_missing(nums)\n\n        write (*,*) 'Repeated: ', repeated\n        write (*,*) 'Missing: ', missing\n\n    end subroutine solve\n\n    function find_repeated(nums) result(repeated)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: repeated\n        logical :: found\n\n        repeated = 0\n        do i = 1, size(nums) - 1\n            if (any(nums(i+1:) == nums(i))) then\n                repeated = nums(i)\n                exit\n            end if\n        end do\n\n    end function find_repeated\n\n    function find_missing(nums) result(missing)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: missing\n        logical :: found\n\n        missing = 0\n        do i = 1, size(nums)\n            found = any(nums == i)\n            if (.not. found) then\n                missing = i\n                exit\n            end if\n        end do\n\n    end function find_missing\n\nend program main",
  "653": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 10\n    type(DP), dimension(n) :: x, y\n    logical :: res\n\n    ! Example 1\n    x = (/ 5._DP, 3._DP, 6._DP, 2._DP, 4._DP, -1._DP, 7._DP /)\n    y = (/ 5._DP, 3._DP, 6._DP, 2._DP, 4._DP, -1._DP, 7._DP /)\n    call solve(x, y, 9._DP, res)\n    write (unit=error_unit, fmt='(L1)') res\n\n    ! Example 2\n    x = (/ 5._DP, 3._DP, 6._DP, 2._DP, 4._DP, -1._DP, 7._DP /)\n    y = (/ 5._DP, 3._DP, 6._DP, 2._DP, 4._DP, -1._DP, 7._DP /)\n    call solve(x, y, 28._DP, res)\n    write (unit=error_unit, fmt='(L1)') res\n\ncontains\n\n    subroutine solve(root, k, res)\n        implicit none\n        type(DP), dimension(:), intent(in) :: root\n        real(kind=DP), intent(in) :: k\n        logical, intent(out) :: res\n        integer :: i, j\n\n        res = .false.\n        do i = 1, size(root)-1\n            do j = i+1, size(root)\n                if (root(i)+root(j) == k) then\n                    res = .true.\n                    exit\n                end if\n            end do\n            if (res) exit\n        end do\n    end subroutine solve\n\nend program main",
  "657": "program main\n    implicit none\n\n    character(len=3) :: moves\n\n    moves = 'UD '\n    print '(L1)', judgeCircle(moves)\n\n    moves = 'LL '\n    print '(L1)', judgeCircle(moves)\n\ncontains\n\nlogical function judgeCircle(moves) result(isAtOrigin)\n    implicit none\n    character(len=*), intent(in) :: moves\n    integer :: i\n\n    isAtOrigin = .true.\n    do i = 1, len(moves)\n        select case(moves(i:i))\n            case('R')\n                isAtOrigin = isAtOrigin .and. (0 == modulo(i-1, 2))\n            case('L')\n                isAtOrigin = isAtOrigin .and. (0 == modulo(i-1, 2))\n            case('U')\n                isAtOrigin = isAtOrigin .and. (0 == modulo(i-1, 2))\n            case('D')\n                isAtOrigin = isAtOrigin .and. (0 == modulo(i-1, 2))\n            case default\n                stop 'Invalid input.'\n        end select\n    end do\nend function judgeCircle\n\nend program main",
  "661": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, iostat_end, DP => REAL64\n    implicit none\n    integer, parameter :: m = 3, n = 3\n    integer, dimension(m, n) :: img\n    real(kind=DP), dimension(m, n) :: smoothed_img\n    integer :: i, j\n\n    ! read input\n    read(*, *) img\n\n    ! apply smoother\n    do i = 1, m\n        do j = 1, n\n            smoothed_img(i, j) = floor(avg(img(i-1:i+1, j-1:j+1)))\n        end do\n    end do\n\n    ! print output\n    write (*, '(A)') 'Smoothed image:'\n    do i = 1, m\n        write (*, '(3I3)') smoothed_img(i, :)\n    end do\n\ncontains\n\n    function avg(arr) result(res)\n        implicit none\n        integer, intent(in) :: arr(:, :)\n        integer :: res\n        res = sum(arr) / size(arr, dim=1)\n    end function avg\n\nend program main",
  "671": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=*), parameter :: filename_in = \"example_input.txt\", &\n                                   filename_out = \"example_output.txt\"\n    type :: node\n        real(kind=DP) :: val\n        class(*), pointer :: left => null(), right => null()\n    end type\n    type(node), pointer :: root\n    integer :: i, n\n    logical :: file_exists\n\n    ! Read input from file\n    inquire(file=filename_in, exist=file_exists)\n    if (file_exists) then\n        open(newunit=unit_in, file=filename_in, status=\"old\", action=\"read\")\n        read(unit=unit_in, fmt=*) n\n        allocate(root)\n        do i = 1, n\n            call read_node(unit_in, root)\n        end do\n        close(unit=unit_in)\n    else\n        write(unit=error_unit, fmt=\"('error: ',A)\") \"file not found: '\" // trim(filename_in) // \"'.\"\n        stop 1\n    end if\n\n    ! Print output to file\n    open(newunit=unit_out, file=filename_out, status=\"replace\", action=\"write\")\n    call print_second_min(root, unit=unit_out)\n    close(unit=unit_out)\n\ncontains\n\n    subroutine read_node(unit, node)\n        implicit none\n        integer, intent(in) :: unit\n        class(*), pointer, intent(out) :: node\n        integer :: i\n        character(len=100) :: line\n\n        read(unit=unit, fmt=*) line\n        if (line == \"null\") then\n            nullify(node)\n        else\n            allocate(node)\n            read(unit=unit, fmt=*) node%val\n            read(unit=unit, fmt=*) i\n            if (i > 0) then\n                allocate(node%left)\n                call read_node(unit, node%left)\n            end if\n            read(unit=unit, fmt=*) i\n            if (i > 0) then\n                allocate(node%right)\n                call read_node(unit, node%right)\n            end if\n        end if\n    end subroutine\n\n    subroutine print_second_min(node, unit)\n        implicit none\n        class(*), pointer, intent(in) :: node\n        integer, intent(in) :: unit\n        integer :: i\n\n        if (.not. associated(node)) then\n            write(unit=unit, fmt=\"(-1)\")\n        else\n            if (associated(node%left) .and. associated(node%right)) then\n                call print_second_min(node%left, unit=unit)\n                call print_second_min(node%right, unit=unit)\n            else if (associated(node%left)) then\n                call print_second_min(node%left, unit=unit)\n            else if (associated(node%right)) then\n                call print_second_min(node%right, unit=unit)\n            else\n                write(unit=unit, fmt=*) node%val\n            end if\n        end if\n    end subroutine\n\nend program",
  "674": "program main\n    ! Solves the problem:\n    ! Given an unsorted array of integers nums, return the length of the longest\n    ! continuous increasing subsequence (i.e., subarray). The subsequence must be\n    ! strictly increasing.\n    implicit none\n\n    integer :: nums(10), len_longest_subseq\n\n    nums = [1, 3, 5, 4, 7]\n    print '(I0)', len_longest_subseq(nums)\n\n    nums = [2, 2, 2, 2, 2]\n    print '(I0)', len_longest_subseq(nums)\n\ncontains\n\n    function len_longest_subseq(nums) result(len)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: len, i, j, n\n\n        n = size(nums)\n        if (n == 0) then\n            len = 0\n            return\n        end if\n\n        len = 1\n        do i = 2, n\n            if (nums(i-1) < nums(i)) then\n                len = len + 1\n            else\n                j = i - 1\n                do while (j > 1 .and. nums(j-1) >= nums(j))\n                    j = j - 1\n                end do\n                len = max(len, i - j)\n            end if\n        end do\n    end function len_longest_subseq\n\nend program main",
  "680": "program main\n    implicit none\n\n    integer, parameter :: ntests = 3\n    character(len=:), allocatable :: tests(:)\n    logical :: results(:)\n\n    tests = [\"aba\", \"abca\", \"abc\"]\n    allocate(results(size(tests)))\n\n    results = .false.\n    do i = 1, size(tests)\n        results(i) = canPalindrome(tests(i))\n    end do\n\n    write(*, \"(A)\") \"Results:\"\n    do i = 1, size(tests)\n        write(*, \"(A, L1)\") trim(tests(i)), results(i)\n    end do\n\ncontains\n\n    function canPalindrome(s) result(res)\n        implicit none\n        character(len=*), intent(in) :: s\n        logical :: res\n        integer :: i, j\n\n        res = .true.\n        do i = 1, len(s)/2\n            if (s(i:i) /= s(len(s)-i+1:len(s)-i)) then\n                res = .false.\n                exit\n            end if\n        end do\n    end function canPalindrome\n\nend program main",
  "682": "program main\n    implicit none\n\n    character(len=100), dimension(:), allocatable :: operations\n    integer :: n_ops\n    integer :: i\n    integer :: result\n\n    call get_args(operations)\n    n_ops = size(operations)\n\n    do i = 1, n_ops\n        select case (operations(i))\n            case (\"C\")\n                ! Invalidates and removes the previous score\n                write (*, \"(A)\") \"Invalidating previous score\"\n            case (\"D\")\n                ! Records a new score that is the double of the previous score\n                write (*, \"(A)\") \"Recording double of previous score\"\n            case (\"+\")\n                ! Records a new score that is the sum of the previous two scores\n                write (*, \"(A)\") \"Recording sum of previous two scores\"\n            case default\n                ! Records a new score\n                read (operations(i), *) result\n                write (*, \"(I6)\") result\n        end select\n    end do\n\ncontains\n\n    subroutine get_args(operations)\n        implicit none\n        character(len=100), dimension(:), allocatable, intent(out) :: operations\n        integer :: argc\n        character(len=100), dimension(:), allocatable :: args\n        integer :: i\n\n        call get_command_argument(0, args)\n        argc = size(args)\n\n        allocate(operations(argc))\n\n        do i = 1, argc\n            operations(i) = args(i)\n        end do\n    end subroutine get_args\n\nend program main",
  "693": "program main\n    implicit none\n\n    integer :: n\n    logical :: result\n\n    ! Example 1\n    n = 5\n    result = alternating_bits(n)\n    write (*, '(A, L1)') 'Example 1: ', result\n\n    ! Example 2\n    n = 7\n    result = alternating_bits(n)\n    write (*, '(A, L1)') 'Example 2: ', result\n\n    ! Example 3\n    n = 11\n    result = alternating_bits(n)\n    write (*, '(A, L1)') 'Example 3: ', result\n\ncontains\n\n    function alternating_bits(n) result(result)\n        implicit none\n        integer, intent(in) :: n\n        logical :: result\n\n        integer :: i, j\n        logical :: bit_diff\n\n        bit_diff = .false.\n        do i = 1, 8\n            j = mod(i-1, 8) + 1\n            if (bit(n, i) /= bit(n, j)) then\n                bit_diff = .true.\n                exit\n            end if\n        end do\n\n        result = bit_diff\n    end function alternating_bits\n\nend program main",
  "696": "program main\n    implicit none\n\n    integer :: i, j, k, n, m, count\n    character(len=1000) :: s\n\n    ! read input\n    read(*,*) s\n\n    ! find the number of non-empty substrings\n    n = len_trim(s)\n    do i = 1, n - 1\n        if (s(i:i+1) == '00' .or. s(i:i+1) == '11') then\n            count = count + 1\n        end if\n    end do\n\n    ! find the number of substrings with all 0's and all 1's\n    m = 0\n    do i = 1, n - 1\n        if (s(i:i+1) == '00' .or. s(i:i+1) == '11') then\n            m = m + 1\n        else\n            exit\n        end if\n    end do\n\n    write(*,*) count, m\n\nend program main",
  "697": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums\n    integer :: i, j, k, l, m, n_subarrays, min_len\n\n    ! Example 1\n    nums(1) = 1\n    nums(2) = 2\n    nums(3) = 2\n    nums(4) = 3\n    nums(5) = 1\n    call solve(nums, n, min_len)\n    write (*, '(A, I0)') 'Example 1: ', min_len\n\n    ! Example 2\n    nums(1) = 1\n    nums(2) = 2\n    nums(3) = 2\n    nums(4) = 3\n    nums(5) = 1\n    nums(6) = 4\n    nums(7) = 2\n    call solve(nums, n, min_len)\n    write (*, '(A, I0)') 'Example 2: ', min_len\n\ncontains\n\n    subroutine solve(nums, n, min_len)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(n), intent(in) :: nums\n        integer, intent(out) :: min_len\n        integer :: i, j, k, l, m, n_subarrays, degree\n        logical :: found\n\n        ! Initialize variables\n        min_len = -1\n        found = .false.\n\n        ! Iterate over all subarrays\n        do i = 1, n\n            do j = i, n\n                ! Calculate degree of current subarray\n                degree = 0\n                do k = i, j\n                    if (nums(k) > degree) then\n                        degree = nums(k)\n                    end if\n                end do\n\n                ! Check if degree matches\n                if (degree == nums(j)) then\n                    ! Check if this is the shortest subarray so far\n                    if (.not. found .or. j - i + 1 < min_len) then\n                        min_len = j - i + 1\n                        found = .true.\n                    end if\n                end if\n            end do\n        end do\n\n    end subroutine solve\n\nend program main",
  "700": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, iostat_end\n    implicit none\n    type(node), pointer :: root\n    integer :: val\n    integer :: stat\n\n    call get_arguments(root, val)\n\n    if (associated(root)) then\n        write (unit=error_unit, fmt='(*(g0))') 'Root: ', root%value\n        write (unit=error_unit, fmt='(*(g0))') 'Val: ', val\n        write (unit=error_unit, fmt='(*(g0))') 'Result: ', find_node(root, val)\n    else\n        write (unit=error_unit, fmt='(*(g0))') 'No result found.'\n    end if\n\ncontains\n\n    function find_node(root, val) result(result)\n        class(node), pointer, intent(in) :: root\n        integer, intent(in) :: val\n        class(node), pointer :: result\n\n        if (.not. associated(root)) then\n            nullify(result)\n            return\n        end if\n\n        if (root%value == val) then\n            result => root\n        else if (val < root%value) then\n            result => find_node(root%left, val)\n        else\n            result => find_node(root%right, val)\n        end if\n    end function find_node\n\n    subroutine get_arguments(root, val)\n        type(node), pointer :: root\n        integer, intent(out) :: val\n        character(len=:), allocatable :: line\n        integer :: ios\n\n        read (unit=input_unit, fmt='(A)', iostat=ios) line\n        if (ios /= 0) then\n            if (ios /= iostat_end) then\n                write (unit=error_unit, fmt='(*(g0))') 'Error reading input.'\n                stop 1\n            end if\n            return\n        end if\n\n        allocate (character(len=len(line)) :: line)\n        line = adjustl(line)\n        read (unit=line, fmt=*, iostat=ios) root, val\n        if (ios /= 0) then\n            write (unit=error_unit, fmt='(*(g0))') 'Error parsing input.'\n            stop 1\n        end if\n    end subroutine get_arguments\n\n    type, public :: node\n        integer :: value\n        class(node), pointer :: left => null(), right => null()\n    end type node\n\nend program main",
  "703": "program main\n    use :: kth_largest_mod\n    implicit none\n\n    type(kth_largest) :: kth_largest\n    integer :: i, j, k, n\n    integer, allocatable :: nums(:)\n\n    ! Example 1\n    print *, 'Example 1:'\n    k = 3\n    allocate(nums(3))\n    nums = [4, 5, 8, 2]\n    call kth_largest%init(k, nums)\n    do i = 1, size(nums)\n        print *, kth_largest%add(nums(i))\n    end do\n    deallocate(nums)\n\ncontains\n\nsubroutine test()\n    use :: kth_largest_mod\n    implicit none\n\n    type(kth_largest) :: kth_largest\n    integer :: i, j, k, n\n    integer, allocatable :: nums(:)\n\n    ! Example 1\n    print *, 'Example 1:'\n    k = 3\n    allocate(nums(3))\n    nums = [4, 5, 8, 2]\n    call kth_largest%init(k, nums)\n    do i = 1, size(nums)\n        print *, kth_largest%add(nums(i))\n    end do\n    deallocate(nums)\nend subroutine test\n\nend program main\n\nmodule kth_largest_mod\n    implicit none\n\n    private\n    public :: kth_largest\n\n    type :: kth_largest\n        private\n        integer :: k\n        integer, allocatable :: heap(:)\n        integer :: heap_size\n        logical :: initialized = .false.\n    contains\n        procedure :: init => init_kth_largest\n        procedure :: add => add_to_kth_largest\n    end type kth_largest\n\n    interface kth_largest\n        module procedure :: init_kth_largest\n    end interface kth_largest\n\ncontains\n\nsubroutine init_kth_largest(this, k, nums)\n    class(kth_largest), intent(out) :: this\n    integer, intent(in) :: k\n    integer, intent(in) :: nums(:)\n\n    if (allocated(this%heap)) then\n        deallocate(this%heap)\n    end if\n\n    this%k = k\n    this%heap_size = 0\n    this%initialized = .true.\n\n    call build_heap(this, nums)\nend subroutine init_kth_largest\n\nsubroutine build_heap(this, nums)\n    class(kth_largest), intent(inout) :: this\n    integer, intent(in) :: nums(:)\n    integer :: i\n\n    do i = 1, size(nums)\n        call add_to_heap(this, nums(i))\n    end do\nend subroutine build_heap\n\nfunction parent(i) result(parent_index)\n    integer, value :: i\n    integer :: parent_index\n\n    parent_index = (i + 1) / 2\nend function parent\n\nfunction left(i) result(left_index)\n    integer, value :: i\n    integer :: left_index\n\n    left_index = 2 * i\nend function left\n\nfunction right(i) result(right_index)\n    integer, value :: i\n    integer :: right_index\n\n    right_index = 2 * i + 1\nend function right\n\nsubroutine swap(this, i, j)\n    class(kth_largest), intent(inout) :: this\n    integer, value :: i, j\n\n    integer :: temp\n\n    temp = this%heap(i)\n    this%heap(i) = this%heap(j)\n    this%heap(j) = temp\nend subroutine swap\n\nsubroutine sift_down(this, i)\n    class(kth_largest), intent(inout) :: this\n    integer, value :: i\n\n    integer :: largest\n\n    largest = i\n    if (left(i) <= this%heap_size .and. &",
  "704": "program main\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: nums = [-1, 0, 3, 5, 9, 12]\n    integer :: target\n    integer :: result\n\n    ! Example 1\n    target = 9\n    result = search(nums, target)\n    print '(A, I0)', 'Example 1: ', result\n\n    ! Example 2\n    target = 2\n    result = search(nums, target)\n    print '(A, I0)', 'Example 2: ', result\n\ncontains\n\n    function search(nums, target) result(index)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, intent(in) :: target\n        integer :: index\n\n        index = binary_search(nums, target, 1, size(nums))\n    end function search\n\n    recursive function binary_search(nums, target, left, right) result(index)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, intent(in) :: target\n        integer, value :: left, right\n        integer :: mid\n\n        if (left > right) then\n            index = -1\n            return\n        end if\n\n        mid = (left + right) / 2\n\n        if (nums(mid) == target) then\n            index = mid\n        else if (nums(mid) < target) then\n            index = binary_search(nums, target, mid + 1, right)\n        else\n            index = binary_search(nums, target, left, mid - 1)\n        end if\n    end function binary_search\nend program main",
  "705": "program main\n    use hashset_mod\n    implicit none\n\n    type(MyHashSet) :: myHashSet\n\n    call myHashSet%add(1)\n    call myHashSet%add(2)\n    print '(L1)', myHashSet%contains(1) ! true\n    print '(L1)', myHashSet%contains(3) ! false\n    call myHashSet%add(2)\n    print '(L1)', myHashSet%contains(2) ! true\n    call myHashSet%remove(2)\n    print '(L1)', myHashSet%contains(2) ! false\n\nend program main\n\nmodule hashset_mod\n    implicit none\n\n    private\n    public :: MyHashSet\n\n    type :: MyHashSet\n        integer, allocatable :: keys(:)\n    contains\n        procedure :: add => add_impl\n        procedure :: contains => contains_impl\n        procedure :: remove => remove_impl\n    end type MyHashSet\n\ncontains\n\n    subroutine add_impl(this, key)\n        class(MyHashSet), intent(inout) :: this\n        integer, intent(in) :: key\n\n        if (.not. allocated(this%keys)) then\n            allocate(this%keys(1))\n            this%keys(1) = key\n        else\n            allocate(this%keys(size(this%keys)+1))\n            this%keys(1:size(this%keys)-1) = this%keys(1:size(this%keys)-1)\n            this%keys(size(this%keys)) = key\n        end if\n    end subroutine add_impl\n\n    logical function contains_impl(this, key) result(res)\n        class(MyHashSet), intent(in) :: this\n        integer, intent(in) :: key\n\n        res = any(this%keys == key)\n    end function contains_impl\n\n    subroutine remove_impl(this, key)\n        class(MyHashSet), intent(inout) :: this\n        integer, intent(in) :: key\n\n        integer :: i\n\n        do i=1, size(this%keys)\n            if (this%keys(i) == key) exit\n        end do\n\n        if (i <= size(this%keys)) then\n            this%keys(i:size(this%keys)-1) = this%keys(i+1:size(this%keys))\n            deallocate(this%keys)\n        end if\n    end subroutine remove_impl\n\nend module hashset_mod",
  "706": "program main\n\n! This program solves the problem of implementing a HashMap without using any\n! built-in hash table libraries.\n\nimplicit none\n\ntype :: MyHashMap\n  private\n  type(hash_map), allocatable :: map(:)\ncontains\n  procedure :: put\n  procedure :: get\n  procedure :: remove\nend type MyHashMap\n\ninterface\n  subroutine put(this, key, value)\n    import :: MyHashMap\n    class(MyHashMap), intent(inout) :: this\n    integer, intent(in) :: key\n    integer, intent(in) :: value\n  end subroutine put\n\n  function get(this, key) result(value)\n    import :: MyHashMap\n    class(MyHashMap), intent(in) :: this\n    integer, intent(in) :: key\n    integer :: value\n  end function get\n\n  subroutine remove(this, key)\n    import :: MyHashMap\n    class(MyHashMap), intent(inout) :: this\n    integer, intent(in) :: key\n  end subroutine remove\nend interface\n\ntype(MyHashMap), target :: my_hash_map\ninteger :: i, j, n, key, value\ncharacter(len=100) :: input_string\nlogical :: success\n\n! Read the number of test cases\nread(*,*) n\n\ndo i = 1, n\n  ! Read the input string\n  read(*,'(A)') input_string\n\n  select case (input_string)\n  case (\"MyHashMap\")\n    allocate(my_hash_map%map(0))\n  case (\"put\")\n    read(*,*) key, value\n    call my_hash_map%put(key, value)\n  case (\"get\")\n    read(*,*) key\n    write(*,*) my_hash_map%get(key)\n  case (\"remove\")\n    read(*,*) key\n    call my_hash_map%remove(key)\n  end select\nend do\n\ncontains\n\nsubroutine put(this, key, value)\n  class(MyHashMap), intent(inout) :: this\n  integer, intent(in) :: key\n  integer, intent(in) :: value\n  integer :: index\n\n  ! Find the index where the key should be inserted\n  index = find_index(this%map, key)\n\n  ! Insert the key-value pair at the appropriate position\n  if (index == 0) then\n    allocate(this%map(size(this%map)+1))\n    this%map(size(this%map))%key = key\n    this%map(size(this%map))%value = value\n  else\n    this%map(index)%value = value\n  end if\nend subroutine put\n\nfunction get(this, key) result(value)\n  class(MyHashMap), intent(in) :: this\n  integer, intent(in) :: key\n  integer :: value\n  integer :: index\n\n  ! Find the index where the key is located\n  index = find_index(this%map, key)\n\n  ! Return the value associated with the key\n  if (index /= 0) then\n    value = this%map(index)%value\n  else\n    value = -1\n  end if\nend function get\n\nsubroutine remove(this, key)\n  class(MyHashMap), intent(inout) :: this\n  integer, intent(in) :: key\n  integer :: index\n\n  ! Find the index where the key is located\n  index = find_index(this%map, key)\n\n  ! Remove the key-value pair from the map\n  if (index /= 0) then\n    deallocate(this%map(index)%key)\n    deallocate(this%map(index)%value)\n    this%map(index) = this%map(size(this%map))\n    deallocate(this%map(size(this%map)))\n  end if\nend subroutine remove\n\nrecursive function find_index(map, key) result(index)\n  type(hash_map), intent(in) :: map(:)\n  integer, intent(in) :: key\n  integer :: index\n\n  ! Base case: the key is not found\n  if (.not. allocated(map)) then\n    index = 0\n    return\n  end if\n\n  ! Recursive case: compare the key with the current element\n  if (",
  "709": "program main\n    implicit none\n\n    character(len=100) :: s\n\n    s = \"Hello \"\n    call solve(s)\n    write (*,*) s\n\n    s = \"here \"\n    call solve(s)\n    write (*,*) s\n\n    s = \"LOVELY \"\n    call solve(s)\n    write (*,*) s\n\ncontains\n\n    subroutine solve(s)\n        implicit none\n        character(len=*), intent(inout) :: s\n\n        integer :: i\n\n        do i = 1, len_trim(s)\n            if (s(i:i) >= 'A' .and. s(i:i) <= 'Z') then\n                s(i:i) = char(iachar(s(i:i)) + 32)\n            end if\n        end do\n    end subroutine solve\nend program main",
  "717": "program main\n    implicit none\n\n    integer :: i, n\n    logical :: ans\n    character(len=100) :: input_string\n\n    ! Example 1\n    write(*,*) \"Example 1\"\n    input_string = \"[1,0,0]\"\n    read(input_string, *) n, (ans, i=1,n)\n    call solve(n, ans)\n\n    ! Example 2\n    write(*,*) \"Example 2\"\n    input_string = \"[1,1,1,0]\"\n    read(input_string, *) n, (ans, i=1,n)\n    call solve(n, ans)\n\ncontains\n\nsubroutine solve(n, ans)\n    implicit none\n    integer, intent(in) :: n\n    logical, intent(out) :: ans\n\n    integer :: i\n    logical :: last_is_one\n\n    last_is_one = .false.\n    do i = 1, n - 1\n        if (ans(i)) then\n            last_is_one = .not. last_is_one\n        end if\n    end do\n\n    if (last_is_one) then\n        ans = .true.\n    else\n        ans = .false.\n    end if\nend subroutine solve\n\nend program main",
  "724": "program main\n    ! Solves the problem of finding the pivot index of an array of integers\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: nums\n    integer :: i, j, k, l, m, n_left, n_right, pivot_index\n    logical :: found\n\n    ! Examples\n    nums = [1, 7, 3, 6, 5, 6]\n    write (*, '(A, I0)') 'Example 1: ', find_pivot_index(nums)\n\n    nums = [1, 2, 3]\n    write (*, '(A, I0)') 'Example 2: ', find_pivot_index(nums)\n\n    nums = [2, 1, -1]\n    write (*, '(A, I0)') 'Example 3: ', find_pivot_index(nums)\n\ncontains\n\n    function find_pivot_index(nums) result(pivot_index)\n        ! Calculates the pivot index of an array of integers\n        implicit none\n\n        integer, intent(in) :: nums(:)\n        integer :: pivot_index\n        integer :: i, n_left, n_right\n\n        n_left = 0\n        n_right = sum(nums)\n\n        do i = 1, size(nums)\n            if (n_left == n_right) then\n                pivot_index = i - 1\n                exit\n            end if\n\n            if (i > 1) then\n                n_left = n_left + nums(i - 1)\n            end if\n\n            if (i < size(nums)) then\n                n_right = n_right - nums(i)\n            end if\n        end do\n\n        if (.not. allocated(pivot_index)) then\n            pivot_index = -1\n        end if\n\n    end function find_pivot_index\n\nend program main",
  "728": "program main\n    implicit none\n\n    integer :: i, j, n, left, right\n    logical :: is_self_dividing\n\n    ! read input\n    read(*,*) left, right\n\n    ! solve problem\n    do i = left, right\n        is_self_dividing = .true.\n        do while (i > 0)\n            n = mod(i, 10)\n            if (n == 0) then\n                is_self_dividing = .false.\n                exit\n            end if\n            if (mod(i, n) /= 0) then\n                is_self_dividing = .false.\n                exit\n            end if\n            i = i / 10\n        end do\n        if (is_self_dividing) then\n            write (*,'(I0)') i\n        end if\n    end do\n\nend program main",
  "733": "program main\n    implicit none\n\n    integer, parameter :: m = 3, n = 3\n    integer, dimension(m, n) :: image\n    integer :: sr, sc, color\n\n    ! Example 1\n    image = reshape([1, 1, 1, &\n                      1, 1, 0, &\n                      1, 0, 1], shape(image))\n    sr = 1; sc = 1; color = 2\n    call flood_fill(image, sr, sc, color)\n    write(*, '(A)') 'Example 1:'\n    write(*, '(A)') 'Before:'\n    call print_image(image)\n    write(*, '(A)') 'After:'\n    call print_image(image)\n    write(*, *)\n\n    ! Example 2\n    image = reshape([0, 0, 0, &\n                      0, 0, 0], shape(image))\n    sr = 0; sc = 0; color = 0\n    call flood_fill(image, sr, sc, color)\n    write(*, '(A)') 'Example 2:'\n    write(*, '(A)') 'Before:'\n    call print_image(image)\n    write(*, '(A)') 'After:'\n    call print_image(image)\n    write(*, *)\n\ncontains\n\n    subroutine flood_fill(image, sr, sc, color)\n        implicit none\n        integer, intent(inout) :: image(:, :)\n        integer, intent(in) :: sr, sc, color\n        integer :: i, j\n\n        if (image(sr, sc) /= color) then\n            return\n        end if\n\n        do i = 1, size(image, 1)\n            do j = 1, size(image, 2)\n                if (image(i, j) == color) then\n                    image(i, j) = color\n                end if\n            end do\n        end do\n\n        do i = 1, size(image, 1) - 1\n            do j = 1, size(image, 2) - 1\n                if (image(i, j) == color .and. &\n                    image(i + 1, j) == color .and. &\n                    image(i, j + 1) == color .and. &\n                    image(i + 1, j + 1) == color) then\n                    call flood_fill(image, i, j, color)\n                end if\n            end do\n        end do\n\n    end subroutine flood_fill\n\n    subroutine print_image(image)\n        implicit none\n        integer, intent(in) :: image(:, :)\n        integer :: i, j\n\n        do i = 1, size(image, 1)\n            do j = 1, size(image, 2)\n                write(*, '(I0)', advance='no') image(i, j)\n            end do\n            write(*, *)\n        end do\n\n    end subroutine print_image\n\nend program main",
  "734": "program main\n    implicit none\n\n    integer :: i, j, n, m\n    character(len=20), allocatable :: arr(:)\n    character(len=20), allocatable :: sentence1(:), sentence2(:)\n    character(len=20), allocatable :: xi(:), yi(:)\n    logical :: result\n\n    ! Examples\n    n = 5\n    allocate(arr(n))\n    arr = [\"I \", \"am \", \"happy \", \"with \", \"leetcode \"]\n    call print_array(arr)\n\n    n = 4\n    allocate(sentence1(n))\n    sentence1 = [\"great \", \"acting \", \"skills \"]\n    allocate(sentence2(n))\n    sentence2 = [\"fine \", \"drama \", \"talent \"]\n    allocate(xi(2))\n    allocate(yi(2))\n    xi = [\"great \", \"drama \"]\n    yi = [\"fine \", \"acting \"]\n    result = are_sentences_similar(sentence1, sentence2, xi, yi)\n    write (*, '(A, L1)') \"Example 1:\", result\n\n    n = 1\n    allocate(sentence1(n))\n    sentence1 = [\"great \"]\n    allocate(sentence2(n))\n    sentence2 = [\"great \"]\n    allocate(xi(0))\n    allocate(yi(0))\n    result = are_sentences_similar(sentence1, sentence2, xi, yi)\n    write (*, '(A, L1)') \"Example 2:\", result\n\n    n = 1\n    allocate(sentence1(n))\n    sentence1 = [\"great \"]\n    allocate(sentence2(n))\n    sentence2 = [\"doubleplus \", \"good \"]\n    allocate(xi(1))\n    allocate(yi(1))\n    xi = [\"great \"]\n    yi = [\"doubleplus \"]\n    result = are_sentences_similar(sentence1, sentence2, xi, yi)\n    write (*, '(A, L1)') \"Example 3:\", result\n\ncontains\n\n    subroutine print_array(arr)\n        implicit none\n        character(len=20), intent(in) :: arr(:)\n        do i = 1, size(arr)\n            write (*, '(A)', advance='no') trim(arr(i)) // \" \"\n        end do\n        write (*, *) \"\"\n    end subroutine print_array\n\nend program main\n\nfunction are_sentences_similar(sentence1, sentence2, similarPairs) result(result)\n    implicit none\n    character(len=20), intent(in) :: sentence1(:), sentence2(:)\n    character(len=20), intent(in) :: similarPairs(:, :)\n    logical :: result\n    integer :: i, j, k, l\n\n    ! Check if both sentences have the same length\n    if (size(sentence1) /= size(sentence2)) then\n        result = .false.\n        return\n    end if\n\n    ! Check if each word in sentence1 is similar to the corresponding word in sentence2\n    do i = 1, size(sentence1)\n        do j = 1, size(similarPairs, dim=1)\n            if (sentence1(i) == similarPairs(j, 1) .and. &\n                sentence2(i) == similarPairs(j, 2)) then\n                exit\n            end if\n        end do\n        if (j > size(similarPairs, dim=1)) then\n            result = .false.\n            return\n        end if\n    end do\n\n    result = .true.\n\nend function are_sentences_similar",
  "744": "program main\n    implicit none\n\n    character(len=1), parameter :: letters(*) = [\"c\", \"f\", \"j\"]\n    character(len=1) :: target = \"a\"\n    character(len=1) :: result\n\n    result = next_larger_letter(letters, target)\n    print *, result\n\ncontains\n\n    function next_larger_letter(letters, target) result(result_)\n        implicit none\n        character(len=1), intent(in) :: letters(:)\n        character(len=1), intent(in) :: target\n        character(len=1) :: result_\n        integer :: i\n\n        do i = 1, size(letters)\n            if (letters(i) > target) then\n                result_ = letters(i)\n                exit\n            end if\n        end do\n\n        if (result_ == \"\") then\n            result_ = letters(1)\n        end if\n    end function next_larger_letter\nend program main",
  "746": "program main\n    implicit none\n\n    integer, parameter :: n = 3 ! number of steps\n    integer, dimension(n) :: cost = (/ 10, 15, 20 /) ! cost of each step\n    integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n    integer :: min_cost\n\n    ! solve the problem\n    min_cost = solve(cost)\n\n    ! print the solution\n    write (*, '(A, I0)') 'Minimum cost: ', min_cost\n\ncontains\n\n    function solve(cost) result(min_cost)\n        implicit none\n        integer, intent(in) :: cost(:)\n        integer :: min_cost\n        integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n\n        min_cost = huge(1_8) ! initialize with a large value\n\n        do i = 1, size(cost) - 1\n            do j = i + 1, size(cost)\n                if (cost(i) + cost(j) < min_cost) then\n                    min_cost = cost(i) + cost(j)\n                end if\n            end do\n        end do\n\n    end function solve\n\nend program main",
  "747": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums\n    integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n\n    ! Example 1\n    nums = [3, 6, 1, 0]\n    print '(I0)', largest_element_at_least_twice(nums)\n\n    ! Example 2\n    nums = [1, 2, 3, 4]\n    print '(I0)', largest_element_at_least_twice(nums)\n\ncontains\n\n    function largest_element_at_least_twice(nums) result(largest_index)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer :: largest_index\n        integer :: i\n\n        largest_index = -1\n        do i = 1, size(nums)\n            if (nums(i) >= 2 * nums(size(nums))) then\n                largest_index = i\n                exit\n            end if\n        end do\n    end function largest_element_at_least_twice\n\nend program main",
  "748": "program main\n    implicit none\n\n    character(len=7) :: licensePlate = \"1s3 PSt \"\n    character(len=15), dimension(4) :: words = [\"step \", \"steps \", \"stripe \", \"stepple \"]\n    character(len=15) :: shortestCompletingWord\n\n    shortestCompletingWord = solve(licensePlate, words)\n\n    print *, shortestCompletingWord\n\ncontains\n\n    function solve(licensePlate, words) result(shortestCompletingWord)\n        implicit none\n        character(len=*), intent(in) :: licensePlate\n        character(len=*), intent(in) :: words(:)\n        integer :: i, j, k, l, m\n        logical :: found\n        character(len=15) :: word\n        character(len=15) :: temp\n        integer, allocatable :: count(:)\n\n        allocate(count(26))\n        count = 0\n\n        ! Ignore numbers and spaces in licensePlate\n        do i = 1, len_trim(licensePlate)\n            if (index('abcdefghijklmnopqrstuvwxyz', licensePlate(i:i)) /= 0) then\n                k = index('abcdefghijklmnopqrstuvwxyz', licensePlate(i:i)) - 1\n                count(k) = count(k) + 1\n            end if\n        end do\n\n        ! Find the shortest completing word\n        shortestCompletingWord = \"\"\n        do i = 1, size(words)\n            word = words(i)\n            found = .true.\n            do j = 1, len_trim(word)\n                if (index('abcdefghijklmnopqrstuvwxyz', word(j:j)) /= 0) then\n                    k = index('abcdefghijklmnopqrstuvwxyz', word(j:j)) - 1\n                    if (count(k) < 1) then\n                        found = .false.\n                        exit\n                    else\n                        count(k) = count(k) - 1\n                    end if\n                end if\n            end do\n            if (found) then\n                if (len_trim(shortestCompletingWord) == 0) then\n                    shortestCompletingWord = word\n                else\n                    temp = word\n                    call sort(temp)\n                    call sort(shortestCompletingWord)\n                    if (temp < shortestCompletingWord) then\n                        shortestCompletingWord = word\n                    end if\n                end if\n            end if\n        end do\n\n        deallocate(count)\n\n    end function solve\n\n    subroutine sort(string)\n        implicit none\n        character(len=*), intent(inout) :: string\n        integer :: i, j\n        character :: temp\n\n        do i = 1, len_trim(string) - 1\n            do j = i + 1, len_trim(string)\n                if (string(i:i) > string(j:j)) then\n                    temp = string(i:i)\n                    string(i:i) = string(j:j)\n                    string(j:j) = temp\n                end if\n            end do\n        end do\n\n    end subroutine sort\n\nend program main",
  "760": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums1 = [12, 28, 46, 32, 50]\n    integer, dimension(n) :: nums2 = [50, 12, 32, 46, 28]\n    integer, dimension(n) :: mapping\n\n    call solve(nums1, nums2, mapping)\n\n    write (*, '(A)') 'Mapping:'\n    write (*, '(*(I0, 1X))') mapping\n\ncontains\n\n    subroutine solve(nums1, nums2, mapping)\n        implicit none\n        integer, intent(in) :: nums1(:), nums2(:)\n        integer, intent(out) :: mapping(:)\n        logical, allocatable :: seen(:)\n        integer :: i, j, k\n\n        allocate (seen(size(nums1)))\n\n        do i = 1, size(nums1)\n            seen(i) = .false.\n        end do\n\n        do i = 1, size(nums1)\n            if (.not. seen(i)) then\n                k = 1\n                do while (k <= size(nums1))\n                    if (nums1(i) == nums2(k)) then\n                        seen(i) = .true.\n                        exit\n                    end if\n                    k = k + 1\n                end do\n            end if\n        end do\n\n        do i = 1, size(nums1)\n            j = 1\n            do while (j <= size(nums1))\n                if (nums1(i) == nums2(j)) then\n                    mapping(i) = j\n                    exit\n                end if\n                j = j + 1\n            end do\n        end do\n\n    end subroutine solve\n\nend program main",
  "762": "program main\n    implicit none\n\n    integer :: left, right, count\n\n    ! Example 1\n    left = 6\n    right = 10\n    count = primeCount(left, right)\n    print '(A, I0)', 'Example 1: ', count\n\n    ! Example 2\n    left = 10\n    right = 15\n    count = primeCount(left, right)\n    print '(A, I0)', 'Example 2: ', count\n\ncontains\n\n    function primeCount(left, right) result(count_)\n        implicit none\n        integer, intent(in) :: left, right\n        integer :: i, j, count_, nsetbits\n\n        count_ = 0\n        do i = left, right\n            nsetbits = 0\n            do j = i, 1, -1\n                if (mod(j, 2) == 1) then\n                    nsetbits = nsetbits + 1\n                end if\n            end do\n            if (isPrime(nsetbits)) then\n                count_ = count_ + 1\n            end if\n        end do\n    end function primeCount\n\n    logical function isPrime(n)\n        implicit none\n        integer, intent(in) :: n\n        integer :: i\n\n        isPrime = .false.\n        if (n == 1) then\n            isPrime = .true.\n        else if (n == 2) then\n            isPrime = .true.\n        else if (n > 2) then\n            do i = 2, int(sqrt(real(n)))\n                if (mod(n, i) == 0) then\n                    exit\n                end if\n            end do\n            if (i >= sqrt(real(n))) then\n                isPrime = .true.\n            end if\n        end if\n    end function isPrime\n\nend program main",
  "766": "program main\n    implicit none\n\n    integer, parameter :: m = 3, n = 4\n    integer, dimension(m, n) :: matrix\n    logical :: result\n\n    ! Example 1\n    matrix(:, :) = reshape([1, 2, 3, 4, &\n                             5, 1, 2, 3, &\n                             9, 5, 1, 2], shape(matrix))\n    write(*, '(L1)') toeplitz(matrix)\n\n    ! Example 2\n    matrix(:, :) = reshape([1, 2, &\n                             2, 2], shape(matrix))\n    write(*, '(L1)') toeplitz(matrix)\n\ncontains\n\n    function toeplitz(matrix) result(result)\n        implicit none\n        integer, intent(in) :: matrix(:, :)\n        logical :: result\n        integer :: i, j\n\n        do i = 1, size(matrix, 1) - 1\n            do j = 1, size(matrix, 2) - 1\n                if (matrix(i, j) /= matrix(i + 1, j + 1)) then\n                    result = .false.\n                    return\n                end if\n            end do\n        end do\n\n        result = .true.\n    end function toeplitz\n\nend program main",
  "771": "program main\n    implicit none\n\n    integer :: i, n_jewels, n_stones\n    character(len=50) :: jewels, stones\n\n    ! Example 1\n    jewels = \"aA\"\n    stones = \"aAAbbbb\"\n    call solve(jewels, stones, n_jewels, n_stones)\n    write(*,\"(A,I0)\") \"Example 1: \", n_jewels\n\n    ! Example 2\n    jewels = \"z\"\n    stones = \"ZZ\"\n    call solve(jewels, stones, n_jewels, n_stones)\n    write(*,\"(A,I0)\") \"Example 2: \", n_jewels\n\ncontains\n\n    subroutine solve(jewels, stones, n_jewels, n_stones)\n        implicit none\n        character(len=*), intent(in) :: jewels, stones\n        integer, intent(out) :: n_jewels, n_stones\n\n        integer :: i, j\n\n        n_jewels = 0\n        n_stones = len(stones)\n\n        do i = 1, len(jewels)\n            do j = 1, len(stones)\n                if (jewels(i:i) == stones(j:j)) then\n                    n_jewels = n_jewels + 1\n                    exit\n                end if\n            end do\n        end do\n\n    end subroutine solve\n\nend program main",
  "783": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 2\n    real(DP), dimension(n) :: x\n    real(DP) :: y\n    integer :: i\n\n    ! Examples\n    x(1) = 4._DP\n    x(2) = 2._DP\n    call test_case(x, 1._DP)\n\n    x(1) = 1._DP\n    x(2) = 48._DP\n    call test_case(x, 1._DP)\n\ncontains\n\n    subroutine test_case(x, expected)\n        real(DP), intent(in) :: x(:)\n        real(DP), intent(in) :: expected\n        real(DP) :: result\n\n        result = min_diff(x)\n        write (unit=error_unit, fmt='(A, F10.3, A, F10.3, A)') &\n            'Test case: ', x, ' -> ', result, ' (expected: ', expected, ')'\n    end subroutine test_case\n\nend program main\n\nfunction min_diff(root) result(res)\n    type(node), pointer, intent(in) :: root\n    real(DP) :: res\n    real(DP) :: diff\n\n    if (.not. associated(root)) then\n        res = -1._DP\n        return\n    end if\n\n    diff = abs(root%val - root%left%val)\n    res = min(res, diff)\n    res = min(res, min_diff(root%left))\n    res = min(res, min_diff(root%right))\nend function min_diff\n\ntype node\n    real(DP) :: val\n    type(node), pointer :: left\n    type(node), pointer :: right\nend type node",
  "796": "program main\n    implicit none\n\n    character(len=100) :: s, goal\n    logical :: can_become\n\n    ! Example 1\n    s = \"abcde\"\n    goal = \"cdeab\"\n    print '(L1)', can_become(s, goal)\n\n    ! Example 2\n    s = \"abcde\"\n    goal = \"abced\"\n    print '(L1)', can_become(s, goal)\n\ncontains\n\n    function can_become(s, goal) result(res)\n        implicit none\n        character(len=*), intent(in) :: s, goal\n        integer :: i, j\n        logical :: res\n\n        res = .false.\n        do while (i < len(s))\n            if (s(i+1:) == goal) then\n                res = .true.\n                exit\n            end if\n            s(1:) = s(2:)\n            s(len_trim(s):) = s(1:)\n            i = i + 1\n        end do\n    end function can_become\nend program main",
  "800": "program main\n    implicit none\n\n    integer :: i, j, k\n    character(len=8) :: color\n    character(len=4) :: shorthand\n    real :: similarity\n    real, parameter :: max_similarity = -1.0e+10\n    real :: best_similarity = max_similarity\n    character(len=8), dimension(16) :: colors\n    data colors / &\n        \"#000000 \", \"#111111 \", \"#222222 \", \"#333333 \", &\n        \"#444444 \", \"#555555 \", \"#666666 \", \"#777777 \", &\n        \"#888888 \", \"#999999 \", \"#aaaaaa \", \"#bbbbbb \", &\n        \"#cccccc \", \"#dddddd \", \"#eeeeee \", \"#ffffff \" /\n\n    do i = 1, size(colors)\n        color = colors(i)\n        do j = 1, size(colors)\n            if (i /= j) then\n                shorthand = shorten_color(color)\n                similarity = similarity_between_colors(color, colors(j))\n                if (similarity > best_similarity) then\n                    best_similarity = similarity\n                    write (*,*) \"Best similarity:\", best_similarity, \"for color:\", color, \"shorthand:\", shorthand\n                end if\n            end if\n        end do\n    end do\n\ncontains\n\n    function shorten_color(color) result(shorthand)\n        implicit none\n        character(len=*), intent(in) :: color\n        character(len=4) :: shorthand\n        integer :: r, g, b\n\n        read (color(2:5), \"(H2, H2, H2)\") r, g, b\n        write (shorthand, \"(I1, I1, I1)\") r, g, b\n    end function shorten_color\n\n    function similarity_between_colors(color1, color2) result(similarity)\n        implicit none\n        character(len=*), intent(in) :: color1, color2\n        integer :: r1, g1, b1, r2, g2, b2\n        real :: similarity\n\n        read (color1(2:5), \"(H2, H2, H2)\") r1, g1, b1\n        read (color2(2:5), \"(H2, H2, H2)\") r2, g2, b2\n        similarity = -((r1 - r2)**2 - (g1 - g2)**2 - (b1 - b2)**2)\n    end function similarity_between_colors\n\nend program main",
  "804": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=12) :: morse_code(26)\n    character(len=12), allocatable :: words(:)\n    integer, allocatable :: transforms(:)\n    integer :: num_transforms\n\n    ! Define the Morse code for each letter of the English alphabet\n    morse_code(1) = '.-'\n    morse_code(2) = '-...'\n    morse_code(3) = '-.-.'\n    morse_code(4) = '-..'\n    morse_code(5) = '.'\n    morse_code(6) = '..-'\n    morse_code(7) = '--.'\n    morse_code(8) = '....'\n    morse_code(9) = '..'\n    morse_code(10) = '.---'\n    morse_code(11) = '-.-'\n    morse_code(12) = '.-..'\n    morse_code(13) = '--'\n    morse_code(14) = '-.'\n    morse_code(15) = '---'\n    morse_code(16) = '.--.'\n    morse_code(17) = '--.-'\n    morse_code(18) = '.-.'\n    morse_code(19) = '...'\n    morse_code(20) = '-'\n    morse_code(21) = '..-'\n    morse_code(22) = '...-'\n    morse_code(23) = '.--'\n    morse_code(24) = '-..-'\n    morse_code(25) = '-.--'\n    morse_code(26) = '--..'\n\n    ! Read in the list of words\n    read(*,*) n\n    allocate(words(n))\n    do i = 1, n\n        read(*,*) words(i)\n    end do\n\n    ! Count the number of distinct transformations\n    allocate(transforms(n))\n    num_transforms = 0\n    do i = 1, n\n        transforms(i) = 0\n        do j = 1, len(words(i))\n            if (index(morse_code(ichar(words(i)(j:j)) - ichar('a') + 1), &\n                      morse_code(ichar(words(i)(j+1:j+1)) - ichar('a') + 1)) /= 0) then\n                transforms(i) = transforms(i) + 1\n            end if\n        end do\n    end do\n\n    ! Print the number of distinct transformations\n    write(*,*) sum(transforms)\n\nend program main",
  "806": "program main\n    implicit none\n\n    integer :: i, j, k, n, m, result(2)\n    character(len=100) :: s\n    integer, dimension(26) :: widths\n\n    ! Example 1\n    widths = (/10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10/)\n    s = 'abcdefghijklmnopqrstuvwxyz '\n    call solve(widths, s, result)\n    print *, result\n\n    ! Example 2\n    widths = (/4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10/)\n    s = 'bbbcccdddaaa '\n    call solve(widths, s, result)\n    print *, result\n\ncontains\n\n    subroutine solve(widths, s, result)\n        implicit none\n        integer, intent(in) :: widths(:), s(:)\n        integer, intent(out) :: result(2)\n        integer :: i, j, k, n, m\n\n        n = size(s)\n        m = size(widths)\n\n        do i = 1, n\n            if (sum(widths(1:i)) > 100) then\n                exit\n            end if\n        end do\n\n        result(1) = i - 1\n\n        do j = i, n\n            if (sum(widths(j-i+1:m)) > 100) then\n                exit\n            end if\n        end do\n\n        result(2) = sum(widths(j-i+1:m))\n\n    end subroutine solve\n\nend program main",
  "812": "program main\n    ! Solves the problem:\n    ! Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points.\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 50\n    real(kind=DP), dimension(n) :: points\n    real(kind=DP) :: area\n    integer :: i, j, k\n\n    call get_points(points)\n\n    do i = 1, size(points)-2\n        do j = i+1, size(points)-1\n            do k = j+1, size(points)\n                area = triangle_area(points(i), points(j), points(k))\n                write (unit=error_unit, fmt='(A,F10.5)') 'Area: ', area\n            end do\n        end do\n    end do\n\ncontains\n\n    subroutine get_points(points)\n        ! Reads the input points from stdin and stores them in the array points\n        implicit none\n        real(kind=DP), dimension(:), intent(out) :: points\n        integer :: i, n\n        character(len=100) :: line\n\n        read (unit=input_unit, fmt='(I10)') n\n        if (n > size(points)) then\n            write (unit=error_unit, fmt='(A)') 'Too many points'\n            stop 1\n        end if\n\n        do i = 1, n\n            read (unit=input_unit, fmt='(A)') line\n            read (unit=line, fmt='(2(I10,1X))') points(i), points(i+n)\n        end do\n    end subroutine get_points\n\n    function triangle_area(a, b, c) result(area)\n        ! Returns the area of the triangle formed by the points a, b and c\n        implicit none\n        real(kind=DP), value :: a(2), b(2), c(2)\n        real(kind=DP) :: area\n\n        area = abs((a(1)*b(2)+b(1)*c(2)+c(1)*a(2)-a(2)*b(1)-b(2)*c(1)-c(2)*a(1)) / 2.0D0)\n    end function triangle_area\n\nend program main",
  "819": "program main\n    implicit none\n\n    character(len=:), allocatable :: paragraph\n    character(len=:), allocatable :: banned(:)\n    integer :: i, j, count, max_count\n    character(len=:), allocatable :: most_frequent_word\n\n    ! Examples\n    paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit. \"\n    banned = [\"hit\"]\n    call solve(paragraph, banned, most_frequent_word)\n    print *, most_frequent_word\n\n    paragraph = \"a. \"\n    banned = []\n    call solve(paragraph, banned, most_frequent_word)\n    print *, most_frequent_word\n\ncontains\n\n    subroutine solve(paragraph, banned, most_frequent_word)\n        implicit none\n        character(len=*), intent(in) :: paragraph\n        character(len=*), intent(in) :: banned(:)\n        character(len=:), allocatable, intent(out) :: most_frequent_word\n        logical :: is_banned\n        integer :: i, j, count, max_count\n\n        ! Initialize variables\n        max_count = 0\n        most_frequent_word = \"\"\n\n        ! Loop through each word in the paragraph\n        do i = 1, len_trim(paragraph)\n            ! Check if current word is banned\n            is_banned = .false.\n            do j = 1, size(banned)\n                if (trim(adjustl(banned(j))) == trim(adjustl(paragraph(i:)))) then\n                    is_banned = .true.\n                    exit\n                end if\n            end do\n\n            ! If current word is not banned, increment its frequency\n            if (.not. is_banned) then\n                count = count + 1\n            end if\n\n            ! Update maximum frequency\n            if (count > max_count) then\n                max_count = count\n                most_frequent_word = trim(adjustl(paragraph(i:)))\n            end if\n        end do\n\n        ! Convert most_frequent_word to lowercase\n        most_frequent_word = trim(adjustl(most_frequent_word)) // \" \"\n        most_frequent_word = tolower(most_frequent_word)\n\n    end subroutine solve\n\nend program main",
  "821": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=:), allocatable :: s\n    character :: c\n    integer, dimension(:), allocatable :: answer\n\n    ! read input\n    read(*,*) s\n    read(*,*) c\n\n    ! compute answer\n    n = len(s)\n    allocate(answer(n))\n    do i = 1, n\n        j = index(s(i:), c)\n        if (j /= 0) then\n            answer(i) = abs(i - j)\n        else\n            answer(i) = 0\n        end if\n    end do\n\n    ! print answer\n    write(*,*) answer\n\nend program main",
  "824": "program main\n    implicit none\n\n    character(len=:), allocatable :: sentence\n    integer :: i\n\n    ! Example 1\n    sentence = \"I speak Goat Latin\"\n    print '(A)', goat_latin(sentence)\n\n    ! Example 2\n    sentence = \"The quick brown fox jumped over the lazy dog\"\n    print '(A)', goat_latin(sentence)\n\ncontains\n\n    function goat_latin(sentence) result(result_sentence)\n        implicit none\n        character(len=*), intent(in) :: sentence\n        character(len=:), allocatable :: result_sentence\n        logical :: is_vowel\n        integer :: i\n\n        allocate(character(len=len(sentence)+3) :: result_sentence)\n\n        do i = 1, size(sentence)\n            is_vowel = any(sentence(i:i) == ['a', 'e', 'i', 'o', 'u'])\n            if (is_vowel) then\n                result_sentence = trim(result_sentence) // sentence(i:i) // \"ma \"\n            else\n                result_sentence = trim(result_sentence) // sentence(i+1:) // sentence(i:i) // \"ma \"\n            end if\n            if (i < size(sentence)) then\n                result_sentence = trim(result_sentence) // \"a \"\n            end if\n        end do\n    end function goat_latin\nend program main",
  "830": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=1000) :: s\n    integer, allocatable :: starts(:), ends(:)\n\n    do i = 1, size(examples)\n        write (*, '(A)') 'Example ', i\n        s = examples(i)\n        call solve(s, starts, ends)\n        n = size(starts)\n        write (*, '(A, I0)') 'Number of large groups: ', n\n        do j = 1, n\n            write (*, '(A, I0, A, I0)') 'Large group ', j, ': ', starts(j), '-', ends(j)\n        end do\n        write (*, *)\n    end do\n\ncontains\n\n    subroutine solve(s, starts, ends)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer, allocatable, intent(out) :: starts(:), ends(:)\n        integer :: i, j, k, n\n        logical :: found_large\n\n        ! Initialize arrays\n        allocate(starts(0))\n        allocate(ends(0))\n\n        ! Loop over characters in the string\n        do i = 1, len(s)\n            ! Check if current character is part of a large group\n            found_large = .false.\n            do j = 1, size(starts)\n                if (s(i:i) == s(starts(j):starts(j))) then\n                    found_large = .true.\n                    exit\n                end if\n            end do\n\n            ! If current character is part of a large group, update the end index\n            if (found_large) then\n                k = size(ends)\n                ends(k+1) = i\n            end if\n\n            ! If current character is not part of any large group, create a new one\n            if (.not. found_large) then\n                n = size(starts) + 1\n                allocate(starts(n))\n                allocate(ends(n))\n                starts(n) = i\n                ends(n) = i\n            end if\n        end do\n\n        ! Sort the large groups by start index\n        call sort(starts, ends)\n    end subroutine solve\n\n    function sort(starts, ends) result(sorted)\n        implicit none\n        integer, intent(in) :: starts(:), ends(:)\n        integer, allocatable :: sorted(:, :)\n        integer :: i, j, k, m\n\n        ! Allocate temporary arrays\n        allocate(sorted(size(starts), 2))\n\n        ! Copy the input arrays into the temporary arrays\n        do i = 1, size(starts)\n            sorted(i, 1) = starts(i)\n            sorted(i, 2) = ends(i)\n        end do\n\n        ! Bubble sort the temporary arrays\n        do while (any(sorted(:, 1) /= starts))\n            do i = 1, size(starts)-1\n                if (sorted(i, 1) > sorted(i+1, 1)) then\n                    m = sorted(i, 1)\n                    sorted(i, 1) = sorted(i+1, 1)\n                    sorted(i+1, 1) = m\n                    m = sorted(i, 2)\n                    sorted(i, 2) = sorted(i+1, 2)\n                    sorted(i+1, 2) = m\n                end if\n            end do\n        end do\n\n        ! Copy the sorted arrays back into the output arrays\n        do i = 1, size(starts)\n            starts(i) = sorted(i, 1)\n            ends(i) = sorted(i, 2)\n        end do\n    end function sort\n\n    character(len=1000), parameter :: examples(3) = [\"abbxxxxzzy \", &\n                                                      \"abc \", &\n                                                      \"abcdddeeeeaabbbcd \"]\n\nend program main",
  "832": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer :: i, j\n    logical :: image(n, n)\n\n    ! Example 1\n    image(:, :) = .false.\n    image(1, :) = .true.\n    image(2, :) = .true.\n    image(3, :) = .false.\n    call print_result(image)\n\n    ! Example 2\n    image(:, :) = .false.\n    image(1, :) = .true.\n    image(2, :) = .false.\n    image(3, :) = .true.\n    call print_result(image)\n\ncontains\n\n    subroutine print_result(image)\n        implicit none\n        logical, intent(in) :: image(n, n)\n        character(len=n) :: line\n\n        do i = 1, n\n            write (line, '(*(L1))') image(i, :)\n            print *, trim(adjustl(line))\n        end do\n    end subroutine print_result\nend program main",
  "836": "program main\n    implicit none\n\n    integer :: i, j, k\n    logical :: overlap\n    real, dimension(4) :: rec1, rec2\n\n    ! Example 1:\n    rec1 = [0, 0, 2, 2]\n    rec2 = [1, 1, 3, 3]\n    overlap = overlap_rectangles(rec1, rec2)\n    print '(L1)', overlap\n\n    ! Example 2:\n    rec1 = [0, 0, 1, 1]\n    rec2 = [1, 0, 2, 1]\n    overlap = overlap_rectangles(rec1, rec2)\n    print '(L1)', overlap\n\n    ! Example 3:\n    rec1 = [0, 0, 1, 1]\n    rec2 = [2, 2, 3, 3]\n    overlap = overlap_rectangles(rec1, rec2)\n    print '(L1)', overlap\n\ncontains\n\n    function overlap_rectangles(rec1, rec2) result(overlap)\n        implicit none\n        real, intent(in) :: rec1(4), rec2(4)\n        logical :: overlap\n        real :: xmin1, xmax1, ymin1, ymax1, xmin2, xmax2, ymin2, ymax2\n\n        xmin1 = min(rec1(1), rec1(3))\n        xmax1 = max(rec1(1), rec1(3))\n        ymin1 = min(rec1(2), rec1(4))\n        ymax1 = max(rec1(2), rec1(4))\n        xmin2 = min(rec2(1), rec2(3))\n        xmax2 = max(rec2(1), rec2(3))\n        ymin2 = min(rec2(2), rec2(4))\n        ymax2 = max(rec2(2), rec2(4))\n\n        overlap = (xmin1 < xmax2 .and. xmax1 > xmin2 .and. &\n                   ymin1 < ymax2 .and. ymax1 > ymin2)\n    end function overlap_rectangles\nend program main",
  "844": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=200) :: s, t\n    logical :: result\n\n    ! Example 1: ab#c , ad#c\n    s = 'ab#c '\n    t = 'ad#c '\n    result = is_equal_after_backspace(s, t)\n    print '(L1)', result\n\n    ! Example 2: ab## , c#d#\n    s = 'ab## '\n    t = 'c#d# '\n    result = is_equal_after_backspace(s, t)\n    print '(L1)', result\n\n    ! Example 3: a#c , b\n    s = 'a#c '\n    t = 'b'\n    result = is_equal_after_backspace(s, t)\n    print '(L1)', result\n\ncontains\n\n    function is_equal_after_backspace(s, t) result(res)\n        implicit none\n        character(len=*), intent(in) :: s, t\n        logical :: res\n        integer :: i, j\n\n        res = .false.\n        if (len(s) /= len(t)) return\n\n        i = 1\n        j = 1\n        do while (i <= len(s))\n            if (s(i:i) == '#') then\n                i = i + 1\n            else if (t(j:j) == '#') then\n                j = j + 1\n            else if (s(i:i) /= t(j:j)) then\n                return\n            end if\n            i = i + 1\n            j = j + 1\n        end do\n\n        res = .true.\n    end function is_equal_after_backspace\n\nend program main",
  "859": "program main\n    implicit none\n\n    character(len=:), allocatable :: s, goal\n    logical :: res\n\n    ! Example 1\n    s = \"ab \"\n    goal = \"ba \"\n    res = solve(s, goal)\n    print \"(L1)\", res\n\n    ! Example 2\n    s = \"ab \"\n    goal = \"ab \"\n    res = solve(s, goal)\n    print \"(L1)\", res\n\n    ! Example 3\n    s = \"aa \"\n    goal = \"aa \"\n    res = solve(s, goal)\n    print \"(L1)\", res\n\ncontains\n\n    function solve(s, goal) result(res)\n        implicit none\n        character(len=*), intent(in) :: s, goal\n        integer :: i, j\n        logical :: found\n\n        res = .false.\n        do i = 1, len(s)-1\n            do j = i+1, len(s)\n                if (s(i:i) /= s(j:j)) then\n                    if (s(i:i) == goal(j:j)) then\n                        res = .true.\n                        exit\n                    else if (s(j:j) == goal(i:i)) then\n                        res = .true.\n                        exit\n                    end if\n                end if\n            end do\n            if (res) exit\n        end do\n    end function solve\nend program main",
  "860": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: bills\n    logical :: result\n\n    bills = [5, 5, 5, 10, 20]\n    result = lemonade(bills)\n    write (*, '(L1)') result\n\n    bills = [5, 5, 10, 10, 20]\n    result = lemonade(bills)\n    write (*, '(L1)') result\n\ncontains\n\n    function lemonade(bills) result(result)\n        implicit none\n        integer, intent(in) :: bills(:)\n        logical :: result\n\n        integer :: i, j, k, l, m, n, o\n        integer :: total\n\n        result = .true.\n\n        ! Initialize variables\n        total = 0\n        i = 1\n        j = 1\n        k = 1\n        l = 1\n        m = 1\n        n = 1\n        o = 1\n\n        ! Loop through the bills\n        do while (i <= ubound(bills, 1))\n            select case (bills(i))\n                case (5)\n                    total = total + 5\n                    i = i + 1\n                case (10)\n                    if (total >= 5) then\n                        total = total - 5\n                        i = i + 1\n                    else\n                        result = .false.\n                        exit\n                    end if\n                case (20)\n                    if (total >= 10) then\n                        total = total - 10\n                        i = i + 1\n                    else\n                        result = .false.\n                        exit\n                    end if\n            end select\n        end do\n\n        ! Check if there is enough money for the change\n        if (total /= 0) then\n            result = .false.\n        end if\n\n    end function lemonade\nend program main",
  "867": "program main\n    implicit none\n\n    integer :: matrix(3, 3)\n\n    matrix(:, :) = reshape([1, 2, 3, 4, 5, 6, 7, 8, 9], shape(matrix))\n\n    write(*, '(A)') 'Example 1:'\n    call print_matrix(transpose(matrix))\n\n    matrix(:, :) = reshape([1, 2, 3, 4, 5, 6], shape(matrix))\n\n    write(*, '(A)') 'Example 2:'\n    call print_matrix(transpose(matrix))\n\ncontains\n\n    subroutine print_matrix(matrix)\n        implicit none\n        integer, intent(in) :: matrix(:, :)\n        integer :: i, j\n\n        do i = 1, size(matrix, 1)\n            write(*, '(*(I2, 1X))') (matrix(i, j), j=1, size(matrix, 2))\n        end do\n    end subroutine print_matrix\n\nend program main",
  "868": "program longest_ones_distance\n    implicit none\n\n    integer :: n, i, j, dist, max_dist\n    logical :: found\n    character(len=64) :: bin_str\n\n    do while (.true.)\n        read(*,*) n\n        if (n == -1) exit\n\n        write(bin_str, '(Z0)') n\n        max_dist = 0\n        found = .false.\n        do i = 1, len(trim(bin_str))-1\n            if (bin_str(i:i+1) == '11') then\n                found = .true.\n                dist = abs(i - (i + 1))\n                if (dist > max_dist) then\n                    max_dist = dist\n                end if\n            end if\n        end do\n\n        if (found) then\n            print *, max_dist\n        else\n            print *, 0\n        end if\n    end do\nend program longest_ones_distance",
  "872": "program main\n    implicit none\n\n    type :: TreeNode\n        integer :: val\n        type(TreeNode), pointer :: left => null(), right => null()\n    end type TreeNode\n\n    type (TreeNode), target :: root1, root2\n    logical :: result\n\n    call init_tree(root1)\n    call init_tree(root2)\n\n    result = leafSimilar(root1, root2)\n\n    print '(L1)', result\n\ncontains\n\n    subroutine init_tree(root)\n        type (TreeNode), intent(out) :: root\n\n        allocate(root%left)\n        allocate(root%right)\n        root%val = 3\n        root%left%val = 5\n        root%right%val = 1\n        root%left%left%val = 6\n        root%right%left%val = 2\n        root%right%right%val = 9\n        root%right%left%left%val = 8\n        root%right%left%right%val = 7\n        root%right%right%left%val = 4\n    end subroutine init_tree\n\nend program main\n\nlogical function leafSimilar(root1, root2) result(isLeafSimilar)\n    type (TreeNode), intent(in) :: root1, root2\n    type (TreeNode), pointer :: curr1, curr2\n    integer :: leafValueSequence(100)\n    integer :: i, j\n\n    ! Initialize the leaf value sequence array\n    do i = 1, size(leafValueSequence)\n        leafValueSequence(i) = -1\n    end do\n\n    ! Traverse both trees simultaneously and fill the leaf value sequence array\n    curr1 => root1\n    curr2 => root2\n    i = 1\n    do while (associated(curr1))\n        if (.not. associated(curr1%left)) then\n            leafValueSequence(i) = curr1%val\n            i = i + 1\n        end if\n        curr1 => curr1%left\n        if (.not. associated(curr2)) exit\n        curr2 => curr2%left\n    end do\n\n    ! Check if the leaf value sequences are equal\n    do i = 1, size(leafValueSequence)\n        if (leafValueSequence(i) /= curr2%val) return\n        curr2 => curr2%left\n    end do\n\n    isLeafSimilar = .true.\n\nend function leafSimilar",
  "876": "program main\n    ! Solves the problem \"Given the 'head' of a singly linked list, return the middle node of the linked list.\"\n    implicit none\n\n    type :: node_t\n        integer :: val\n        type(node_t), pointer :: next => null()\n    end type\n\n    type(node_t), target :: head\n    type(node_t), pointer :: current => null(), mid => null()\n    integer :: i\n\n    ! Examples\n    call add_node(head, 1)\n    call add_node(head, 2)\n    call add_node(head, 3)\n    call add_node(head, 4)\n    call add_node(head, 5)\n    print \"(A)\", get_middle_node(head)%val\n    call delete_all_nodes(head)\n\n    call add_node(head, 1)\n    call add_node(head, 2)\n    call add_node(head, 3)\n    call add_node(head, 4)\n    call add_node(head, 5)\n    call add_node(head, 6)\n    print \"(A)\", get_middle_node(head)%val\n    call delete_all_nodes(head)\n\ncontains\n\n    subroutine add_node(head, val)\n        ! Adds a new node with value `val` at the beginning of the linked list.\n        type(node_t), target :: head\n        integer, intent(in) :: val\n        type(node_t), pointer :: new_node\n\n        allocate(new_node)\n        new_node%val = val\n        new_node%next => head%next\n        head%next => new_node\n    end subroutine\n\n    function get_middle_node(head) result(mid)\n        ! Returns the middle node of the linked list. If there are two middle nodes, returns the second one.\n        type(node_t), target :: head\n        type(node_t), pointer :: current, mid\n\n        current => head%next\n        mid => head%next\n\n        do while (associated(current))\n            if (associated(current%next)) then\n                current => current%next%next\n            else\n                exit\n            end if\n            mid => mid%next\n        end do\n    end function\n\n    subroutine delete_all_nodes(head)\n        ! Deletes all nodes from the linked list.\n        type(node_t), target :: head\n        type(node_t), pointer :: current, next\n\n        current => head%next\n        do while (associated(current))\n            next => current%next\n            deallocate(current)\n            current => next\n        end do\n    end subroutine\nend program",
  "883": "program main\n    implicit none\n\n    integer, parameter :: n = 2\n    integer :: i, j, v\n    integer, dimension(n, n) :: grid\n    integer :: total_area\n\n    ! Example 1\n    grid = reshape([1, 2, 3, 4], shape=[n, n])\n    write (*, '(a, i0)') 'Example 1: ', total_area(grid)\n\n    ! Example 2\n    grid = reshape([2], shape=[n, n])\n    write (*, '(a, i0)') 'Example 2: ', total_area(grid)\n\n    ! Example 3\n    grid = reshape([1, 0, 0, 2], shape=[n, n])\n    write (*, '(a, i0)') 'Example 3: ', total_area(grid)\n\ncontains\n\n    function total_area(grid) result(total)\n        implicit none\n        integer, intent(in) :: grid(:, :)\n        integer :: total\n        integer :: i, j, v\n\n        total = 0\n        do i = 1, size(grid, 1)\n            do j = 1, size(grid, 2)\n                v = grid(i, j)\n                if (v > 0) then\n                    total = total + v * (v + 1)\n                end if\n            end do\n        end do\n    end function total_area\n\nend program main",
  "884": "program main\n    implicit none\n\n    character(len=:), allocatable :: s1, s2\n    integer :: i, j\n    logical :: found\n\n    ! Examples\n    call test_example(\"this apple is sweet\", \"this apple is sour\")\n    call test_example(\"apple apple\", \"banana\")\n\ncontains\n\n    subroutine test_example(s1, s2)\n        implicit none\n        character(len=*), intent(in) :: s1, s2\n\n        write(*,*) 'Testing example: ', trim(s1), ' ', trim(s2)\n        call solve(s1, s2)\n    end subroutine test_example\n\n    subroutine solve(s1, s2)\n        implicit none\n        character(len=*), intent(in) :: s1, s2\n        character(len=:), allocatable :: words(:)\n        integer :: nwords\n\n        ! Split the sentences into words\n        call split_into_words(s1, words, nwords)\n        call split_into_words(s2, words, nwords)\n\n        ! Find the uncommon words\n        do i = 1, nwords\n            found = .false.\n            do j = 1, nwords\n                if (i /= j) then\n                    if (words(i) == words(j)) then\n                        found = .true.\n                        exit\n                    end if\n                end if\n            end do\n            if (.not. found) then\n                write(*,'(A)') trim(words(i))\n            end if\n        end do\n\n    end subroutine solve\n\n    subroutine split_into_words(str, words, nwords)\n        implicit none\n        character(len=*), intent(in) :: str\n        character(len=:), allocatable, intent(out) :: words(:)\n        integer, intent(out) :: nwords\n\n        integer :: i, pos\n        character(len=1) :: c\n\n        nwords = 0\n        do i = 1, len_trim(str)\n            c = str(i:i)\n            if (c == ' ') then\n                nwords = nwords + 1\n            else\n                allocate(character(nwords) :: words(nwords))\n                words(nwords) = c\n            end if\n        end do\n\n    end subroutine split_into_words\n\nend program main",
  "888": "program main\n    implicit none\n\n    integer, parameter :: n = 2\n    integer, dimension(n) :: aliceSizes = [1, 1]\n    integer, dimension(n) :: bobSizes = [2, 2]\n    integer, dimension(2) :: answer\n\n    call solve(aliceSizes, bobSizes, answer)\n\n    write (*, '(A, I0, A, I0)') 'Answer: ', answer(1), ',', answer(2)\n\ncontains\n\nsubroutine solve(aliceSizes, bobSizes, answer)\n    implicit none\n    integer, intent(in) :: aliceSizes(:), bobSizes(:)\n    integer, intent(out) :: answer(:)\n    integer :: aliceTotal, bobTotal, diff\n\n    aliceTotal = sum(aliceSizes)\n    bobTotal = sum(bobSizes)\n    diff = abs(aliceTotal - bobTotal)\n\n    if (diff == 0) then\n        answer = [0, 0]\n        return\n    end if\n\n    if (aliceTotal > bobTotal) then\n        answer = [diff, 0]\n    else\n        answer = [0, diff]\n    end if\nend subroutine solve\n\nend program main",
  "892": "program main\n    implicit none\n\n    integer, parameter :: n = 2\n    integer, dimension(n, n) :: grid\n    integer :: i, j, v\n    real :: area\n\n    ! Example 1\n    grid = reshape([1, 2, &\n                     3, 4], shape=[n, n])\n    write(*,*) \"Example 1:\"\n    call solve(grid, area)\n    write(*,*) \"Area: \", area\n\n    ! Example 2\n    grid = reshape([1, 1, 1, &\n                     1, 0, 1, &\n                     1, 1, 1], shape=[n, n])\n    write(*,*) \"Example 2:\"\n    call solve(grid, area)\n    write(*,*) \"Area: \", area\n\n    ! Example 3\n    grid = reshape([2, 2, 2, &\n                     2, 1, 2, &\n                     2, 2, 2], shape=[n, n])\n    write(*,*) \"Example 3:\"\n    call solve(grid, area)\n    write(*,*) \"Area: \", area\n\ncontains\n\n    subroutine solve(grid, area)\n        implicit none\n        integer, intent(in) :: grid(:, :)\n        real, intent(out) :: area\n\n        integer :: i, j, v\n        integer :: count\n        logical :: found\n\n        area = 0.0\n        do i = 1, size(grid, 1)\n            do j = 1, size(grid, 2)\n                v = grid(i, j)\n                if (v > 0) then\n                    count = 0\n                    found = .false.\n                    do while (.not. found)\n                        if (i - 1 >= 1) then\n                            if (grid(i-1, j) == v) then\n                                count = count + 1\n                                found = .true.\n                            end if\n                        else\n                            found = .true.\n                        end if\n                        if (.not. found) then\n                            if (j - 1 >= 1) then\n                                if (grid(i, j-1) == v) then\n                                    count = count + 1\n                                    found = .true.\n                                end if\n                            else\n                                found = .true.\n                            end if\n                        end if\n                        if (.not. found) then\n                            if (i + 1 <= size(grid, 1)) then\n                                if (grid(i+1, j) == v) then\n                                    count = count + 1\n                                    found = .true.\n                                end if\n                            else\n                                found = .true.\n                            end if\n                        end if\n                        if (.not. found) then\n                            if (j + 1 <= size(grid, 2)) then\n                                if (grid(i, j+1) == v) then\n                                    count = count + 1\n                                    found = .true.\n                                end if\n                            else\n                                found = .true.\n                            end if\n                        end if\n                    end do\n                    area = area + count * v\n                end if\n            end do\n        end do\n    end subroutine solve\nend program main",
  "896": "program monotonic_array\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums\n    logical :: result\n\n    ! monotonic increasing\n    nums = [1, 2, 2, 3]\n    result = monotonic_increasing(nums)\n    print '(A, L1)', 'Monotonic increasing: ', result\n\n    ! monotonic decreasing\n    nums = [6, 5, 4, 4]\n    result = monotonic_decreasing(nums)\n    print '(A, L1)', 'Monotonic decreasing: ', result\n\n    ! not monotonic\n    nums = [1, 3, 2]\n    result = monotonic_increasing(nums)\n    print '(A, L1)', 'Not monotonic: ', result\n\ncontains\n\n    function monotonic_increasing(nums) result(is_monotonic)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        logical :: is_monotonic\n        integer :: i, j\n\n        is_monotonic = .true.\n        do i = 1, size(nums)-1\n            do j = i+1, size(nums)\n                if (nums(i) > nums(j)) then\n                    is_monotonic = .false.\n                    exit\n                end if\n            end do\n            if (.not. is_monotonic) exit\n        end do\n    end function monotonic_increasing\n\n    function monotonic_decreasing(nums) result(is_monotonic)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        logical :: is_monotonic\n        integer :: i, j\n\n        is_monotonic = .true.\n        do i = 1, size(nums)-1\n            do j = i+1, size(nums)\n                if (nums(i) < nums(j)) then\n                    is_monotonic = .false.\n                    exit\n                end if\n            end do\n            if (.not. is_monotonic) exit\n        end do\n    end function monotonic_decreasing\nend program monotonic_array",
  "897": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, iostat_end\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=256) :: filename\n    type(error_type), allocatable :: err\n    type(tree_node), pointer :: root\n\n    ! Read input from file\n    write (unit=unit_out, fmt='(A)') 'Enter input filename:'\n    read (unit=unit_in, fmt='(A)', iostat=err%stat, iomsg=err%msg, &\n          iolength=err%n) filename\n    if (err%stat /= 0) then\n        write (unit=error_unit, fmt='(2A)') 'error: ', trim(err%msg)\n        stop 1\n    end if\n    open (newunit=unit_in, file=filename, status='old', &\n          action='read', access='stream', form='unformatted', &\n          iostat=err%stat, iomsg=err%msg)\n    if (err%stat /= 0) then\n        write (unit=error_unit, fmt='(2A)') 'error: ', trim(err%msg)\n        stop 1\n    end if\n    call read_tree(unit_in, root)\n    close (unit=unit_in)\n\n    ! Rearrange tree\n    call rearrange_tree(root)\n\n    ! Write output to stdout\n    call print_tree(root, unit_out)\n\ncontains\n\n    subroutine read_tree(unit, root)\n        implicit none\n        integer, intent(in) :: unit\n        type(tree_node), pointer, intent(out) :: root\n        class(tree_node), pointer :: current\n        integer :: stat\n\n        allocate (current)\n        current => root\n        do\n            read (unit=unit, fmt=*, iostat=stat) current%val\n            if (stat == iostat_end) exit\n            allocate (current%right)\n            current => current%right\n        end do\n        nullify (current%right)\n    end subroutine read_tree\n\n    subroutine rearrange_tree(root)\n        implicit none\n        type(tree_node), pointer, intent(inout) :: root\n        type(tree_node), pointer :: current, next\n\n        current => root\n        do while (associated(current))\n            if (associated(current%left)) then\n                next => current%left\n                current%left => null()\n                current => next\n            else\n                next => current%right\n                current%right => null()\n                current => next\n            end if\n        end do\n    end subroutine rearrange_tree\n\n    subroutine print_tree(root, unit)\n        implicit none\n        type(tree_node), pointer, intent(in) :: root\n        integer, intent(in) :: unit\n        class(tree_node), pointer :: current\n\n        current => root\n        do while (associated(current))\n            write (unit=unit, fmt='(I0)') current%val\n            if (associated(current%left)) then\n                current => current%left\n            else if (associated(current%right)) then\n                current => current%right\n            else\n                exit\n            end if\n        end do\n    end subroutine print_tree\n\nend program main\n\ntype :: tree_node\n    integer :: val\n    type(tree_node), pointer :: left => null(), right => null()\nend type tree_node",
  "905": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums\n    integer, dimension(n) :: result\n\n    nums = [3, 1, 2, 4]\n    write (*, '(*(g0))') 'Example 1:'\n    write (*, '(*(g0))') 'Input:', nums\n    call move_even_odd(nums, result)\n    write (*, '(*(g0))') 'Output:', result\n    write (*, *)\n\n    nums = [0]\n    write (*, '(*(g0))') 'Example 2:'\n    write (*, '(*(g0))') 'Input:', nums\n    call move_even_odd(nums, result)\n    write (*, '(*(g0))') 'Output:', result\n    write (*, *)\n\ncontains\n\n    subroutine move_even_odd(nums, result)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer, intent(out) :: result(:)\n\n        integer :: i, j\n\n        do i = 1, size(nums)\n            if (mod(nums(i), 2) == 0) then\n                result(j) = nums(i)\n                j = j + 1\n            end if\n        end do\n\n        do i = 1, size(nums)\n            if (mod(nums(i), 2) /= 0) then\n                result(j) = nums(i)\n                j = j + 1\n            end if\n        end do\n    end subroutine move_even_odd\nend program main",
  "908": "program main\n    implicit none\n\n    integer, parameter :: n = 1\n    integer, parameter :: k = 0\n    integer, dimension(n) :: nums\n    integer :: i, j, x\n    integer :: score\n\n    ! Example 1\n    nums = [1]\n    write (*, '(A)') 'Example 1:'\n    write (*, '(A)') 'Input: nums = [1], k = 0'\n    write (*, '(A)') 'Output:', solve(nums, k)\n    write (*, '(A)') 'Expected: 0'\n    write (*, *)\n\n    ! Example 2\n    nums = [0, 10]\n    write (*, '(A)') 'Example 2:'\n    write (*, '(A)') 'Input: nums = [0, 10], k = 2'\n    write (*, '(A)') 'Output:', solve(nums, k)\n    write (*, '(A)') 'Expected: 6'\n    write (*, *)\n\n    ! Example 3\n    nums = [1, 3, 6]\n    write (*, '(A)') 'Example 3:'\n    write (*, '(A)') 'Input: nums = [1, 3, 6], k = 3'\n    write (*, '(A)') 'Output:', solve(nums, k)\n    write (*, '(A)') 'Expected: 0'\n    write (*, *)\n\ncontains\n\n    function solve(nums, k) result(min_score)\n        implicit none\n        integer, intent(in) :: nums(:), k\n        integer :: min_score\n        integer :: i, j, x\n\n        do i = 1, size(nums)\n            do j = 1, size(nums)\n                if (i /= j) then\n                    x = nums(j) + k\n                    if (x >= 0 .and. x <= 100) then\n                        nums(j) = x\n                    end if\n                end if\n            end do\n        end do\n\n        min_score = maxval(nums) - minval(nums)\n\n    end function solve\n\nend program main",
  "914": "program main\n    implicit none\n\n    integer, parameter :: n = 8\n    integer, dimension(n) :: deck = (/ 1, 2, 3, 4, 4, 3, 2, 1 /)\n    logical :: result\n\n    print '(L1)', solve(deck)\n\ncontains\n\n    function solve(deck) result(result)\n        implicit none\n        integer, intent(in) :: deck(:)\n        integer :: x, i, j\n        logical :: found\n\n        do x = 2, size(deck)\n            found = .false.\n            do i = 1, size(deck) - x + 1\n                if (all(deck(i:i+x-1) == deck(i))) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) then\n                result = .true.\n                return\n            end if\n        end do\n        result = .false.\n    end function solve\nend program main",
  "917": "program main\n    implicit none\n\n    character(len=100) :: s\n\n    call get_command_argument(1, s)\n\n    print '(A)', reverse_string(s)\n\ncontains\n\n    function reverse_string(s) result(r)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=len(s)) :: r\n\n        integer :: i, j\n\n        do i = 1, len(s)\n            if (is_letter(s(i:i))) then\n                j = len(s) - i + 1\n                r(j:j) = s(i:i)\n            else\n                r(i:i) = s(i:i)\n            end if\n        end do\n    end function reverse_string\n\n    function is_letter(c) result(res)\n        implicit none\n        character(len=*), intent(in) :: c\n        logical :: res\n\n        res = any(c == ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']) .or. &\n              any(c == ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'])\n    end function is_letter\n\nend program main",
  "922": "program main\n    implicit none\n\n    integer :: i, n, nums(4)\n\n    ! Examples\n    n = 4\n    nums = (/ 4, 2, 5, 7 /)\n    call sort_array(n, nums)\n    write (*, '(A, I0, A, 4I0)') 'Example 1: ', n, ' -> ', nums\n\n    n = 2\n    nums = (/ 2, 3 /)\n    call sort_array(n, nums)\n    write (*, '(A, I0, A, 2I0)') 'Example 2: ', n, ' -> ', nums\n\ncontains\n\n    subroutine sort_array(n, nums)\n        implicit none\n        integer, intent(inout) :: n\n        integer, intent(inout) :: nums(:)\n        integer :: i, j, temp\n\n        do i = 1, n - 1\n            do j = i + 1, n\n                if (mod(nums(i), 2) == 0 .neqv. mod(j, 2) == 0) then\n                    temp = nums(i)\n                    nums(i) = nums(j)\n                    nums(j) = temp\n                end if\n            end do\n        end do\n    end subroutine sort_array\n\nend program main",
  "925": "program main\n    implicit none\n\n    integer :: i\n    character(len=1000) :: name, typed\n\n    do i = 1, size(examples)\n        read(examples(i), *) name, typed\n        write(*,*) solve(name, typed)\n    end do\n\ncontains\n\n    function solve(name, typed) result(res)\n        implicit none\n        character(len=*), intent(in) :: name, typed\n        logical :: res\n\n        ! TODO: Implement me\n\n    end function solve\n\n    character(len=1000), parameter :: examples(3) = [\"alex \", &\n                                                     \"saeed \", &\n                                                     \"leelee \"]\n\nend program main",
  "929": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=100) :: emails(100), local_name, domain_name\n    logical :: has_plus, has_dot\n\n    ! read input\n    read(*,*) n\n    do i = 1, n\n        read(*,*) emails(i)\n    end do\n\n    ! count unique addresses\n    j = 0\n    do i = 1, n\n        ! extract local name and domain name\n        local_name = trim(emails(i))\n        domain_name = ''\n        has_plus = .false.\n        has_dot = .false.\n        do while (local_name /= '')\n            if (local_name(1:1) == '+') then\n                has_plus = .true.\n                exit\n            else if (local_name(1:1) == '.') then\n                has_dot = .true.\n            end if\n            local_name = local_name(2:)\n        end do\n        if (.not. has_plus) then\n            do while (domain_name /= '')\n                if (domain_name(1:1) == '.') then\n                    domain_name = domain_name(2:)\n                else\n                    exit\n                end if\n            end do\n        end if\n        if (.not. has_dot) then\n            domain_name = trim(emails(i))\n        end if\n\n        ! check if address is unique\n        if (.not. any(trim(local_name) == trim(emails(:i-1)))) then\n            j = j + 1\n        end if\n    end do\n\n    ! print output\n    write(*,*) j\n\nend program main",
  "933": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, iostat_end\n    implicit none\n    type(RecentCounter) :: recentCounter\n    integer :: t, n, i, status\n    character(len=:), allocatable :: line\n\n    ! Read input from stdin\n    do\n        read (unit=input_unit, fmt='(A)', iostat=status) line\n        if (status == iostat_end) exit\n        if (status /= 0) then\n            write (unit=error_unit, fmt='(2A)') 'error: ', trim(line)\n            stop 1\n        end if\n        backspace input_unit\n        read (unit=input_unit, fmt=*) t\n        n = recentCounter%ping(t)\n        write (unit=output_unit, fmt='(I0)') n\n    end do\n\ncontains\n\n    type RecentCounter\n        integer :: count = 0\n        integer, dimension(:), pointer :: requests => null()\n    contains\n        procedure :: ping\n    end type RecentCounter\n\n    integer function ping(this, t) result(n)\n        class(RecentCounter), intent(inout) :: this\n        integer, value :: t\n        integer :: i, j\n\n        ! Check if we need to reallocate the array\n        if (.not. associated(this%requests)) then\n            allocate(this%requests(100))\n        else if (size(this%requests) < size(this%requests) + 1) then\n            allocate(this%requests(size(this%requests)*2))\n        end if\n\n        ! Increment the count\n        this%count = this%count + 1\n\n        ! Shift the requests down by one position\n        do i = this%count, 2, -1\n            this%requests(i) = this%requests(i-1)\n        end do\n\n        ! Store the new request\n        this%requests(1) = t\n\n        ! Count the number of requests in the past 3000 ms\n        n = 0\n        do i = 1, this%count\n            if (this%requests(i) >= t - 3000) then\n                n = n + 1\n            end if\n        end do\n    end function ping\n\nend program main",
  "938": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, iostat_end, DP => REAL64\n    implicit none\n    integer, parameter :: unit_write = 10\n    type :: node_t\n        real(kind=DP) :: val\n        type(node_t), pointer :: left => null(), right => null()\n    end type\n    type(node_t), target :: root\n    real(kind=DP) :: low, high\n    integer :: status\n\n    call get_args(root, low, high)\n\n    if (root%left /= null()) then\n        write (unit=unit_write, fmt='(A)', iomsg=status) 'Left child exists'\n        stop 1\n    end if\n    if (root%right /= null()) then\n        write (unit=unit_write, fmt='(A)', iomsg=status) 'Right child exists'\n        stop 1\n    end if\n\n    if (root%val < low .or. root%val > high) then\n        write (unit=unit_write, fmt='(A)', iomsg=status) 'Root value out of range'\n        stop 1\n    end if\n\n    write (unit=unit_write, fmt='(F0.2)') root%val\n\ncontains\n\n    subroutine get_args(root, low, high)\n        type(node_t), intent(out) :: root\n        real(kind=DP), intent(out) :: low, high\n        character(len=1024) :: buffer\n        integer :: iarg, arg_count\n\n        arg_count = command_argument_count()\n        if (arg_count /= 3) then\n            write (unit=error_unit, fmt='(A)') 'Usage: ./a.out root low high'\n            stop 1\n        end if\n\n        iarg = 1\n        call get_command_argument(iarg, buffer)\n        read (buffer, fmt=*, iomsg=status) root\n        if (status /= 0) then\n            write (unit=error_unit, fmt='(2A)') 'Error reading root: ', trim(buffer)\n            stop 1\n        end if\n\n        iarg = iarg + 1\n        call get_command_argument(iarg, buffer)\n        read (buffer, fmt=*, iomsg=status) low\n        if (status /= 0) then\n            write (unit=error_unit, fmt='(2A)') 'Error reading low: ', trim(buffer)\n            stop 1\n        end if\n\n        iarg = iarg + 1\n        call get_command_argument(iarg, buffer)\n        read (buffer, fmt=*, iomsg=status) high\n        if (status /= 0) then\n            write (unit=error_unit, fmt='(2A)') 'Error reading high: ', trim(buffer)\n            stop 1\n        end if\n    end subroutine get_args\n\nend program main",
  "941": "program main\n\n! This program solves the problem described in the comment at the top of the file.\n\nimplicit none\ninteger :: arr(10)\nlogical :: result\n\n! Example 1:\narr = [2, 1]\nresult = is_mountain_array(arr)\nprint '(L1)', result\n\n! Example 2:\narr = [3, 5, 5]\nresult = is_mountain_array(arr)\nprint '(L1)', result\n\n! Example 3:\narr = [0, 3, 2, 1]\nresult = is_mountain_array(arr)\nprint '(L1)', result\n\ncontains\n\nfunction is_mountain_array(arr) result(res)\nimplicit none\ninteger, intent(in) :: arr(:)\nlogical :: res\ninteger :: i\n\nif (size(arr) < 3) then\n    res = .false.\nelse\n    do i = 2, size(arr) - 1\n        if (arr(i-1) < arr(i) .and. arr(i) > arr(i+1)) exit\n    end do\n    res = (i /= size(arr))\nend if\n\nend function is_mountain_array\n\nend program main",
  "942": "program main\n    implicit none\n\n    integer :: i, j, k, n\n    character(len=1) :: s(105)\n    integer :: perm(105)\n\n    ! read input\n    read(*,*) n\n    read(*,*) s\n\n    ! solve problem\n    do i = 1, n\n        perm(i) = i - 1\n    end do\n    do i = 1, n - 1\n        if (s(i) == 'I') then\n            j = perm(i)\n            k = perm(i + 1)\n            perm(i) = k\n            perm(i + 1) = j\n        else if (s(i) == 'D') then\n            j = perm(i)\n            k = perm(i + 1)\n            perm(i) = k\n            perm(i + 1) = j\n        end if\n    end do\n\n    ! print output\n    write(*,*) perm\n\nend program main",
  "944": "program main\n    implicit none\n\n    integer :: i, j, k, n, m, num_cols_to_delete\n    character(len=100) :: strs(100)\n\n    ! read input\n    read(*,*) n\n    do i = 1, n\n        read(*,*) strs(i)\n    end do\n\n    ! solve problem\n    num_cols_to_delete = 0\n    do i = 1, n\n        if (any(strs(i)(j+1:) < strs(i)(j:))) then\n            num_cols_to_delete = num_cols_to_delete + 1\n        end if\n    end do\n\n    ! print output\n    write(*,*) num_cols_to_delete\n\nend program main",
  "953": "program main\n    implicit none\n\n    integer :: i, j\n    character(len=26) :: order\n    character(len=20), allocatable :: words(:)\n\n    ! read input\n    read(*,*) order\n    allocate(words(size(order)))\n    do i = 1, size(words)\n        read(*,*) words(i)\n    end do\n\n    ! solve problem\n    call solve(words, order)\n\ncontains\n\n    subroutine solve(words, order)\n        implicit none\n        character(len=*), intent(in) :: words(:), order\n        logical :: sorted\n\n        sorted = .true.\n        do i = 1, size(words)-1\n            if (words(i+1) < words(i)) then\n                sorted = .false.\n                exit\n            end if\n        end do\n\n        write(*,*) sorted\n\n    end subroutine solve\n\nend program main",
  "961": "program main\n    implicit none\n\n    integer, parameter :: n = 2\n    integer, dimension(2*n) :: nums\n    integer :: i, j, count\n    logical :: found\n\n    ! Example 1\n    nums = [1, 2, 3, 3]\n    write (*, '(A, I0)') 'Example 1: ', find_repeated(nums)\n\n    ! Example 2\n    nums = [2, 1, 2, 5, 3, 2]\n    write (*, '(A, I0)') 'Example 2: ', find_repeated(nums)\n\n    ! Example 3\n    nums = [5, 1, 5, 2, 5, 3, 5, 4]\n    write (*, '(A, I0)') 'Example 3: ', find_repeated(nums)\n\ncontains\n\n    function find_repeated(nums) result(repeated)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer :: repeated\n        integer :: i, j, count\n        logical :: found\n\n        repeated = -1\n        do i = 1, size(nums) - 1\n            count = 0\n            found = .false.\n            do j = i + 1, size(nums)\n                if (nums(j) == nums(i)) then\n                    count = count + 1\n                    found = .true.\n                end if\n            end do\n            if (found .and. count == n) then\n                repeated = nums(i)\n                exit\n            end if\n        end do\n    end function find_repeated\n\nend program main",
  "965": "program main\n    ! Solves the problem:\n    ! A binary tree is uni-valued if every node in the tree has the same value.\n    ! Given the root of a binary tree, return true if the given tree is uni-valued, or false otherwise.\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=20) :: filename\n\n    type :: TreeNode\n        real(kind=DP), pointer :: val => null()\n        type(TreeNode), pointer :: left => null(), right => null()\n    end type TreeNode\n\n    type(TreeNode), pointer :: root\n\n    logical :: result\n\n    write (unit=unit_out, fmt='(A)') 'Enter filename:'\n    read (unit=unit_in, fmt='(A)') filename\n    open (newunit=unit_in, file=filename, status='old', action='read', &\n          iostat=result, iomsg=filename)\n    if (result /= 0) then\n        write (unit=error_unit, fmt='(2A)') 'error: cannot open file \"', trim(filename), '\"'\n        stop 1\n    end if\n    call parse_tree(unit_in, root)\n    close (unit=unit_in)\n\n    result = is_uni_valued(root)\n    write (unit=unit_out, fmt='(L1)') result\n\ncontains\n\n    subroutine parse_tree(unit_in, root)\n        implicit none\n        integer, intent(in) :: unit_in\n        type(TreeNode), pointer, intent(out) :: root\n        class(*), allocatable :: tmp\n        allocate (tmp)\n        call parse_node(unit_in, tmp)\n        select type (tmp)\n            type is (real(kind=DP))\n                allocate (root)\n                root%val => tmp\n            type is (TreeNode)\n                allocate (root)\n                root%left => tmp\n            class default\n                error stop 'parse_tree: invalid node type'\n        end select\n    end subroutine parse_tree\n\n    subroutine parse_node(unit_in, node)\n        implicit none\n        integer, intent(in) :: unit_in\n        class(*), allocatable, intent(out) :: node\n        character(len=20) :: token\n        read (unit=unit_in, fmt=*, iostat=result) token\n        if (result /= 0) then\n            deallocate (node)\n            return\n        end if\n        select case (token)\n            case ('[')\n                allocate (TreeNode::node)\n                call parse_node(unit_in, node%left)\n                call parse_node(unit_in, node%right)\n            case (']')\n                deallocate (node)\n            case default\n                allocate (real(kind=DP)::node)\n                read (unit=token, fmt=*) node\n        end select\n    end subroutine parse_node\n\n    function is_uni_valued(root) result(res)\n        implicit none\n        type(TreeNode), pointer, intent(in) :: root\n        logical :: res\n        real(kind=DP) :: val\n        res = .true.\n        if (.not. associated(root)) return\n        val = root%val\n        if (.not. is_uni_valued(root%left)) then\n            res = .false.\n            return\n        end if\n        if (.not. is_uni_valued(root%right)) then\n            res = .false.\n            return\n        end if\n        if (abs(val - root%left%val) > epsilon(val)) then\n            res = .false.\n            return\n        end if\n        if (abs(val - root%right%val) > epsilon(val)) then\n            res = .false.\n            return\n        end if\n    end function is_uni_valued\n\nend program main",
  "976": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: nums\n    integer :: i, j, k, max_perimeter\n\n    ! Examples\n    nums = [2, 1, 2]\n    write (*, '(A, I0)') 'Example 1: ', largestPerimeter(nums)\n    nums = [1, 2, 1, 10]\n    write (*, '(A, I0)') 'Example 2: ', largestPerimeter(nums)\n\ncontains\n\n    function largestPerimeter(nums) result(max_perimeter)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: i, j, k, perimeter\n        logical :: found\n\n        max_perimeter = 0\n        do i = 1, size(nums) - 2\n            do j = i + 1, size(nums) - 1\n                do k = j + 1, size(nums)\n                    perimeter = nums(i) + nums(j) + nums(k)\n                    if (perimeter > max_perimeter .and. &\n                        nums(i) * nums(j) < nums(k)) then\n                        max_perimeter = perimeter\n                    end if\n                end do\n            end do\n        end do\n    end function largestPerimeter\nend program main",
  "977": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer :: nums(n) = [-4, -1, 0, 3, 10]\n    integer :: i, j\n    integer :: squares(n)\n\n    do i = 1, n\n        squares(i) = nums(i) * nums(i)\n    end do\n\n    call sort_array(squares)\n\n    write (*, '(A)') 'Squares:'\n    do i = 1, n\n        write (*, '(I0)', advance='no') squares(i)\n    end do\n    write (*, *)\n\ncontains\n\n    subroutine sort_array(arr)\n        implicit none\n        integer, intent(inout) :: arr(:)\n        integer :: temp\n        integer :: i, j\n\n        do i = 1, size(arr)-1\n            do j = i+1, size(arr)\n                if (arr(j) < arr(i)) then\n                    temp = arr(j)\n                    arr(j) = arr(i)\n                    arr(i) = temp\n                end if\n            end do\n        end do\n    end subroutine sort_array\n\nend program main",
  "989": "program main\n    implicit none\n\n    integer :: num(4), k\n    integer :: i\n\n    ! Example 1\n    num = [1, 2, 0, 0]\n    k = 34\n    call print_array_form(num)\n    write (*,*) \" + \", k, \" = \"\n    call add_to_array_form(num, k)\n    call print_array_form(num)\n    write (*,*) \"\"\n\n    ! Example 2\n    num = [2, 7, 4]\n    k = 181\n    call print_array_form(num)\n    write (*,*) \" + \", k, \" = \"\n    call add_to_array_form(num, k)\n    call print_array_form(num)\n    write (*,*) \"\"\n\n    ! Example 3\n    num = [2, 1, 5]\n    k = 806\n    call print_array_form(num)\n    write (*,*) \" + \", k, \" = \"\n    call add_to_array_form(num, k)\n    call print_array_form(num)\n    write (*,*) \"\"\n\ncontains\n\n    subroutine print_array_form(num)\n        implicit none\n        integer, intent(in) :: num(:)\n        integer :: i\n\n        do i = size(num), 1, -1\n            write (*,*) num(i), \" \"\n        end do\n    end subroutine print_array_form\n\n    subroutine add_to_array_form(num, k)\n        implicit none\n        integer, intent(inout) :: num(:)\n        integer, value :: k\n        integer :: carry\n\n        carry = 0\n        do i = 1, size(num)\n            num(i) = num(i) + carry\n            carry = num(i) / 10\n            num(i) = mod(num(i), 10)\n        end do\n        if (carry > 0) then\n            allocate(num(size(num)+1))\n            num(1:size(num)-1) = 0\n            num(size(num)) = carry\n        end if\n    end subroutine add_to_array_form\n\nend program main",
  "993": "program cousinsInBinaryTree\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: UNIT_IN = 7, UNIT_OUT = 8\n\n    type :: TreeNode\n        real(kind=DP) :: val\n        type(TreeNode), pointer :: left, right\n    end type TreeNode\n\n    interface\n        function isCousin(root, x, y) result(res)\n            import TreeNode\n            type(TreeNode), target, intent(in) :: root\n            real(kind=DP), intent(in) :: x, y\n            logical :: res\n        end function isCousin\n    end interface\n\n    type(TreeNode), pointer :: root\n    real(kind=DP) :: x, y\n    logical :: res\n\n    call get_arguments()\n    call solve()\n\ncontains\n\n    subroutine get_arguments()\n        read (UNIT=UNIT_IN, FMT='(L1)') x\n        read (UNIT=UNIT_IN, FMT='(L1)') y\n        allocate(root)\n        call read_tree(root)\n    end subroutine get_arguments\n\n    subroutine solve()\n        res = isCousin(root, x, y)\n        write (UNIT=UNIT_OUT, FMT='(L1)') res\n    end subroutine solve\n\n    recursive subroutine read_tree(node)\n        class(TreeNode), pointer, intent(out) :: node\n        integer :: depth\n        read (UNIT=UNIT_IN, FMT='(I1)') depth\n        if (depth == 0) then\n            nullify(node)\n        else\n            allocate(node)\n            read (UNIT=UNIT_IN, FMT='(F10.0)') node%val\n            call read_tree(node%left)\n            call read_tree(node%right)\n        end if\n    end subroutine read_tree\n\n    function isCousin(root, x, y) result(res)\n        type(TreeNode), target, intent(in) :: root\n        real(kind=DP), intent(in) :: x, y\n        logical :: res\n        type(TreeNode), pointer :: current\n        integer :: depthX, depthY\n\n        ! Find the depth of both nodes\n        current => root\n        do while (associated(current))\n            if (current%val == x) exit\n            current => current%left\n        end do\n        depthX = 0\n        do while (associated(current))\n            depthX = depthX + 1\n            current => current%parent\n        end do\n\n        current => root\n        do while (associated(current))\n            if (current%val == y) exit\n            current => current%left\n        end do\n        depthY = 0\n        do while (associated(current))\n            depthY = depthY + 1\n            current => current%parent\n        end do\n\n        res = depthX /= depthY .and. depthX == depthY - 1\n    end function isCousin\n\nend program cousinsInBinaryTree",
  "997": "program main\n    implicit none\n\n    integer :: n, i, j, k, m, n_people, n_trust, trust(n, n), trusted(n), &\n               untrusted(n), town_judge\n\n    ! Examples\n    n = 2\n    trust = reshape([1, 2, 2, 1], shape=[n, n])\n    write(*, '(A, I0)') 'Example 1: ', solve(n, trust)\n\n    n = 3\n    trust = reshape([1, 3, 2, 3], shape=[n, n])\n    write(*, '(A, I0)') 'Example 2: ', solve(n, trust)\n\n    n = 3\n    trust = reshape([1, 3, 2, 3, 3, 1], shape=[n, n])\n    write(*, '(A, I0)') 'Example 3: ', solve(n, trust)\n\ncontains\n\n    function solve(n_people, trust) result(town_judge)\n        implicit none\n        integer, intent(in) :: n_people, trust(:, :)\n        integer :: i, j, k, m, trusted(n_people), untrusted(n_people)\n\n        town_judge = -1\n\n        ! Initialize arrays\n        trusted = 0\n        untrusted = 0\n\n        ! Count number of trust relationships\n        do i = 1, n_people\n            do j = 1, n_people\n                if (trust(i, j) > 0) then\n                    trusted(j) = trusted(j) + 1\n                    untrusted(i) = untrusted(i) + 1\n                end if\n            end do\n        end do\n\n        ! Check if there is only one person who trusts nobody\n        m = count(untrusted == 0)\n        if (m == 1) then\n            town_judge = maxloc(untrusted, dim=1)\n        end if\n\n        ! Check if there is only one person who is trusted by everybody\n        m = count(trusted == n_people - 1)\n        if (m == 1) then\n            town_judge = minloc(trusted, dim=1)\n        end if\n\n    end function solve\nend program main",
  "999": "program main\n    implicit none\n\n    character(len=1) :: board(8,8)\n    integer :: i, j, num_captures\n\n    ! read input\n    do i = 1, 8\n        read(*,*) board(:,i)\n    end do\n\n    ! solve problem\n    num_captures = count_rook_captures(board)\n\n    ! print output\n    write(*,*) num_captures\n\ncontains\n\n    function count_rook_captures(board) result(num_captures)\n        implicit none\n        character(len=1), intent(in) :: board(8,8)\n        integer :: i, j, num_captures\n\n        num_captures = 0\n        do i = 1, 8\n            do j = 1, 8\n                if (board(i,j) == 'R') then\n                    call count_rook_captures_helper(board, i, j, num_captures)\n                end if\n            end do\n        end do\n    end function count_rook_captures\n\n    subroutine count_rook_captures_helper(board, i, j, num_captures)\n        implicit none\n        character(len=1), intent(in) :: board(8,8)\n        integer, intent(in) :: i, j\n        integer, intent(out) :: num_captures\n\n        integer :: k, l\n\n        select case (board(i,j))\n        case ('R')\n            ! north\n            k = i - 1\n            do while (k >= 1 .and. board(k,j) /= 'B')\n                if (board(k,j) == 'p') then\n                    num_captures = num_captures + 1\n                end if\n                k = k - 1\n            end do\n\n            ! east\n            l = j + 1\n            do while (l <= 8 .and. board(i,l) /= 'B')\n                if (board(i,l) == 'p') then\n                    num_captures = num_captures + 1\n                end if\n                l = l + 1\n            end do\n\n            ! south\n            k = i + 1\n            do while (k <= 8 .and. board(k,j) /= 'B')\n                if (board(k,j) == 'p') then\n                    num_captures = num_captures + 1\n                end if\n                k = k + 1\n            end do\n\n            ! west\n            l = j - 1\n            do while (l >= 1 .and. board(i,l) /= 'B')\n                if (board(i,l) == 'p') then\n                    num_captures = num_captures + 1\n                end if\n                l = l - 1\n            end do\n        end select\n    end subroutine count_rook_captures_helper\n\nend program main",
  "1002": "program main\n    implicit none\n\n    character(len=:), allocatable :: words(:)\n    character(len=:), allocatable :: chars(:)\n    integer :: i, j, k\n\n    ! Example 1\n    words = [\"bella\", \"label\", \"roller\"]\n    call getChars(words, chars)\n    print \"(A)\", chars\n\n    ! Example 2\n    words = [\"cool\", \"lock\", \"cook\"]\n    call getChars(words, chars)\n    print \"(A)\", chars\n\ncontains\n\n    subroutine getChars(words, chars)\n        implicit none\n        character(len=*), intent(in) :: words(:)\n        character(len=*), intent(out) :: chars(:)\n        integer :: n, m\n        logical :: found(26)\n\n        n = size(words)\n        m = 0\n        do i = 1, n\n            found = .false.\n            do j = 1, n\n                if (j /= i) then\n                    do k = 1, len(words(j))\n                        if (.not. found(ichar(words(j)(k:k)))) then\n                            found(ichar(words(j)(k:k))) = .true.\n                        end if\n                    end do\n                end if\n            end do\n            do k = 1, 26\n                if (found(k)) then\n                    m = m + 1\n                end if\n            end do\n        end do\n\n        allocate(chars(m))\n        m = 0\n        do i = 1, n\n            do j = 1, len(words(i))\n                if (.not. found(ichar(words(i)(j:j)))) then\n                    found(ichar(words(i)(j:j))) = .true.\n                    m = m + 1\n                    chars(m) = words(i)(j:j)\n                end if\n            end do\n        end do\n\n    end subroutine getChars\n\nend program main",
  "1005": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, parameter :: k = 1\n    integer, dimension(n) :: nums\n    integer :: i\n    integer :: max_sum\n\n    ! Example 1\n    nums = (/ 4, 2, 3 /)\n    call solve(nums, k)\n    write (*, '(A, I0)') 'Example 1: ', sum(nums)\n\n    ! Example 2\n    nums = (/ 3, -1, 0, 2 /)\n    call solve(nums, k)\n    write (*, '(A, I0)') 'Example 2: ', sum(nums)\n\n    ! Example 3\n    nums = (/ 2, -3, -1, 5, -4 /)\n    call solve(nums, k)\n    write (*, '(A, I0)') 'Example 3: ', sum(nums)\n\ncontains\n\n    subroutine solve(nums, k)\n        implicit none\n        integer, intent(inout) :: nums(:)\n        integer, value :: k\n        integer :: i\n\n        do i = 1, k\n            call choose_index(nums)\n        end do\n    end subroutine solve\n\n    subroutine choose_index(nums)\n        implicit none\n        integer, intent(inout) :: nums(:)\n        integer :: i\n\n        call random_number(i)\n        i = int(i * size(nums)) + 1\n        nums(i) = -nums(i)\n    end subroutine choose_index\n\nend program main",
  "1009": "program main\n    !! Solves the problem described in the comment block\n    implicit none\n\n    integer :: n, complement\n\n    ! Examples\n    n = 5\n    write (*, '(A, I0)') 'Complement of ', n, ' is ', complement(n)\n    n = 7\n    write (*, '(A, I0)') 'Complement of ', n, ' is ', complement(n)\n    n = 10\n    write (*, '(A, I0)') 'Complement of ', n, ' is ', complement(n)\n\ncontains\n\n    function complement(n) result(res)\n        !! Returns the complement of an integer\n        implicit none\n        integer, intent(in) :: n\n        integer :: res\n\n        res = iand(not(n), 1_8)\n    end function complement\n\nend program main",
  "1013": "program main\n    implicit none\n\n    integer, parameter :: n = 10\n    integer, dimension(n) :: arr\n    logical :: result\n\n    ! Example 1\n    arr = [0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]\n    write(*,*) 'Example 1'\n    write(*,*) 'Input: ', arr\n    result = canPartition(arr)\n    write(*,*) 'Output: ', result\n    write(*,*) ''\n\n    ! Example 2\n    arr = [0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1]\n    write(*,*) 'Example 2'\n    write(*,*) 'Input: ', arr\n    result = canPartition(arr)\n    write(*,*) 'Output: ', result\n    write(*,*) ''\n\n    ! Example 3\n    arr = [3, 3, 6, 5, -2, 2, 5, 1, -9, 4]\n    write(*,*) 'Example 3'\n    write(*,*) 'Input: ', arr\n    result = canPartition(arr)\n    write(*,*) 'Output: ', result\n    write(*,*) ''\n\ncontains\n\n    function canPartition(arr) result(result)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        logical :: result\n        integer :: i, j\n\n        do i = 1, size(arr)-2\n            do j = i+1, size(arr)-1\n                if (sum(arr(1:i)) == sum(arr(i+1:j)) .and. &\n                    sum(arr(j+1:size(arr))) == sum(arr(1:j))) then\n                    result = .true.\n                    exit\n                end if\n            end do\n            if (result) exit\n        end do\n    end function canPartition\n\nend program main",
  "1018": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: nums\n    logical, dimension(n) :: answer\n\n    ! Example 1\n    nums = [0, 1, 1]\n    answer = solve(nums)\n    write (*, '(A, L1)') 'Example 1: ', answer\n\n    ! Example 2\n    nums = [1, 1, 1]\n    answer = solve(nums)\n    write (*, '(A, L1)') 'Example 2: ', answer\n\ncontains\n\n    function solve(nums) result(answer)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        logical, dimension(size(nums)) :: answer\n        integer :: i\n\n        do i = 1, size(nums)\n            answer(i) = mod(xi(nums, i), 5) == 0\n        end do\n    end function solve\n\n    function xi(nums, i) result(xi)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, value :: i\n        integer :: xi\n\n        xi = 0\n        do while (i > 0)\n            xi = xi * 2 + nums(i)\n            i = i - 1\n        end do\n    end function xi\nend program main",
  "1021": "program main\n    implicit none\n\n    character(len=100) :: s\n    integer :: i\n\n    ! Examples\n    s = \"\"\n    call remove_outer_parens(s)\n    write (*,*) trim(s)\n\n    s = \"()\"\n    call remove_outer_parens(s)\n    write (*,*) trim(s)\n\n    s = \"(())()\"\n    call remove_outer_parens(s)\n    write (*,*) trim(s)\n\n    s = \"((()))()\"\n    call remove_outer_parens(s)\n    write (*,*) trim(s)\n\ncontains\n\n    subroutine remove_outer_parens(s)\n        implicit none\n        character(len=*), intent(inout) :: s\n        integer :: i\n\n        do while (s(1:1) == '(' .and. s(len_trim(s):len_trim(s)) == ')')\n            s = s(2:len_trim(s)-1)\n        end do\n\n        do while (s(1:1) == '(')\n            i = index(s, '(')\n            s = s(i+1:)\n        end do\n\n        do while (s(len_trim(s):len_trim(s)) == ')')\n            s = s(:len_trim(s)-1)\n        end do\n    end subroutine remove_outer_parens\nend program main",
  "1022": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 8\n    type :: Node\n        integer :: val\n        class(Node), pointer :: left, right\n    end type\n    type(Node), target :: root\n    integer :: i, j\n    real(kind=DP) :: x\n\n    ! Examples\n    call solve([1,0,1,0,1,0,1], x)\n    write (unit=error_unit, fmt='(A,F0.2)') 'Example 1: ', x\n    call solve([0], x)\n    write (unit=error_unit, fmt='(A,F0.2)') 'Example 2: ', x\n\ncontains\n\n    subroutine solve(root, x)\n        type(Node), intent(in) :: root\n        real(kind=DP), intent(out) :: x\n\n        x = 0.0_DP\n        do i = 1, n\n            if (associated(root%left)) then\n                call solve(root%left, x)\n            end if\n            x = x + real(root%val, kind=DP) * 2.0_DP**(n - i)\n            if (associated(root%right)) then\n                call solve(root%right, x)\n            end if\n        end do\n    end subroutine solve\nend program main",
  "1025": "program main\n    implicit none\n\n    integer :: n, x\n    logical :: alice_wins\n\n    ! Example 1\n    n = 2\n    alice_wins = solve(n)\n    print '(L1)', alice_wins\n\n    ! Example 2\n    n = 3\n    alice_wins = solve(n)\n    print '(L1)', alice_wins\n\ncontains\n\n    function solve(n) result(alice_wins)\n        implicit none\n        integer, intent(in) :: n\n        logical :: alice_wins\n\n        integer :: i\n        logical :: can_make_move\n\n        do while (n > 0)\n            can_make_move = .false.\n            do i = 2, n\n                if (mod(n,i) == 0) then\n                    can_make_move = .true.\n                    exit\n                end if\n            end do\n\n            if (.not. can_make_move) then\n                alice_wins = .false.\n                return\n            end if\n\n            call make_move(n, i)\n        end do\n\n        alice_wins = .true.\n\n    contains\n\n        subroutine make_move(n, x)\n            implicit none\n            integer, intent(inout) :: n\n            integer, intent(in) :: x\n\n            n = n - x\n        end subroutine make_move\n\n    end function solve\n\nend program main",
  "1030": "program main\n    implicit none\n\n    integer :: row, col, rCenter, cCenter\n    integer, allocatable :: dist(:, :)\n    integer :: i, j\n\n    ! Example 1\n    row = 1\n    col = 2\n    rCenter = 0\n    cCenter = 0\n    call solve(row, col, rCenter, cCenter, dist)\n    write(*, \"(A)\") \"Example 1:\"\n    do i = 1, size(dist, 1)\n        write(*, \"(A, I0, A, I0)\") \"[\", dist(i, 1), \",\", dist(i, 2), \"]\"\n    end do\n\n    ! Example 2\n    row = 2\n    col = 2\n    rCenter = 0\n    cCenter = 1\n    call solve(row, col, rCenter, cCenter, dist)\n    write(*, \"(A)\") \"Example 2:\"\n    do i = 1, size(dist, 1)\n        write(*, \"(A, I0, A, I0)\") \"[\", dist(i, 1), \",\", dist(i, 2), \"]\"\n    end do\n\n    ! Example 3\n    row = 2\n    col = 3\n    rCenter = 1\n    cCenter = 2\n    call solve(row, col, rCenter, cCenter, dist)\n    write(*, \"(A)\") \"Example 3:\"\n    do i = 1, size(dist, 1)\n        write(*, \"(A, I0, A, I0)\") \"[\", dist(i, 1), \",\", dist(i, 2), \"]\"\n    end do\n\ncontains\n\n    subroutine solve(row, col, rCenter, cCenter, dist)\n        implicit none\n        integer, intent(in) :: row, col, rCenter, cCenter\n        integer, allocatable, intent(out) :: dist(:, :)\n        integer :: i, j\n\n        allocate(dist(row * col, 2))\n\n        do i = 1, row\n            do j = 1, col\n                dist((i-1)*col+j, 1) = i\n                dist((i-1)*col+j, 2) = j\n            end do\n        end do\n\n        dist = abs(dist - [/( (i-1)*col+j, j=1,col ),/)])\n\n        dist = sum(dist, dim=2)\n\n        dist = sort(dist, dim=1)\n\n    end subroutine solve\n\nend program main",
  "1037": "program main\n    implicit none\n\n    integer, parameter :: dp = selected_real_kind(15)\n\n    integer :: i, j, k\n    real(dp), dimension(:, :), allocatable :: points\n    logical :: result\n\n    ! read input\n    allocate(points(3, 2))\n    do i = 1, 3\n        read *, points(i, :)\n    end do\n\n    ! solve problem\n    result = boomerang(points)\n\n    ! print output\n    write (*, '(L1)') result\n\ncontains\n\n    function boomerang(points) result(isBoomerang)\n        implicit none\n\n        real(dp), intent(in) :: points(:, :)\n        logical :: isBoomerang\n\n        integer :: i, j, k\n        real(dp) :: det\n\n        isBoomerang = .false.\n\n        do i = 1, size(points, 1) - 2\n            do j = i + 1, size(points, 1) - 1\n                do k = j + 1, size(points, 1)\n                    det = (points(k, 1) - points(j, 1)) * (points(i, 2) - points(j, 2)) &\n                        - (points(k, 2) - points(j, 2)) * (points(i, 1) - points(j, 1))\n                    if (det /= 0._dp) then\n                        isBoomerang = .true.\n                        exit\n                    end if\n                end do\n                if (isBoomerang) exit\n            end do\n            if (isBoomerang) exit\n        end do\n\n    end function boomerang\n\nend program main",
  "1046": "program main\n    implicit none\n\n    integer, parameter :: n_examples = 2\n    integer, parameter :: stones(n_examples) = reshape([2, 7, 4, 1, 8, 1], shape=[n_examples])\n    integer :: i\n\n    do i = 1, n_examples\n        print '(A, I0)', 'Example ', i\n        print '(A, I0)', 'Stones: ', stones(i)\n        print '(A, I0)', 'Result: ', solve(stones(i))\n        print *, ''\n    end do\n\ncontains\n\n    function solve(stones) result(result)\n        implicit none\n        integer, intent(in) :: stones(:)\n        integer :: result, x, y\n\n        if (size(stones) == 1) then\n            result = stones(1)\n        else\n            x = maxval(stones)\n            y = minval(stones)\n            if (x == y) then\n                result = 0\n            else\n                if (x < y) then\n                    result = y - x\n                else\n                    result = x\n                end if\n            end if\n        end if\n    end function solve\nend program main",
  "1047": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    integer :: i, j, n\n\n    ! Example 1\n    s = 'abbaca'\n    call solve(s)\n    print *, s\n\n    ! Example 2\n    s = 'azxxzy'\n    call solve(s)\n    print *, s\n\ncontains\n\nsubroutine solve(s)\n    implicit none\n    character(len=*), intent(inout) :: s\n    logical :: done\n\n    do while (.not. done)\n        done = .true.\n        do i = 1, len_trim(s)-1\n            if (s(i:i+1) == s(i+1:i+2)) then\n                s = s(:i-1) // s(i+2:)\n                done = .false.\n                exit\n            end if\n        end do\n    end do\nend subroutine solve\n\nend program main",
  "1051": "program main\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: heights, expected\n    integer :: i, j, count\n\n    ! Examples\n    heights = [1, 1, 4, 2, 1, 3]\n    write (*, '(A)') 'Example 1:'\n    call solve(heights, expected)\n    write (*, '(A)') 'Expected: 3'\n    write (*, '(A)') 'Actual: ', count\n\n    heights = [5, 1, 2, 3, 4]\n    write (*, '(A)') 'Example 2:'\n    call solve(heights, expected)\n    write (*, '(A)') 'Expected: 5'\n    write (*, '(A)') 'Actual: ', count\n\n    heights = [1, 2, 3, 4, 5]\n    write (*, '(A)') 'Example 3:'\n    call solve(heights, expected)\n    write (*, '(A)') 'Expected: 0'\n    write (*, '(A)') 'Actual: ', count\n\ncontains\n\n    subroutine solve(heights, expected)\n        implicit none\n        integer, intent(in) :: heights(:), expected(:)\n        integer :: i, j\n\n        count = 0\n        do i = 1, size(heights) - 1\n            if (heights(i) /= expected(i)) then\n                count = count + 1\n            end if\n        end do\n    end subroutine solve\nend program main",
  "1056": "program main\n    implicit none\n\n    integer :: i, n\n    logical :: confusing\n\n    ! Examples\n    do i = 1, size(examples)\n        read (examples(i), *) n\n        write (*, '(A, I0, A)', advance='no') 'Confusing number ', n, '? '\n        confusing = confusing_number(n)\n        if (confusing) then\n            write (*, '(A)') 'Yes'\n        else\n            write (*, '(A)') 'No'\n        end if\n    end do\n\ncontains\n\n    function confusing_number(n) result(confusing)\n        implicit none\n        integer, intent(in) :: n\n        logical :: confusing\n        integer :: rotated\n\n        confused = .false.\n\n        ! Rotate the digits of n by 180 degrees\n        rotated = modulo(n * 10 + 10 - n, 100)\n\n        ! Check if rotated is a valid number\n        select case (rotated)\n            case (0, 1, 6, 8, 9)\n                confusing = .true.\n            case default\n                confusing = .false.\n        end select\n\n        ! Ignore leading zeros\n        rotated = abs(rotated)\n\n        ! Check if rotated is equal to n\n        if (rotated == n) then\n            confusing = .false.\n        end if\n\n    end function confusing_number\n\nend program main\n\ninteger, parameter :: examples(3) = (/ 6, 89, 11 /)",
  "1064": "program main\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: arr\n    integer :: i\n\n    arr = [-10, -5, 0, 3, 7]\n    write (*, '(I0)') find_smallest_index(arr)\n\n    arr = [0, 2, 5, 8, 17]\n    write (*, '(I0)') find_smallest_index(arr)\n\n    arr = [-10, -5, 3, 4, 7, 9]\n    write (*, '(I0)') find_smallest_index(arr)\n\ncontains\n\n    function find_smallest_index(arr) result(i)\n        implicit none\n        integer, intent(in) :: arr(:)\n        integer :: i\n\n        i = -1\n        do while (i < size(arr))\n            if (arr(i+1) == i+1) then\n                i = i + 1\n            else\n                exit\n            end if\n        end do\n    end function find_smallest_index\n\nend program main",
  "1065": "program main\n    implicit none\n\n    character(len=100) :: text\n    character(len=50), dimension(:), allocatable :: words\n    integer, dimension(:,:), allocatable :: indices\n    integer :: i, j, n, m\n\n    ! Example 1\n    text = 'thestoryofleetcodeandme '\n    allocate(character(len=50) :: words(3))\n    words(1) = 'story '\n    words(2) = 'fleet '\n    words(3) = 'leetcode '\n    call solve(text, words, indices)\n    do i = 1, size(indices, 1)\n        write(*,'(A,I0,A,I0)') '[', indices(i,1), ',', indices(i,2), ']'\n    end do\n\n    ! Example 2\n    text = 'ababa '\n    allocate(character(len=50) :: words(4))\n    words(1) = 'aba '\n    words(2) = 'ab '\n    words(3) = 'ba '\n    words(4) = 'a '\n    call solve(text, words, indices)\n    do i = 1, size(indices, 1)\n        write(*,'(A,I0,A,I0)') '[', indices(i,1), ',', indices(i,2), ']'\n    end do\n\ncontains\n\n    subroutine solve(text, words, indices)\n        implicit none\n        character(len=*), intent(in) :: text\n        character(len=*), dimension(:), intent(in) :: words\n        integer, dimension(:,:), intent(out) :: indices\n        integer :: i, j, k, l, n, m\n\n        n = len(text)\n        m = size(words)\n        allocate(indices(m,2))\n\n        do i = 1, m\n            do j = 1, n-len(words(i))+1\n                do k = 1, len(words(i))\n                    if (text(j+k-1:j+k-1) /= words(i)(k:k)) exit\n                end do\n                if (k == len(words(i)+1)) then\n                    indices(i,1) = j\n                    indices(i,2) = j + len(words(i)) - 1\n                    exit\n                end if\n            end do\n        end do\n\n        indices = transpose(indices)\n        indices = merge(indices, -1, indices(:,1) < indices(:,2))\n        indices = merge(indices, -1, indices(:,1) == indices(:,2))\n        indices = merge(indices, -1, indices(:,1) > indices(:,2))\n\n    end subroutine solve\n\nend program main",
  "1071": "program main\n    implicit none\n\n    character(len=:), allocatable :: str1, str2, x\n    integer :: i\n\n    ! Example 1\n    str1 = \"ABCABC \"\n    str2 = \"ABC \"\n    call solve(str1, str2, x)\n    write (*, '(A)') trim(x)\n\n    ! Example 2\n    str1 = \"ABABAB \"\n    str2 = \"ABAB \"\n    call solve(str1, str2, x)\n    write (*, '(A)') trim(x)\n\n    ! Example 3\n    str1 = \"LEET \"\n    str2 = \"CODE \"\n    call solve(str1, str2, x)\n    write (*, '(A)') trim(x)\n\ncontains\n\n    subroutine solve(str1, str2, x)\n        implicit none\n        character(len=*), intent(in) :: str1, str2\n        character(len=:), allocatable, intent(out) :: x\n        integer :: n\n\n        n = len(str2)\n        do while (n > 0)\n            if (index(str1, str2) /= 0 .and. index(str2, str2) == 0) then\n                x = str2\n                exit\n            end if\n            n = n - 1\n            str2 = str2 // str2\n        end do\n    end subroutine solve\n\nend program main",
  "1078": "program main\n    implicit none\n\n    character(len=:), allocatable :: text\n    character(len=:), allocatable :: first\n    character(len=:), allocatable :: second\n    character(len=:), allocatable :: third\n    integer :: i\n\n    call get_command_argument(1, text)\n    call get_command_argument(2, first)\n    call get_command_argument(3, second)\n\n    do i = 1, size(text)\n        if (index(text(i:), first // ' ' // second // ' ') > 0) then\n            third = trim(adjustl(text(i+size(first)+size(second):)))\n            print *, third\n        end if\n    end do\n\nend program main",
  "1085": "program main\n    implicit none\n\n    integer, parameter :: n = 8\n    integer, dimension(n) :: nums = (/ 34, 23, 1, 24, 75, 33, 54, 8 /)\n    integer :: i, min_index, sum_digits, result\n\n    ! find the index of the minimum element in nums\n    min_index = minloc(nums, dim=1)\n\n    ! calculate the sum of the digits of the minimum element\n    sum_digits = 0\n    do i = 1, len_trim(nums(min_index))\n        sum_digits = sum_digits + mod(nums(min_index), 10)\n        nums(min_index) = nums(min_index) / 10\n    end do\n\n    ! return 0 if the sum of the digits is odd, otherwise return 1\n    result = merge(0, 1, mod(sum_digits, 2) == 0)\n\n    print '(I0)', result\n\nend program main",
  "1086": "program main\n    implicit none\n\n    integer :: i, j, n\n    integer, allocatable :: ids(:), scores(:)\n    real(kind=8), allocatable :: result(:,:)\n\n    ! read input\n    read(*,*) n\n    allocate(ids(n))\n    allocate(scores(n))\n    do i = 1, n\n        read(*,*) ids(i), scores(i)\n    end do\n\n    ! solve problem\n    allocate(result(n,2))\n    do i = 1, n\n        result(i,1) = ids(i)\n        result(i,2) = topFiveAverage(scores(i))\n    end do\n\n    ! sort result by id in increasing order\n    call sort(result, n, 2, 1)\n\n    ! print output\n    do i = 1, n\n        write(*,fmt='(I4, F6.2)') result(i,1), result(i,2)\n    end do\n\ncontains\n\n    function topFiveAverage(score) result(average)\n        implicit none\n        integer, intent(in) :: score\n        integer :: topScores(5)\n        integer :: i, sum\n\n        ! find top five scores\n        topScores = score\n        do i = 2, size(topScores)\n            if (topScores(i-1) < score) then\n                topScores(i) = topScores(i-1)\n                topScores(i-1) = score\n            end if\n        end do\n\n        ! calculate top five average\n        sum = 0\n        do i = 1, size(topScores)\n            sum = sum + topScores(i)\n        end do\n        average = sum / 5\n    end function topFiveAverage\n\nend program main",
  "1089": "program main\n    implicit none\n\n    integer, parameter :: n = 8\n    integer :: arr(n)\n\n    arr = [1, 0, 2, 3, 0, 4, 5, 0]\n    call duplicate_zeros(arr)\n    write (*, '(*(I1, 1X))') arr\n\n    arr = [1, 2, 3]\n    call duplicate_zeros(arr)\n    write (*, '(*(I1, 1X))') arr\n\ncontains\n\nsubroutine duplicate_zeros(arr)\n    implicit none\n    integer, intent(inout) :: arr(:)\n    integer :: i, j\n\n    do i = 1, size(arr) - 1\n        if (arr(i) == 0) then\n            do j = size(arr), i + 1, -1\n                arr(j) = arr(j - 1)\n            end do\n            arr(i) = 0\n        end if\n    end do\nend subroutine duplicate_zeros\n\nend program main",
  "1099": "program main\n    implicit none\n\n    integer, parameter :: n = 9\n    integer, parameter :: k = 60\n    integer, dimension(n) :: nums = (/ 34, 23, 1, 24, 75, 33, 54, 8 /)\n    integer :: i, j, sum\n\n    do i = 1, n-1\n        do j = i+1, n\n            if (nums(i) + nums(j) == k) then\n                write (*, '(A, I0, A, I0, A)') 'Found ', nums(i), ' + ', nums(j), ' = ', k\n                exit\n            end if\n        end do\n    end do\n\nend program main",
  "1103": "program main\n\n! This program solves the following problem:\n! We distribute some number of candies, to a row of n = num_people people in the following way:\n! We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.\n! Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.\n! This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\n! Return an array (of length num_people and sum candies) that represents the final distribution of candies.\n\nimplicit none\ninteger :: i, j, k, n, m, num_people, candies\ninteger, dimension(:), allocatable :: ans\n\n! read input\nread(*,*) candies, num_people\n\n! allocate memory for the answer array\nallocate(ans(num_people))\n\n! initialize the answer array\ndo i = 1, num_people\n    ans(i) = 0\nend do\n\n! solve the problem\ndo while (candies > 0)\n    ! give candies to the first person\n    if (candies >= 1) then\n        ans(1) = ans(1) + 1\n        candies = candies - 1\n    end if\n    \n    ! move to the next person\n    i = 2\n    \n    ! give candies to the next person\n    do while (candies >= i .and. i <= num_people)\n        ans(i) = ans(i) + i\n        candies = candies - i\n        i = i + 1\n    end do\n    \n    ! move to the start of the row\n    i = 1\n    \n    ! give candies to the next person\n    do while (candies >= i .and. i <= num_people)\n        ans(i) = ans(i) + i\n        candies = candies - i\n        i = i + 1\n    end do\nend do\n\n! print the final distribution of candies\ndo i = 1, num_people\n    write(*,'(I0)',advance='no') ans(i)\nend do\nwrite(*,*)\n\nend program main",
  "1108": "program main\n    implicit none\n\n    character(len=32) :: address\n    character(len=32) :: defanged_address\n\n    ! Example 1\n    address = \"1.1.1.1\"\n    call solve(address, defanged_address)\n    print \"(A)\", trim(defanged_address)\n\n    ! Example 2\n    address = \"255.100.50.0\"\n    call solve(address, defanged_address)\n    print \"(A)\", trim(defanged_address)\n\ncontains\n\nsubroutine solve(address, defanged_address)\n    implicit none\n    character(len=*), intent(in) :: address\n    character(len=*), intent(out) :: defanged_address\n\n    integer :: i\n\n    do i = 1, len(address)\n        if (address(i:i) == \".\") then\n            defanged_address(i:i+2) = \"[.] \"\n        else\n            defanged_address(i:i) = address(i:i)\n        end if\n    end do\nend subroutine solve\n\nend program main",
  "1118": "program main\n    implicit none\n\n    integer :: year, month, days\n\n    ! Example 1\n    year = 1992\n    month = 7\n    days = get_days(year, month)\n    print '(A, I0, A, I0, A, I0)', 'Year ', year, ' Month ', month, &\n        ' has ', days, ' days.'\n\n    ! Example 2\n    year = 2000\n    month = 2\n    days = get_days(year, month)\n    print '(A, I0, A, I0, A, I0)', 'Year ', year, ' Month ', month, &\n        ' has ', days, ' days.'\n\n    ! Example 3\n    year = 1900\n    month = 2\n    days = get_days(year, month)\n    print '(A, I0, A, I0, A, I0)', 'Year ', year, ' Month ', month, &\n        ' has ', days, ' days.'\n\ncontains\n\n    function get_days(year, month) result(days)\n        implicit none\n        integer, intent(in) :: year, month\n        integer :: days\n\n        select case (month)\n            case (1, 3, 5, 7, 8, 10, 12)\n                days = 31\n            case (4, 6, 9, 11)\n                days = 30\n            case (2)\n                if (mod(year, 4) == 0) then\n                    days = 29\n                else\n                    days = 28\n                end if\n        end select\n    end function get_days\nend program main",
  "1119": "program main\n    implicit none\n\n    character(len=1000) :: s\n    character(len=1000) :: result\n\n    ! Example 1\n    s = \"leetcodeisacommunityforcoders\"\n    write(*,\"(A)\") trim(remove_vowels(s))\n\n    ! Example 2\n    s = \"aeiou \"\n    write(*,\"(A)\") trim(remove_vowels(s))\n\ncontains\n\n    function remove_vowels(str) result(new_str)\n        implicit none\n        character(len=*), intent(in) :: str\n        character(len=len(str)) :: new_str\n        integer :: i, j\n\n        do i = 1, len(str)\n            if (str(i:i) /= 'a' .and. &\n                str(i:i) /= 'e' .and. &\n                str(i:i) /= 'i' .and. &\n                str(i:i) /= 'o' .and. &\n                str(i:i) /= 'u') then\n                    new_str(j:j) = str(i:i)\n                    j = j + 1\n            end if\n        end do\n    end function remove_vowels\n\nend program main",
  "1122": "program main\n    implicit none\n\n    integer, parameter :: n = 10\n    integer, dimension(n) :: arr1, arr2, sorted_arr\n    integer :: i, j\n\n    ! Example 1\n    arr1 = [2, 3, 1, 3, 2, 4, 6, 7, 9, 2, 19]\n    arr2 = [2, 1, 4, 3, 9, 6]\n    call sort_array(arr1, arr2, sorted_arr)\n    write(*,*) 'Example 1:'\n    write(*,'(10I5)') sorted_arr\n\n    ! Example 2\n    arr1 = [28, 6, 22, 8, 44, 17]\n    arr2 = [22, 28, 8, 6]\n    call sort_array(arr1, arr2, sorted_arr)\n    write(*,*) 'Example 2:'\n    write(*,'(10I5)') sorted_arr\n\ncontains\n\n    subroutine sort_array(arr1, arr2, sorted_arr)\n        implicit none\n        integer, intent(in) :: arr1(:), arr2(:)\n        integer, intent(out) :: sorted_arr(:)\n        integer :: i, j, k\n\n        do i = 1, size(arr1)\n            do j = 1, size(arr2)\n                if (arr1(i) == arr2(j)) then\n                    exit\n                end if\n            end do\n            if (j > size(arr2)) then\n                sorted_arr(i) = arr1(i)\n            else\n                do k = i+1, size(arr1)\n                    if (arr1(k) < arr1(i)) then\n                        sorted_arr(i) = arr1(k)\n                        exit\n                    end if\n                end do\n            end if\n        end do\n\n        do i = 1, size(arr2)\n            do j = 1, size(arr1)\n                if (arr2(i) == arr1(j)) then\n                    exit\n                end if\n            end do\n            if (j > size(arr1)) then\n                sorted_arr(i) = arr2(i)\n            end if\n        end do\n\n    end subroutine sort_array\n\nend program main",
  "1128": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: dominoes\n    integer :: i, j, k, l, m, n_pairs\n\n    ! Example 1\n    dominoes = reshape([1, 2, 2, 1, 3, 4, 5, 6], shape=[n])\n    write(*,*) 'Example 1'\n    write(*,*) 'Input:'\n    do i = 1, size(dominoes)\n        write(*,'(A,I0,A,I0)') '[', dominoes(i,1), ',', dominoes(i,2), ']'\n    end do\n    call solve(dominoes)\n    write(*,*) 'Output:'\n    write(*,*) n_pairs\n\n    ! Example 2\n    dominoes = reshape([1, 2, 1, 2, 1, 2, 1, 2], shape=[n])\n    write(*,*) 'Example 2'\n    write(*,*) 'Input:'\n    do i = 1, size(dominoes)\n        write(*,'(A,I0,A,I0)') '[', dominoes(i,1), ',', dominoes(i,2), ']'\n    end do\n    call solve(dominoes)\n    write(*,*) 'Output:'\n    write(*,*) n_pairs\n\ncontains\n\n    subroutine solve(dominoes)\n        implicit none\n        integer, intent(inout) :: dominoes(:,:)\n        integer :: i, j, k, l, m, n_pairs\n\n        n_pairs = 0\n        do i = 1, size(dominoes)-1\n            do j = i+1, size(dominoes)\n                if (dominoes(i,1) == dominoes(j,2)) then\n                    if (dominoes(i,2) == dominoes(j,1)) then\n                        n_pairs = n_pairs + 1\n                    end if\n                else if (dominoes(i,2) == dominoes(j,2)) then\n                    if (dominoes(i,1) == dominoes(j,1)) then\n                        n_pairs = n_pairs + 1\n                    end if\n                end if\n            end do\n        end do\n    end subroutine solve\n\nend program main",
  "1133": "program main\n    implicit none\n\n    integer, parameter :: n = 9\n    integer, dimension(n) :: nums\n    integer :: i, j, max_occurence, unique_num\n\n    ! Example 1\n    nums = [5, 7, 3, 9, 4, 9, 8, 3, 1]\n    write (*, '(A, I0)') 'Example 1: ', largest_unique_integer(nums)\n\n    ! Example 2\n    nums = [9, 9, 8, 8]\n    write (*, '(A, I0)') 'Example 2: ', largest_unique_integer(nums)\n\ncontains\n\n    function largest_unique_integer(nums) result(unique_num)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: i, j, max_occurence, unique_num\n\n        max_occurence = 0\n        unique_num = -1\n\n        do i = 1, size(nums)\n            do j = 1, size(nums)\n                if (nums(i) == nums(j)) then\n                    max_occurence = max(max_occurence, 2)\n                end if\n            end do\n            if (max_occurence == 1) then\n                unique_num = nums(i)\n                exit\n            else\n                max_occurence = 0\n            end if\n        end do\n    end function largest_unique_integer\n\nend program main",
  "1134": "program armstrong_numbers\n    implicit none\n\n    integer :: n, k, i, sum\n    logical :: is_armstrong\n\n    ! Example 1:\n    n = 153\n    call check(is_armstrong(n), .true.)\n\n    ! Example 2:\n    n = 123\n    call check(is_armstrong(n), .false.)\n\ncontains\n\n    function is_armstrong(n) result(res)\n        implicit none\n        integer, value :: n\n        integer :: k, i, sum\n        logical :: res\n\n        k = floor(log10(real(n))) + 1\n        sum = 0\n        do i = 1, k\n            sum = sum + (mod(n, 10)**i)\n            n = n / 10\n        end do\n        res = sum == n\n    end function is_armstrong\n\n    subroutine check(actual, expected)\n        implicit none\n        logical, value :: actual, expected\n\n        if (actual .eqv. expected) then\n            write (*, '(A)') \"PASSED\"\n        else\n            write (*, '(A)') \"FAILED\"\n        end if\n    end subroutine check\nend program armstrong_numbers",
  "1137": "program tribonacci\n    implicit none\n\n    integer :: n, i, j, k\n    integer :: t(0:37)\n\n    ! initialize the first four terms of the sequence\n    t(0) = 0\n    t(1) = 1\n    t(2) = 1\n    t(3) = 2\n\n    do i=4,37\n        t(i) = t(i-1) + t(i-2) + t(i-3)\n    end do\n\n    print *, \"Enter n:\"\n    read(*,*) n\n\n    if (n < 0 .or. n > 37) then\n        print *, \"Invalid input\"\n    else\n        print *, \"T\", n, \"=\", t(n)\n    end if\n\nend program tribonacci",
  "1150": "program main\n    implicit none\n\n    integer, parameter :: n = 9\n    integer, dimension(n) :: nums\n    integer :: i, target\n    logical :: result\n\n    ! Example 1\n    nums = [2, 4, 5, 5, 5, 5, 5, 6, 6]\n    target = 5\n    result = majorityElement(nums, target)\n    write (unit=*, fmt='(L1)') result\n\n    ! Example 2\n    nums = [10, 100, 101, 101]\n    target = 101\n    result = majorityElement(nums, target)\n    write (unit=*, fmt='(L1)') result\n\ncontains\n\n    function majorityElement(nums, target) result(result_)\n        implicit none\n\n        integer, dimension(:), intent(in) :: nums\n        integer, intent(in) :: target\n        logical :: result_\n\n        integer :: count\n\n        count = 0\n        do i = 1, size(nums)\n            if (nums(i) == target) then\n                count = count + 1\n            end if\n        end do\n\n        result_ = count > size(nums) / 2\n    end function majorityElement\nend program main",
  "1154": "program main\n    implicit none\n\n    character(len=10) :: date\n    integer :: day_of_year\n\n    ! Example 1\n    date = \"2019-01-09\"\n    write(*,*) day_of_year(date), \"Expected: 9\"\n\n    ! Example 2\n    date = \"2019-02-10\"\n    write(*,*) day_of_year(date), \"Expected: 41\"\n\ncontains\n\n    function day_of_year(date) result(day)\n        implicit none\n        character(len=*), intent(in) :: date\n        integer :: day\n\n        ! Convert YYYY-MM-DD to YYYYMMDD\n        date = adjustl(date)\n        date(5:6) = date(4:5)\n        date(4:4) = \"-\"\n\n        ! Calculate day of year\n        day = 0\n        do while (date /= \"000000\")\n            select case (date(7:8))\n                case (\"01\",\"03\",\"05\",\"07\",\"08\",\"10\",\"12\")\n                    day = day + 31\n                case (\"04\",\"06\",\"09\",\"11\")\n                    day = day + 30\n                case (\"02\")\n                    if (mod(date(1:2),4)==0) then\n                        day = day + 29\n                    else\n                        day = day + 28\n                    end if\n            end select\n            date = date(9:)\n        end do\n    end function day_of_year\nend program main",
  "1160": "program main\n    implicit none\n\n    integer :: i, j\n    character(len=:), allocatable :: words(:)\n    character(len=:), allocatable :: chars\n    integer :: n_words, n_chars\n    integer :: result\n\n    ! read input\n    read(*,*) n_words\n    allocate(words(n_words))\n    do i = 1, n_words\n        read(*,*) words(i)\n    end do\n    read(*,*) n_chars\n    allocate(chars(n_chars))\n    do i = 1, n_chars\n        read(*,*) chars(i)\n    end do\n\n    ! solve problem\n    result = good_strings(words, chars)\n\n    ! print output\n    write(*,*) result\n\ncontains\n\n    function good_strings(words, chars) result(sum)\n        implicit none\n        character(len=*), intent(in) :: words(:)\n        character(len=*), intent(in) :: chars\n        integer :: sum\n        integer :: i, j\n\n        sum = 0\n        do i = 1, size(words)\n            do j = 1, len(words(i))\n                if (index(chars, words(i)(j:j)) /= 0) then\n                    sum = sum + len(words(i))\n                    exit\n                end if\n            end do\n        end do\n    end function good_strings\n\nend program main",
  "1165": "program main\n    implicit none\n\n    integer :: i, j, n, m\n    character(len=26) :: keyboard\n    character(len=*) :: word\n    integer :: time\n\n    ! read input\n    read(*,*) keyboard\n    read(*,*) word\n\n    ! solve problem\n    n = len_trim(word)\n    m = len_trim(keyboard)\n    time = 0\n    do i = 1, n\n        j = index(keyboard, word(i:i))\n        time = time + abs(i - j)\n    end do\n\n    ! print output\n    write(*,*) time\n\nend program main",
  "1175": "program main\n    implicit none\n\n    integer :: i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z\n    integer :: count, modulus\n    logical :: is_prime(100)\n\n    ! Modulus for the result\n    modulus = 1000000007\n\n    ! Initialize the array of primes\n    do i = 2, 100\n        is_prime(i) = .true.\n    end do\n\n    ! Mark non-primes\n    do i = 2, 100\n        if (is_prime(i)) then\n            j = i * i\n            do while (j <= 100)\n                is_prime(j) = .false.\n                j = j + i\n            end do\n        end if\n    end do\n\n    ! Count the number of permutations\n    count = 0\n    do i = 1, 100\n        if (is_prime(i)) then\n            count = count + 1\n        end if\n    end do\n\n    ! Output the result modulo the modulus\n    print '(I0)', count\n\nend program main",
  "1176": "program main\n    implicit none\n\n    integer :: i, j, k, n, lower, upper, points, total_points\n    integer, dimension(:), allocatable :: calories\n\n    ! read input\n    read(*,*) n\n    allocate(calories(n))\n    do i=1,n\n        read(*,*) calories(i)\n    end do\n    read(*,*) k\n    read(*,*) lower\n    read(*,*) upper\n\n    ! solve problem\n    points = 0\n    do i=1,n-k+1\n        total_points = 0\n        do j=i,i+k-1\n            total_points = total_points + calories(j)\n        end do\n        if (total_points < lower) then\n            points = points - 1\n        else if (total_points > upper) then\n            points = points + 1\n        end if\n    end do\n\n    ! print output\n    write(*,*) points\n\nend program main",
  "1180": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    integer :: n_substrings, i\n\n    ! Example 1\n    s = \"aaaba\"\n    print '(A)', solve(s)\n\n    ! Example 2\n    s = \"aaaaaaaaaa\"\n    print '(A)', solve(s)\n\ncontains\n\n    function solve(s) result(n_substrings)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: n_substrings, i, j\n        logical :: first_letter\n\n        n_substrings = 0\n        do i = 1, len(s)-1\n            first_letter = .true.\n            do j = i+1, len(s)\n                if (first_letter .and. s(j:j) == s(i:i)) then\n                    first_letter = .false.\n                else if (.not. first_letter .and. s(j:j) /= s(i:i)) then\n                    exit\n                end if\n            end do\n            if (first_letter) then\n                n_substrings = n_substrings + 1\n            end if\n        end do\n    end function solve\n\nend program main",
  "1184": "program main\n    implicit none\n\n    integer :: n, start, destination, distance(10000), min_dist\n    character(len=100) :: input_string\n\n    ! read input\n    read(*, '(I5)') n\n    do i = 1, n\n        read(*, '(I5)') distance(i)\n    end do\n    read(*, '(I5)') start\n    read(*, '(I5)') destination\n\n    ! solve problem\n    min_dist = solve(n, distance, start, destination)\n\n    ! print output\n    write (*, '(I5)') min_dist\n\ncontains\n\n    function solve(n, distance, start, destination) result(min_dist)\n        implicit none\n        integer, intent(in) :: n, start, destination\n        integer, intent(in) :: distance(n)\n        integer :: i, j, k, l, min_dist\n\n        ! initialize variables\n        min_dist = huge(1_8)\n\n        ! loop over all possible combinations of start and destination\n        do i = 0, n - 1\n            do j = 0, n - 1\n                if (i /= j) then\n                    k = modulo(j + 1, n)\n                    l = modulo(k + 1, n)\n\n                    ! check if current combination is valid\n                    if ((i == start .and. j == destination) .or. &\n                        (i == destination .and. j == start)) then\n                        ! calculate distance\n                        min_dist = min(min_dist, distance(i) + distance(j) + distance(k) + distance(l))\n                    end if\n                end if\n            end do\n        end do\n\n        ! return solution\n        min_dist = min_dist / 2\n    end function solve\nend program main",
  "1185": "program main\n    implicit none\n\n    integer :: day, month, year\n    character(len=9) :: answer\n\n    call get_answer(day, month, year, answer)\n    print '(A)', trim(answer)\n\ncontains\n\nsubroutine get_answer(day, month, year, answer)\n    implicit none\n    integer, intent(in) :: day, month, year\n    character(len=9), intent(out) :: answer\n\n    select case (day + 1 + (month-1)*31 + (year-1971)*365)\n        case (0, 6)\n            answer = \"Saturday \"\n        case (1, 7)\n            answer = \"Sunday \"\n        case (2, 8)\n            answer = \"Monday \"\n        case (3, 9)\n            answer = \"Tuesday \"\n        case (4, 10)\n            answer = \"Wednesday \"\n        case (5, 11)\n            answer = \"Thursday \"\n        case default\n            answer = \"Friday \"\n    end select\nend subroutine get_answer\n\nend program main",
  "1189": "program main\n    implicit none\n\n    integer :: i, j, k, n, m\n    character(len=100) :: text\n    character(len=7), parameter :: balloon = \"balloon \"\n    integer, allocatable :: dp(:,:)\n    integer :: max_instances\n\n    ! read input\n    read(*,'(A)') text\n\n    ! allocate dynamic memory for dp array\n    n = len(text)\n    allocate(dp(n+1,n))\n\n    ! initialize dp array\n    do i = 1, n+1\n        dp(i,1) = 1\n    end do\n    do i = 2, n\n        do j = 2, n\n            if (text(j-1:j-1) == balloon(i-1:i-1)) then\n                dp(j,i) = dp(j-1,i-1) + 1\n            else\n                dp(j,i) = max(dp(j-1,i), dp(j,i-1))\n            end if\n        end do\n    end do\n\n    ! find maximum number of instances\n    max_instances = 0\n    do i = 1, n\n        do j = 1, n\n            if (dp(j,i) > max_instances) then\n                max_instances = dp(j,i)\n            end if\n        end do\n    end do\n\n    ! print result\n    write(*,*) max_instances\n\n    ! deallocate dynamic memory\n    deallocate(dp)\n\nend program main",
  "1196": "program main\n    implicit none\n\n    integer :: i, n, weight(5), max_apples\n\n    ! Example 1\n    weight = [100, 200, 150, 1000]\n    print '(A, I0)', 'Example 1: ', max_apples(weight)\n\n    ! Example 2\n    weight = [900, 950, 800, 1000, 700, 800]\n    print '(A, I0)', 'Example 2: ', max_apples(weight)\n\ncontains\n\n    function max_apples(weight) result(max_apples_)\n        implicit none\n        integer, intent(in) :: weight(:)\n        integer :: max_apples_, total_weight\n\n        total_weight = 0\n        do i = 1, size(weight)\n            if (total_weight + weight(i) > 5000) then\n                exit\n            end if\n            total_weight = total_weight + weight(i)\n        end do\n        max_apples_ = i - 1\n    end function max_apples\n\nend program main",
  "1200": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: arr\n    integer, dimension(:, :), allocatable :: pairs\n    integer :: i, j, k\n\n    ! Example 1\n    arr = [4, 2, 1, 3]\n    call solve(arr, pairs)\n    write (*, '(A)') 'Example 1:'\n    do i = 1, size(pairs, 1)\n        write (*, '(2I5)') pairs(i, :)\n    end do\n    deallocate (pairs)\n\n    ! Example 2\n    arr = [1, 3, 6, 10, 15]\n    call solve(arr, pairs)\n    write (*, '(A)') 'Example 2:'\n    do i = 1, size(pairs, 1)\n        write (*, '(2I5)') pairs(i, :)\n    end do\n    deallocate (pairs)\n\n    ! Example 3\n    arr = [3, 8, -10, 23, 19, -4, -14, 27]\n    call solve(arr, pairs)\n    write (*, '(A)') 'Example 3:'\n    do i = 1, size(pairs, 1)\n        write (*, '(2I5)') pairs(i, :)\n    end do\n    deallocate (pairs)\n\ncontains\n\n    subroutine solve(arr, pairs)\n        implicit none\n        integer, intent(in) :: arr(:)\n        integer, allocatable, intent(out) :: pairs(:, :)\n        integer :: min_diff, diff, i, j, k\n\n        allocate (pairs(size(arr), 2))\n\n        min_diff = huge(min_diff)\n        do i = 1, size(arr) - 1\n            do j = i + 1, size(arr)\n                diff = abs(arr(j) - arr(i))\n                if (diff < min_diff) then\n                    min_diff = diff\n                    pairs(:, :) = reshape(",
  "1207": "program main\n    implicit none\n\n    integer, parameter :: n = 10\n    integer, dimension(n) :: arr\n    logical :: result\n\n    ! Example 1\n    arr = [1, 2, 2, 1, 1, 3]\n    write (*, '(A)') 'Example 1:'\n    write (*, '(A)') 'Input:  ', arr\n    result = uniqueOccurrences(arr)\n    write (*, '(A, L1)') 'Output: ', result\n    write (*, *)\n\n    ! Example 2\n    arr = [1, 2]\n    write (*, '(A)') 'Example 2:'\n    write (*, '(A)') 'Input:  ', arr\n    result = uniqueOccurrences(arr)\n    write (*, '(A, L1)') 'Output: ', result\n    write (*, *)\n\n    ! Example 3\n    arr = [-3, 0, 1, -3, 1, 1, 1, -3, 10, 0]\n    write (*, '(A)') 'Example 3:'\n    write (*, '(A)') 'Input:  ', arr\n    result = uniqueOccurrences(arr)\n    write (*, '(A, L1)') 'Output: ', result\n    write (*, *)\n\ncontains\n\n    function uniqueOccurrences(arr) result(result_)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        logical :: result_\n\n        integer :: i, j\n        integer :: count\n\n        do i = 1, size(arr) - 1\n            count = 0\n            do j = i + 1, size(arr)\n                if (arr(i) == arr(j)) then\n                    count = count + 1\n                end if\n            end do\n            if (count > 0) then\n                result_ = .false.\n                return\n            end if\n        end do\n\n        result_ = .true.\n    end function uniqueOccurrences\n\nend program main",
  "1213": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 5\n    integer, dimension(n) :: arr1, arr2, arr3\n    integer, dimension(:), allocatable :: result\n    integer :: i, j, k\n\n    ! Example 1\n    arr1 = [1, 2, 3, 4, 5]\n    arr2 = [1, 2, 5, 7, 9]\n    arr3 = [1, 3, 4, 5, 8]\n    call solve(arr1, arr2, arr3, result)\n    write (unit=error_unit, fmt='(*(I0, 1X))') result\n\n    ! Example 2\n    arr1 = [197, 418, 523, 876, 1356]\n    arr2 = [501, 880, 1593, 1710, 1870]\n    arr3 = [521, 682, 1337, 1395, 1764]\n    call solve(arr1, arr2, arr3, result)\n    write (unit=error_unit, fmt='(*(I0, 1X))') result\n\ncontains\n\n    subroutine solve(arr1, arr2, arr3, result)\n        implicit none\n        integer, dimension(:), intent(in) :: arr1\n        integer, dimension(:), intent(in) :: arr2\n        integer, dimension(:), intent(in) :: arr3\n        integer, dimension(:), allocatable, intent(out) :: result\n        integer :: i, j, k\n\n        allocate (result(size(arr1)))\n\n        i = 1\n        j = 1\n        k = 1\n        do while (i <= size(arr1) .and. j <= size(arr2) .and. k <= size(arr3))\n            if (arr1(i) == arr2(j) .and. arr1(i) == arr3(k)) then\n                result(i) = arr1(i)\n                i = i + 1\n                j = j + 1\n                k = k + 1\n            else if (arr1(i) < arr2(j)) then\n                i = i + 1\n            else if (arr1(i) > arr3(k)) then\n                k = k + 1\n            else\n                stop \"Error: unexpected condition\"\n            end if\n        end do\n\n        result = result(1:i-1)\n    end subroutine solve\n\nend program main",
  "1217": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: position = (/ 1, 2, 3 /)\n    integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n    integer :: cost\n    integer :: minCost\n\n    ! Example 1\n    write (*,*) \"Example 1:\"\n    write (*,*) \"position = \", position\n    cost = 0\n    call moveChips(position, cost)\n    write (*,*) \"minCost = \", minCost\n\n    ! Example 2\n    write (*,*) \"Example 2:\"\n    write (*,*) \"position = \", position\n    cost = 0\n    call moveChips(position, cost)\n    write (*,*) \"minCost = \", minCost\n\n    ! Example 3\n    write (*,*) \"Example 3:\"\n    write (*,*) \"position = \", position\n    cost = 0\n    call moveChips(position, cost)\n    write (*,*) \"minCost = \", minCost\n\ncontains\n\n    subroutine moveChips(position, cost)\n        implicit none\n        integer, intent(inout) :: position(:)\n        integer, intent(inout) :: cost\n        integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n\n        do i = 1, size(position)\n            if (position(i) == position(i+1)) then\n                cost = cost + 1\n            else if (position(i) == position(i+1)+1 .or. position(i) == position(i+1)-1) then\n                cost = cost + 2\n            end if\n        end do\n\n        minCost = cost\n    end subroutine moveChips\n\nend program main",
  "1221": "program main\n    implicit none\n\n    character(len=1000) :: s\n    integer :: n, i, j, count_l, count_r\n\n    read(*,*) s\n    n = len(trim(s))\n\n    do i = 1, n\n        if (s(i:i) == 'L') then\n            count_l = count_l + 1\n        else if (s(i:i) == 'R') then\n            count_r = count_r + 1\n        end if\n    end do\n\n    if (count_l == count_r) then\n        print *, 1\n    else\n        print *, 0\n    end if\n\nend program main",
  "1228": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: arr\n    integer :: i\n\n    ! Example 1\n    arr = [5, 7, 11, 13]\n    call solve(arr)\n    write (*, '(I0)') arr(3)\n\n    ! Example 2\n    arr = [15, 13, 12]\n    call solve(arr)\n    write (*, '(I0)') arr(2)\n\ncontains\n\n    subroutine solve(arr)\n        implicit none\n        integer, dimension(:), intent(inout) :: arr\n        integer :: diff, i\n\n        diff = arr(2) - arr(1)\n        do i = 2, size(arr) - 1\n            if (arr(i + 1) - arr(i) /= diff) then\n                arr(i) = arr(i) + diff\n                exit\n            end if\n        end do\n    end subroutine solve\nend program main",
  "1232": "program main\n    implicit none\n\n    integer, parameter :: dp = selected_real_kind(15)\n\n    real(dp), allocatable :: coordinates(:, :)\n    integer :: n, i, j\n    logical :: is_straight\n\n    ! read input\n    read(*, *) n\n    allocate(coordinates(n, 2))\n    do i = 1, n\n        read(*, *) coordinates(i, :)\n    end do\n\n    ! check if points make a straight line\n    is_straight = .true.\n    do i = 2, n\n        do j = 1, i-1\n            if (abs(coordinates(i, 1) - coordinates(j, 1)) > epsilon(1._dp)) then\n                is_straight = .false.\n                exit\n            end if\n        end do\n        if (.not. is_straight) exit\n    end do\n\n    ! print result\n    write(*, '(L1)') is_straight\n\nend program main",
  "1243": "program main\n    implicit none\n\n    integer, parameter :: n = 100\n    integer :: i, j, k\n    integer :: arr(n)\n    logical :: changed\n\n    ! Example 1\n    arr = [6, 2, 3, 4]\n    call solve(arr)\n    write(*,*) \"Example 1:\"\n    write(*,'(10I3)') arr\n\n    ! Example 2\n    arr = [1, 6, 3, 4, 3, 5]\n    call solve(arr)\n    write(*,*) \"Example 2:\"\n    write(*,'(10I3)') arr\n\ncontains\n\n    subroutine solve(arr)\n        implicit none\n        integer, intent(inout) :: arr(:)\n        integer :: i, j, k\n        logical :: changed\n\n        do while (changed)\n            changed = .false.\n            do i = 2, size(arr)-1\n                if (arr(i) < arr(i-1) .and. arr(i) < arr(i+1)) then\n                    arr(i) = arr(i) + 1\n                    changed = .true.\n                end if\n                if (arr(i) > arr(i-1) .and. arr(i) > arr(i+1)) then\n                    arr(i) = arr(i) - 1\n                    changed = .true.\n                end if\n            end do\n        end do\n    end subroutine solve\n\nend program main",
  "1252": "program main\n    ! Solves the problem described in the comment block\n    implicit none\n\n    integer :: m, n, i, j, ri, ci, num_odd\n    integer, dimension(:, :), allocatable :: matrix\n    integer, dimension(:, :), allocatable :: indices\n\n    ! Read input\n    read *, m, n\n    allocate(matrix(m, n))\n    allocate(indices(size(matrix, 1), size(matrix, 2)))\n    do i = 1, size(matrix, 1)\n        do j = 1, size(matrix, 2)\n            read *, matrix(i, j)\n        end do\n    end do\n    do i = 1, size(indices, 1)\n        read *, indices(i, :)\n    end do\n\n    ! Apply increments\n    do i = 1, size(indices, 1)\n        ri = indices(i, 1)\n        ci = indices(i, 2)\n        matrix(ri, :) = matrix(ri, :) + 1\n        matrix(:, ci) = matrix(:, ci) + 1\n    end do\n\n    ! Count number of odd values\n    num_odd = 0\n    do i = 1, size(matrix, 1)\n        do j = 1, size(matrix, 2)\n            if (mod(matrix(i, j), 2) /= 0) then\n                num_odd = num_odd + 1\n            end if\n        end do\n    end do\n\n    ! Output result\n    write (*, '(I0)') num_odd\n\nend program main",
  "1260": "program main\n    implicit none\n\n    integer, parameter :: m = 3, n = 3\n    integer, dimension(m, n) :: grid\n    integer :: i, j, k\n\n    ! Example 1\n    grid = reshape([1, 2, 3, 4, 5, 6, 7, 8, 9], shape=[m, n])\n    k = 1\n    call shift(grid, k)\n    write(*, \"(A)\") \"Example 1:\"\n    do i = 1, m\n        write(*, \"(A)\", advance=\"no\") \"[\"\n        do j = 1, n\n            write(*, \"(I2)\", advance=\"no\") grid(i, j)\n            if (j < n) then\n                write(*, \"(A)\", advance=\"no\") \", \"\n            end if\n        end do\n        write(*, \"(A)\") \"]\"\n        if (i < m) then\n            write(*, \"(A)\") \"\"\n        end if\n    end do\n\n    ! Example 2\n    grid = reshape([3, 8, 1, 9, 19, 7, 2, 5, 4, 6, 11, 10, 12, 0, 21, 13], &\n                   shape=[m, n])\n    k = 4\n    call shift(grid, k)\n    write(*, \"(A)\") \"Example 2:\"\n    do i = 1, m\n        write(*, \"(A)\", advance=\"no\") \"[\"\n        do j = 1, n\n            write(*, \"(I2)\", advance=\"no\") grid(i, j)\n            if (j < n) then\n                write(*, \"(A)\", advance=\"no\") \", \"\n            end if\n        end do\n        write(*, \"(A)\") \"]\"\n        if (i < m) then\n            write(*, \"(A)\") \"\"\n        end if\n    end do\n\n    ! Example 3\n    grid = reshape([1, 2, 3, 4, 5, 6, 7, 8, 9], shape=[m, n])\n    k = 9\n    call shift(grid, k)\n    write(*, \"(A)\") \"Example 3:\"\n    do i = 1, m\n        write(*, \"(A)\", advance=\"no\") \"[\"\n        do j = 1, n\n            write(*, \"(I2)\", advance=\"no\") grid(i, j)\n            if (j < n) then\n                write(*, \"(A)\", advance=\"no\") \", \"\n            end if\n        end do\n        write(*, \"(A)\") \"]\"\n        if (i < m) then\n            write(*, \"(A)\") \"\"\n        end if\n    end do\n\ncontains\n\n    subroutine shift(grid, k)\n        implicit none\n        integer, dimension(:, :), intent(inout) :: grid\n        integer, intent(in) :: k\n        integer :: i, j, temp\n\n        do while (k > 0)\n            ! Shift elements in each row\n            do i = 1, size(grid, 1)\n                ! Move element at grid[i][j] to grid[i][j + 1]\n                if (j < size(grid, 2)) then\n                    temp = grid(i, j)\n                    grid(i, j) = grid(i, j + 1)\n                    grid(i, j + 1) = temp\n                end if\n\n                ! Move element at grid[i][n - 1] to grid[i + 1][0]\n                if (i < size(grid, 1) .and. j == size(grid, 2)) then\n                    temp = grid(i, j)\n                    grid(i, j) = grid(i + 1, 0)\n                    grid(i + 1, 0) = temp\n                end if\n\n                ! Move element at grid[m - 1][n - 1] to grid[0][0]\n                if (i == size(grid, 1) .and. j == size(grid, 2)) then\n                    temp = grid(i, j)\n                    grid(i, j) = grid(0, 0)\n                    grid(0, 0) = temp\n                end if\n            end",
  "1266": "program main\n\n! This program solves the following problem:\n!\n! On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi].\n! Return the minimum time in seconds to visit all the points in the order given by points.\n!\n! You can move according to these rules:\n!\n! - In 1 second, you can either:\n!   - move vertically by one unit,\n!   - move horizontally by one unit, or\n!   - move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).\n! - You have to visit the points in the same order as they appear in the array.\n! - You are allowed to pass through points that appear later in the order, but these do not count as visits.\n!\n! Example 1:\n! Input: points = [[1,1], [3,4], [-1,0]]\n! Output: 7\n! Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]\n! Time from [1,1] to [3,4] = 3 seconds\n! Time from [3,4] to [-1,0] = 4 seconds\n! Total time = 7 seconds\n!\n! Example 2:\n! Input: points = [[3,2], [-2,2]]\n! Output: 5\n!\n! Constraints:\n! - points.length == n\n! - 1 <= n <= 100\n! - points[i].length == 2\n! - -1000 <= points[i][0], points[i][1] <= 1000\n\nimplicit none\n\ninteger :: i, j, k, n, xi, yi, xj, yj, xk, yk, t, t_min\nreal :: d, d_min\nlogical :: visited(100, 100)\ninteger, allocatable :: points(:, :)\n\nprint '(A)', 'Enter number of points:'\nread(*,*) n\nallocate(points(n, 2))\n\ndo i = 1, n\n    print '(A, I0, A)', 'Enter point ', i, ':'\n    read(*,*) xi, yi\n    points(i, :) = [xi, yi]\nend do\n\nt_min = huge(t_min)\n\ndo i = 1, n\n    do j = i + 1, n\n        if (.not. visited(i, j)) then\n            d = sqrt((points(i, 1) - points(j, 1))**2 + (points(i, 2) - points(j, 2))**2)\n            if (d < d_min) then\n                d_min = d\n                t = int(d_min)\n            end if\n        end if\n    end do\nend do\n\nif (t > t_min) then\n    print '(A, I0)', 'Minimum time: ', t\nelse\n    print '(A)', 'No solution'\nend if\n\ndeallocate(points)\n\ncontains\n\nfunction distance(x1, y1, x2, y2) result(d)\nimplicit none\ninteger, intent(in) :: x1, y1, x2, y2\nreal :: d\n\nd = sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\nend function distance\n\nend program main",
  "1271": "program main\n    implicit none\n\n    character(len=12) :: num\n    character(len=4) :: hexspeak\n\n    ! Example 1\n    num = \"257\"\n    write(*,*) \"Example 1:\"\n    write(*,*) \"Input: \", trim(num)\n    hexspeak = hexspeak_representation(num)\n    write(*,*) \"Output: \", trim(hexspeak)\n\n    ! Example 2\n    num = \"3\"\n    write(*,*) \"Example 2:\"\n    write(*,*) \"Input: \", trim(num)\n    hexspeak = hexspeak_representation(num)\n    write(*,*) \"Output: \", trim(hexspeak)\n\ncontains\n\n    function hexspeak_representation(num) result(hexspeak)\n        implicit none\n        character(len=*), intent(in) :: num\n        character(len=4) :: hexspeak\n        character(len=12) :: hexstring\n\n        hexstring = num\n        call toupper(hexstring)\n        hexspeak = \"\"\n        do i = 1, len_trim(hexstring)\n            select case (hexstring(i:i))\n                case (\"0\")\n                    hexspeak = hexspeak // \"O\"\n                case (\"1\")\n                    hexspeak = hexspeak // \"I\"\n                case default\n                    hexspeak = hexspeak // hexstring(i:i)\n            end select\n        end do\n\n        if (all(hexspeak == [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"I\", \"O\"])) then\n            hexspeak = trim(hexspeak)\n        else\n            hexspeak = \"ERROR \"\n        end if\n\n    end function hexspeak_representation\n\nend program main",
  "1275": "program tictactoe\n    implicit none\n\n    integer :: i, j, k, l, m, n\n    integer :: moves(9, 2)\n    character(len=1) :: grid(3, 3)\n    character(len=1) :: winner\n\n    ! Examples\n    moves(:, :) = reshape([&\n        & [0, 0], [2, 0], [1, 1], [2, 1], [2, 2],&\n        & [0, 0], [1, 1], [0, 1], [0, 2], [1, 0], [2, 0]], shape(moves))\n\n    do i = 1, size(moves, 1)\n        call solve(moves(i, :), grid, winner)\n        write(*, *) 'Move ', i, ':', moves(i, :)\n        write(*, *) 'Grid:'\n        do j = 1, size(grid, 1)\n            write(*, '(3A)') ((grid(j, k), k = 1, size(grid, 2)), new_line(''))\n        end do\n        write(*, *) 'Winner: ', winner\n    end do\n\ncontains\n\n    subroutine solve(move, grid, winner)\n        implicit none\n        integer, intent(in) :: move(2)\n        character(len=1), intent(inout) :: grid(3, 3)\n        character(len=1), intent(out) :: winner\n\n        integer :: row, col\n        logical :: found\n\n        row = move(1)\n        col = move(2)\n\n        if (grid(row, col) /= ' ') then\n            stop 'Invalid move'\n        end if\n\n        grid(row, col) = 'X'\n\n        found = .false.\n        do i = 1, size(grid, 1)\n            if (all(grid(i, :) == 'X')) then\n                winner = 'A'\n                found = .true.\n                exit\n            else if (all(grid(:, i) == 'X')) then\n                winner = 'A'\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            do i = 1, size(grid, 1) - 2\n                if (grid(i, i) == 'X' .and. grid(i + 1, i + 1) == 'X' .and. grid(i + 2, i + 2) == 'X') then\n                    winner = 'A'\n                    found = .true.\n                    exit\n                else if (grid(i, i) == 'X' .and. grid(i + 1, i + 1) == 'X' .and. grid(i + 2, i + 2) == 'X') then\n                    winner = 'A'\n                    found = .true.\n                    exit\n                end if\n            end do\n        end if\n\n        if (.not. found) then\n            do i = 1, size(grid, 1)\n                if (all(grid(i, :) == 'O')) then\n                    winner = 'B'\n                    found = .true.\n                    exit\n                else if (all(grid(:, i) == 'O')) then\n                    winner = 'B'\n                    found = .true.\n                    exit\n                end if\n            end do\n        end if\n\n        if (.not. found) then\n            do i = 1, size(grid, 1) - 2\n                if (grid(i, i) == 'O' .and. grid(i + 1, i + 1) == 'O' .and. grid(i + 2, i + 2) == 'O') then\n                    winner = 'B'\n                    found = .true.\n                    exit\n                else if (grid(i, i) == 'O' .and. grid(i + 1, i + 1) == 'O' .and. grid(i + 2, i + 2) == 'O') then\n                    winner = 'B'\n                    found = .true.\n                    exit\n                end if\n            end do\n        end if\n\n        if (.not. found) then\n            if (all",
  "1281": "program main\n    implicit none\n\n    integer, parameter :: n = 234\n    integer :: result\n\n    result = digit_product_minus_digit_sum(n)\n    write (*, '(I0)') result\n\ncontains\n\n    function digit_product_minus_digit_sum(n) result(diff)\n        implicit none\n        integer, intent(in) :: n\n        integer :: diff, digit_product, digit_sum\n\n        digit_product = 1\n        digit_sum = 0\n\n        do while (n > 0)\n            digit_product = digit_product * mod(n, 10)\n            digit_sum = digit_sum + mod(n, 10)\n            n = n / 10\n        end do\n\n        diff = digit_product - digit_sum\n    end function digit_product_minus_digit_sum\n\nend program main",
  "1287": "program main\n    implicit none\n\n    integer, parameter :: n = 9\n    integer, dimension(n) :: sorted = (/ 1, 2, 2, 6, 6, 6, 6, 7, 10 /)\n    integer :: i, j, k, l, m, n, o\n    integer :: result\n\n    ! Example 1\n    write (*, '(A)') 'Example 1:'\n    write (*, '(A)') 'arr = [1,2,2,6,6,6,6,7,10]'\n    result = find_most_frequent(sorted)\n    write (*, '(A, I0)') 'result = ', result\n    write (*, *)\n\n    ! Example 2\n    write (*, '(A)') 'Example 2:'\n    write (*, '(A)') 'arr = [1,1]'\n    result = find_most_frequent(sorted)\n    write (*, '(A, I0)') 'result = ', result\n    write (*, *)\n\ncontains\n\n    function find_most_frequent(sorted) result(res)\n        implicit none\n        integer, intent(in) :: sorted(:)\n        integer :: res\n        integer :: i, j, k, l, m, n, o\n\n        do i = 1, size(sorted) - 1\n            if (sorted(i+1) == sorted(i)) then\n                cycle\n            else\n                exit\n            end if\n        end do\n\n        res = sorted(i)\n    end function find_most_frequent\n\nend program main",
  "1290": "program main\n    ! Solves the problem described in the comment block\n    implicit none\n\n    type :: Node\n        integer :: value\n        type(Node), pointer :: next => null()\n    end type\n\n    type(Node), pointer :: head => null(), current => null()\n    integer :: i, n, dec_val\n\n    ! Read input\n    read(*,*) n\n    allocate(head)\n    head%value = 0\n    do i=2,n+1\n        allocate(current)\n        current%value = 0\n        if (i <= n) then\n            read(*,*) current%value\n        end if\n        current%next => head\n        head => current\n    end do\n\n    ! Solve problem\n    dec_val = solve(head)\n\n    ! Output result\n    write(*,*) dec_val\n\ncontains\n\n    function solve(head) result(dec_val)\n        implicit none\n        type(Node), pointer :: head\n        integer :: dec_val\n\n        dec_val = 0\n        do while (associated(head))\n            dec_val = dec_val * 2 + head%value\n            head => head%next\n        end do\n    end function\n\nend program",
  "1295": "program main\n    ! Solve the problem described in the task\n    implicit none\n\n    integer :: i, n\n    integer, parameter :: nums(5) = [12, 345, 2, 6, 7896]\n    integer, parameter :: expected_result = 2\n\n    print '(A)', 'Testing example 1:'\n    call test_example(nums, expected_result)\n\n    print '(A)', 'Testing example 2:'\n    n = size(nums)\n    allocate(nums(n+1))\n    nums(n+1) = 555\n    call test_example(nums, 1)\n\ncontains\n\n    subroutine test_example(nums, expected_result)\n        implicit none\n        integer, intent(in) :: nums(:), expected_result\n        integer :: result\n\n        result = count_even_digits(nums)\n        if (result == expected_result) then\n            print '(A,I0)', 'Passed! Result is ', result\n        else\n            print '(A,I0)', 'Failed! Expected result is ', expected_result\n        end if\n    end subroutine test_example\n\n    function count_even_digits(nums) result(count)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: count, digit, i\n\n        count = 0\n        do i = 1, size(nums)\n            digit = modulo(nums(i), 10)\n            if (digit == 0 .or. digit == 2 .or. digit == 4 .or. &\n                digit == 6 .or. digit == 8) then\n                count = count + 1\n            end if\n        end do\n    end function count_even_digits\n\nend program main",
  "1299": "program main\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: arr\n    integer :: i\n\n    ! Example 1\n    arr = [17, 18, 5, 4, 6, 1]\n    call solve(arr)\n    write (*, '(A)') 'Example 1:'\n    do i = 1, size(arr)\n        write (*, '(I2)', advance='no') arr(i)\n    end do\n    write (*, *) ''\n\n    ! Example 2\n    arr = [400]\n    call solve(arr)\n    write (*, '(A)') 'Example 2:'\n    do i = 1, size(arr)\n        write (*, '(I2)', advance='no') arr(i)\n    end do\n    write (*, *) ''\n\ncontains\n\n    subroutine solve(arr)\n        implicit none\n        integer, intent(inout) :: arr(:)\n        integer :: i, j\n\n        do i = 1, size(arr) - 1\n            j = maxloc(arr(i+1:size(arr)), dim=1) + i - 1\n            arr(i) = arr(j)\n        end do\n        arr(size(arr)) = -1\n    end subroutine solve\n\nend program main",
  "1304": "program main\n    implicit none\n\n    integer :: n\n    integer, allocatable :: arr(:)\n\n    call get_arguments(n)\n\n    allocate(arr(n))\n\n    arr = solve(n)\n\n    write(*,*) 'Solution:'\n    write(*,*) arr\n\ncontains\n\n    function solve(n) result(arr)\n        implicit none\n        integer, value :: n\n        integer, dimension(:), allocatable :: arr\n\n        integer :: i\n\n        do i = 1, n\n            arr(i) = -i\n        end do\n    end function solve\n\n    subroutine get_arguments(n)\n        implicit none\n        integer, intent(out) :: n\n\n        character(len=100) :: buffer\n        integer :: status\n\n        read(*,fmt='(A)',iostat=status) buffer\n        if (status /= 0) then\n            stop 'Error reading input'\n        end if\n\n        read(buffer,fmt=*) n\n    end subroutine get_arguments\nend program main",
  "1309": "program main\n    implicit none\n\n    character(len=:), allocatable :: s, result\n\n    s = \"10#11#12\"\n    print \"(A)\", solve_problem(s)\n\n    s = \"1326#\"\n    print \"(A)\", solve_problem(s)\n\ncontains\n\n    function solve_problem(s) result(result)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j, k\n        character(len=1) :: c\n        character(len=:), allocatable :: result\n\n        allocate(character(len=size(s)) :: result)\n\n        do i = 1, size(s)\n            c = s(i:i)\n            if (c >= 'a' .and. c <= 'i') then\n                result(i:i) = char(ichar('1') + ichar(c) - ichar('a'))\n            else if (c >= 'j' .and. c <= 'z') then\n                result(i:i) = char(ichar('10#') + ichar(c) - ichar('j'))\n            end if\n        end do\n\n    end function solve_problem\n\nend program main",
  "1313": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums\n    integer, dimension(n) :: expected\n    integer, dimension(:), allocatable :: actual\n\n    nums = [1, 2, 3, 4]\n    expected = [2, 4, 4, 4]\n    call test_case(nums, expected)\n\n    nums = [1, 1, 2, 3]\n    expected = [1, 3, 3]\n    call test_case(nums, expected)\n\ncontains\n\n    subroutine test_case(nums, expected)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, dimension(:), intent(in) :: expected\n        integer, dimension(:), allocatable :: actual\n\n        allocate(actual, source=decompress(nums))\n\n        if (size(actual) /= size(expected)) then\n            write (*, '(\"Test case failed: \", \"Expected size:\", i0, &\n                          &\" Actual size:\", i0)') size(expected), size(actual)\n            stop 1\n        end if\n\n        if (any(actual /= expected)) then\n            write (*, '(\"Test case failed: \", \"Expected:\", *(i0, \",\"), &\n                          &\" Actual:\", *(i0, \",\"))') expected, actual\n            stop 1\n        end if\n\n        deallocate(actual)\n    end subroutine test_case\n\n    function decompress(nums) result(decompressed)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, dimension(:), allocatable :: decompressed\n        integer :: i, j, k, freq, val\n\n        k = 0\n        do i = 1, size(nums), 2\n            freq = nums(i)\n            val = nums(i + 1)\n            do j = 1, freq\n                k = k + 1\n                decompressed(k) = val\n            end do\n        end do\n    end function decompress\nend program main",
  "1317": "program main\n    implicit none\n\n    integer :: n, a, b\n\n    n = 2\n    call solve(n, a, b)\n    print '(I0, \" \", I0)', a, b\n\n    n = 11\n    call solve(n, a, b)\n    print '(I0, \" \", I0)', a, b\n\ncontains\n\n    subroutine solve(n, a, b)\n        implicit none\n        integer, intent(in) :: n\n        integer, intent(out) :: a, b\n\n        if (mod(n, 2) == 0) then\n            a = n / 2\n            b = n - a\n        else\n            a = (n - 1) / 2\n            b = n - a\n        end if\n    end subroutine solve\nend program main",
  "1323": "program main\n    implicit none\n\n    integer, parameter :: num = 9669\n    integer :: max_number\n\n    max_number = solve(num)\n    print '(I0)', max_number\n\ncontains\n\n    function solve(n) result(max_n)\n        implicit none\n        integer, intent(in) :: n\n        integer :: max_n\n        integer :: i, j, k, l\n\n        do i = 1, len(n)\n            if (n(i:i) == '6') then\n                n(i:i) = '9'\n                max_n = max(max_n, n)\n                n(i:i) = '6'\n            else if (n(i:i) == '9') then\n                n(i:i) = '6'\n                max_n = max(max_n, n)\n                n(i:i) = '9'\n            end if\n        end do\n    end function solve\nend program main",
  "1331": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer :: arr(n) = [40, 10, 20, 30]\n    integer :: i, j, k\n\n    do i = 1, n\n        write (*, '(I0)') arr(i)\n    end do\n\nend program main",
  "1332": "program main\n    implicit none\n\n    character(len=1000) :: s\n    integer :: nsteps\n\n    call get_command_argument(1, s)\n\n    nsteps = solve(s)\n\n    write (*, '(I0)') nsteps\n\ncontains\n\n    function solve(s) result(nsteps)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: nsteps\n        integer :: i, j\n\n        do while (any(s /= ''))\n            i = 1\n            j = len(s)\n            do while (i < j)\n                if (s(i:j) == s(i:j)(::-1)) then\n                    s(i:j) = ''\n                    exit\n                end if\n                i = i + 1\n            end do\n        end do\n\n        nsteps = len(trim(s))\n    end function solve\nend program main",
  "1337": "program main\n    implicit none\n\n    integer, parameter :: m = 5, n = 5\n    integer, dimension(m, n) :: mat\n    integer :: i, j, k\n    integer, dimension(:), allocatable :: weakest_rows\n\n    ! Example 1\n    mat = reshape([1, 1, 0, 0, 0, &\n                    1, 1, 1, 1, 0, &\n                    1, 0, 0, 0, 0, &\n                    1, 1, 0, 0, 0, &\n                    1, 1, 1, 1, 1], shape(mat))\n    k = 3\n    call solve(mat, k, weakest_rows)\n    write (*, '(*(I0, 1X))') weakest_rows\n\n    ! Example 2\n    mat = reshape([1, 0, 0, 0, &\n                    1, 1, 1, 1, &\n                    1, 0, 0, 0, &\n                    1, 0, 0, 0], shape(mat))\n    k = 2\n    call solve(mat, k, weakest_rows)\n    write (*, '(*(I0, 1X))') weakest_rows\n\ncontains\n\n    subroutine solve(mat, k, weakest_rows)\n        implicit none\n        integer, intent(in) :: m, n, k\n        integer, dimension(m, n), intent(in) :: mat\n        integer, dimension(:), allocatable, intent(out) :: weakest_rows\n        integer :: i, j, num_soldiers, min_num_soldiers, min_row_index\n\n        allocate(weakest_rows(k))\n\n        do i = 1, m\n            num_soldiers = count(mat(i, :) == 1)\n            if (i == 1 .or. num_soldiers < min_num_soldiers) then\n                min_num_soldiers = num_soldiers\n                min_row_index = i\n            end if\n        end do\n\n        weakest_rows(1) = min_row_index\n        do i = 2, k\n            min_row_index = 1\n            min_num_soldiers = mat(1, :)\n            do j = 2, m\n                if ((mat(j, :) < min_num_soldiers) .or. &\n                    (mat(j, :) == min_num_soldiers .and. j < min_row_index)) then\n                    min_num_soldiers = mat(j, :)\n                    min_row_index = j\n                end if\n            end do\n            weakest_rows(i) = min_row_index\n        end do\n\n    end subroutine solve\n\nend program main",
  "1342": "program main\n    implicit none\n\n    integer :: num, steps\n\n    ! Example 1\n    num = 14\n    write (*, '(A, I0, A, I0)') 'Example 1: ', num, ' -> ', solve(num)\n\n    ! Example 2\n    num = 8\n    write (*, '(A, I0, A, I0)') 'Example 2: ', num, ' -> ', solve(num)\n\n    ! Example 3\n    num = 123\n    write (*, '(A, I0, A, I0)') 'Example 3: ', num, ' -> ', solve(num)\n\ncontains\n\n    function solve(num) result(steps)\n        implicit none\n        integer, intent(in) :: num\n        integer :: steps\n\n        do while (num /= 0)\n            if (mod(num, 2) == 0) then\n                num = num / 2\n            else\n                num = num - 1\n            end if\n            steps = steps + 1\n        end do\n    end function solve\nend program main",
  "1346": "program main\n    implicit none\n\n    integer :: arr(4)\n    logical :: result\n\n    ! Example 1\n    arr = [10, 2, 5, 3]\n    write(*,*) 'Example 1:'\n    result = check_array(arr)\n    write(*,*) 'Result: ', result\n    write(*,*) ''\n\n    ! Example 2\n    arr = [3, 1, 7, 11]\n    write(*,*) 'Example 2:'\n    result = check_array(arr)\n    write(*,*) 'Result: ', result\n    write(*,*) ''\n\ncontains\n\n    function check_array(arr) result(result_)\n        implicit none\n        integer, intent(in) :: arr(:)\n        logical :: result_\n        integer :: i, j\n\n        do i = 1, size(arr) - 1\n            do j = i + 1, size(arr)\n                if (arr(i) == 2 * arr(j)) then\n                    result_ = .true.\n                    return\n                end if\n            end do\n        end do\n        result_ = .false.\n    end function check_array\n\nend program main",
  "1351": "program main\n    implicit none\n\n    integer, parameter :: m = 4, n = 4\n    integer :: grid(m, n)\n    integer :: i, j\n    integer :: negative_count\n\n    ! Example 1\n    grid(:, :) = reshape([4, 3, 2, -1, 3, 2, 1, -1, 1, 1, -1, -2, -1, -1, -2, -3], shape(grid))\n    write(*, '(A, I0)') 'Example 1: ', count_negatives(grid)\n\n    ! Example 2\n    grid(:, :) = reshape([3, 2, 1, 0, 1, 0], shape(grid))\n    write(*, '(A, I0)') 'Example 2: ', count_negatives(grid)\n\ncontains\n\n    function count_negatives(grid) result(negative_count)\n        implicit none\n        integer, intent(in) :: grid(:, :)\n        integer :: i, j\n        integer :: negative_count\n\n        negative_count = 0\n        do i = 1, size(grid, 1)\n            do j = 1, size(grid, 2)\n                if (grid(i, j) < 0) then\n                    negative_count = negative_count + 1\n                end if\n            end do\n        end do\n    end function count_negatives\n\nend program main",
  "1356": "program main\n    implicit none\n\n    integer, parameter :: n = 9\n    integer :: arr(n) = reshape([0, 1, 2, 3, 4, 5, 6, 7, 8], shape(arr))\n    integer :: i, j, tmp\n\n    call sort_by_bits(arr)\n\n    do i = 1, size(arr)\n        write(*, '(I0)', advance='no') arr(i)\n    end do\n    write(*,*)\n\ncontains\n\nsubroutine sort_by_bits(arr)\n    implicit none\n    integer, intent(inout) :: arr(:)\n    integer :: i, j, tmp\n\n    do i = 1, size(arr) - 1\n        do j = i + 1, size(arr)\n            if (count_bits(arr(i)) < count_bits(arr(j))) then\n                tmp = arr(i)\n                arr(i) = arr(j)\n                arr(j) = tmp\n            else if (count_bits(arr(i)) == count_bits(arr(j)) .and. arr(i) > arr(j)) then\n                tmp = arr(i)\n                arr(i) = arr(j)\n                arr(j) = tmp\n            end if\n        end do\n    end do\nend subroutine sort_by_bits\n\nfunction count_bits(x) result(res)\n    implicit none\n    integer, value :: x\n    integer :: res\n\n    res = 0\n    do while (x /= 0)\n        res = res + 1\n        x = x - 2 * (mod(x, 2))\n    end do\nend function count_bits\n\nend program main",
  "1360": "program main\n    implicit none\n\n    character(len=10) :: date1, date2\n    integer :: days_between\n\n    ! Example 1\n    date1 = \"2019-06-29\"\n    date2 = \"2019-06-30\"\n    write(*,*) 'Example 1:'\n    write(*,*) 'date1 = ', date1\n    write(*,*) 'date2 = ', date2\n    call count_days(date1, date2, days_between)\n    write(*,*) 'days_between = ', days_between\n    write(*,*) ''\n\n    ! Example 2\n    date1 = \"2020-01-15\"\n    date2 = \"2019-12-31\"\n    write(*,*) 'Example 2:'\n    write(*,*) 'date1 = ', date1\n    write(*,*) 'date2 = ', date2\n    call count_days(date1, date2, days_between)\n    write(*,*) 'days_between = ', days_between\n    write(*,*) ''\n\ncontains\n\n    subroutine count_days(date1, date2, days_between)\n        implicit none\n        character(len=10), intent(in) :: date1, date2\n        integer, intent(out) :: days_between\n\n        integer :: year1, month1, day1, year2, month2, day2\n\n        read(date1, fmt='(I4, 3(1X, I2))') year1, month1, day1\n        read(date2, fmt='(I4, 3(1X, I2))') year2, month2, day2\n\n        days_between = (year2 - year1) * 365 + &\n                       (month2 - month1) * 30 + &\n                       (day2 - day1)\n\n    end subroutine count_days\n\nend program main",
  "1365": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums\n    integer, dimension(n) :: ans\n\n    ! Example 1\n    nums = [8, 1, 2, 2, 3]\n    ans = solve(nums)\n    write (*, '(A)') 'Example 1:'\n    write (*, '(A)') 'Input:  ', nums\n    write (*, '(A)') 'Output: ', ans\n\n    ! Example 2\n    nums = [6, 5, 4, 8]\n    ans = solve(nums)\n    write (*, '(A)') 'Example 2:'\n    write (*, '(A)') 'Input:  ', nums\n    write (*, '(A)') 'Output: ', ans\n\n    ! Example 3\n    nums = [7, 7, 7, 7]\n    ans = solve(nums)\n    write (*, '(A)') 'Example 3:'\n    write (*, '(A)') 'Input:  ', nums\n    write (*, '(A)') 'Output: ', ans\n\ncontains\n\n    function solve(nums) result(ans)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, dimension(size(nums)) :: ans\n        integer :: i, j\n\n        do i = 1, size(nums)\n            ans(i) = 0\n            do j = 1, size(nums)\n                if (j /= i .and. nums(j) < nums(i)) then\n                    ans(i) = ans(i) + 1\n                end if\n            end do\n        end do\n    end function solve\n\nend program main",
  "1370": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    character(len=:), allocatable :: result\n\n    ! Example 1\n    s = 'aaaabbbbcccc'\n    write(*,'(A)') solve(s)\n\n    ! Example 2\n    s = 'rat'\n    write(*,'(A)') solve(s)\n\ncontains\n\n    function solve(s) result(result)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j, k\n        character :: c\n        logical :: found\n\n        allocate(character(len=len(s)) :: result)\n        result = ''\n\n        do while (len(s) > 0)\n            ! Step 1\n            c = minval(s)\n            call remove(s, c)\n            result = trim(result) // c\n\n            ! Step 2\n            do while (len(s) > 0)\n                c = minval(s, key=gt_char)\n                if (c == '') exit\n                call remove(s, c)\n                result = trim(result) // c\n            end do\n\n            ! Step 3\n            do while (len(s) > 0)\n                c = minval(s)\n                if (c == '') exit\n                call remove(s, c)\n                result = trim(result) // c\n            end do\n\n            ! Step 4\n            c = maxval(s)\n            call remove(s, c)\n            result = trim(result) // c\n\n            ! Step 5\n            do while (len(s) > 0)\n                c = maxval(s, key=lt_char)\n                if (c == '') exit\n                call remove(s, c)\n                result = trim(result) // c\n            end do\n\n            ! Step 6\n            do while (len(s) > 0)\n                c = maxval(s)\n                if (c == '') exit\n                call remove(s, c)\n                result = trim(result) // c\n            end do\n        end do\n\n    contains\n\n        pure function gt_char(c1, c2) result(gt)\n            implicit none\n            character, intent(in) :: c1, c2\n            logical :: gt\n\n            gt = ichar(c1) > ichar(c2)\n        end function gt_char\n\n        pure function lt_char(c1, c2) result(lt)\n            implicit none\n            character, intent(in) :: c1, c2\n            logical :: lt\n\n            lt = ichar(c1) < ichar(c2)\n        end function lt_char\n\n        subroutine remove(string, char)\n            implicit none\n            character(len=*), intent(inout) :: string\n            character, intent(in) :: char\n            integer :: i\n\n            do while (index(string, char) /= 0)\n                i = index(string, char)\n                string(i:) = string(i+1:)\n            end do\n        end subroutine remove\n\n    end function solve\n\nend program main",
  "1374": "program main\n    implicit none\n\n    integer :: i, n\n    character(len=500) :: str\n\n    do i = 1, size(examples)\n        read (examples(i), *) n\n        call solve(n, str)\n        write (*, '(A)') trim(str)\n    end do\n\ncontains\n\n    subroutine solve(n, str)\n        implicit none\n        integer, intent(in) :: n\n        character(len=*), intent(out) :: str\n        integer :: i, j\n\n        str = ''\n        do i = 97, 122\n            do j = 1, mod(n, 2) + 1\n                str = str // char(i)\n            end do\n        end do\n    end subroutine solve\n\nend program main\n\ncharacter(len=*), parameter :: examples(3) = (/ &\n    '4', & ! pppz\n    '2', & ! xy\n    '7'  & ! holasss\n/)",
  "1379": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, iostat_end, DP => REAL64\n    implicit none\n    integer, parameter :: unit_in = 10, unit_out = 20\n    character(len=256) :: filename\n    type :: node\n        real(kind=DP), pointer :: value => null()\n        class(node), pointer :: left => null(), right => null()\n    end type node\n    type(node), pointer :: root, target\n    integer :: stat\n\n    ! read input file name from command line argument\n    if (command_argument_count() /= 1) then\n        write (unit=error_unit, fmt='(A)') 'error: expected one command line argument'\n        stop 1\n    end if\n    call get_command_argument(1, filename)\n\n    ! open files\n    open (newunit=unit_in, file=filename, status='old', action='read', &\n          access='stream', form='unformatted', iostat=stat)\n    if (stat /= 0) then\n        write (unit=error_unit, fmt='(A,I0,A)') 'error: could not open file \"', stat, '\" for reading'\n        stop 2\n    end if\n    open (newunit=unit_out, file='stdout', status='replace', action='write', &\n          access='stream', form='unformatted', iostat=stat)\n    if (stat /= 0) then\n        write (unit=error_unit, fmt='(A,I0,A)') 'error: could not open file \"', stat, '\" for writing'\n        stop 3\n    end if\n\n    ! read root node from input file\n    allocate (root)\n    read (unit=unit_in, iostat=stat) root\n    if (stat == iostat_end) then\n        write (unit=error_unit, fmt='(A)') 'error: unexpected end of file while reading root node'\n        stop 4\n    else if (stat /= 0) then\n        write (unit=error_unit, fmt='(A,I0,A)') 'error: could not read root node from file \"', stat, '\"'\n        stop 5\n    end if\n\n    ! read target node from input file\n    allocate (target)\n    read (unit=unit_in, iostat=stat) target\n    if (stat == iostat_end) then\n        write (unit=error_unit, fmt='(A)') 'error: unexpected end of file while reading target node'\n        stop 6\n    else if (stat /= 0) then\n        write (unit=error_unit, fmt='(A,I0,A)') 'error: could not read target node from file \"', stat, '\"'\n        stop 7\n    end if\n\n    ! solve problem\n    call solve(root, target)\n\n    ! write solution to output file\n    write (unit=unit_out) target\n\n    ! close files\n    close (unit=unit_in)\n    close (unit=unit_out)\n\ncontains\n\nsubroutine solve(original, cloned)\n    implicit none\n    class(node), intent(in) :: original\n    class(node), intent(inout) :: cloned\n    ! local variables\n    class(node), pointer :: current, next\n\n    ! copy original tree into cloned tree\n    allocate (cloned%left)\n    allocate (cloned%right)\n    allocate (cloned%value)\n    cloned%value => original%value\n    cloned%left => original%left\n    cloned%right => original%right\n\n    ! find target node in cloned tree\n    current => cloned\n    do while (associated(current))\n        if (current%value == original%value) exit\n        if (current%value < original%value) then\n            current => current%right\n        else\n            current => current%left\n        end if\n    end do\n\n    ! return reference to same node in cloned tree\n    target => current\nend subroutine solve\n\nend program main",
  "1380": "program main\n    implicit none\n\n    integer, parameter :: m = 3, n = 3\n    integer, dimension(m, n) :: matrix\n    integer, dimension(:), allocatable :: lucky_numbers\n\n    matrix = reshape([3, 7, 8, &\n                       9, 11, 13, &\n                       15, 16, 17], shape(matrix))\n\n    call solve(matrix, lucky_numbers)\n\n    write (*, '(A, *(I0, :, A))') 'Lucky numbers: ', lucky_numbers\n\ncontains\n\n    subroutine solve(mat, lucky_nums)\n        implicit none\n        integer, intent(in) :: mat(:, :)\n        integer, allocatable, intent(out) :: lucky_nums(:)\n        integer :: i, j, min_row, max_col\n\n        allocate (lucky_nums(size(mat)))\n\n        do i = 1, size(mat, 1)\n            min_row = mat(i, 1)\n            max_col = mat(1, i)\n            do j = 2, size(mat, 2)\n                if (mat(i, j) < min_row) then\n                    min_row = mat(i, j)\n                else if (mat(i, j) > max_col) then\n                    max_col = mat(i, j)\n                end if\n            end do\n            if (min_row == mat(i, 1) .and. max_col == mat(1, i)) then\n                lucky_nums(size(lucky_nums)-i+1) = min_row\n            end if\n        end do\n\n    end subroutine solve\n\nend program main",
  "1385": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, parameter :: m = 5\n    integer, parameter :: d = 2\n\n    integer, dimension(n) :: arr1 = (/ 4, 5, 8 /)\n    integer, dimension(m) :: arr2 = (/ 10, 9, 1, 8, 20 /)\n\n    write (*, '(I0)') distance(arr1, arr2, d)\n\ncontains\n\n    function distance(arr1, arr2, d) result(distance_value)\n        implicit none\n        integer, dimension(:), intent(in) :: arr1\n        integer, dimension(:), intent(in) :: arr2\n        integer, intent(in) :: d\n        integer :: distance_value\n        integer :: i, j\n\n        distance_value = 0\n        do i = 1, size(arr1)\n            do j = 1, size(arr2)\n                if (abs(arr1(i) - arr2(j)) <= d) then\n                    exit\n                end if\n            end do\n            if (j == size(arr2)+1) then\n                distance_value = distance_value + 1\n            end if\n        end do\n    end function distance\n\nend program main",
  "1394": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: arr\n    integer :: i, max_freq, max_val\n\n    ! Example 1\n    arr = [2, 2, 3, 4]\n    write(*, '(A, I0)') 'Example 1: ', max_lucky_int(arr)\n\n    ! Example 2\n    arr = [1, 2, 2, 3, 3, 3]\n    write(*, '(A, I0)') 'Example 2: ', max_lucky_int(arr)\n\n    ! Example 3\n    arr = [2, 2, 2, 3, 3]\n    write(*, '(A, I0)') 'Example 3: ', max_lucky_int(arr)\n\ncontains\n\n    function max_lucky_int(arr) result(max_val)\n        implicit none\n        integer, intent(in) :: arr(:)\n        integer :: freq(size(arr)), max_freq, max_val\n\n        freq = count(arr == arr)\n        max_freq = maxval(freq)\n        max_val = -1\n        do i = 1, size(arr)\n            if (freq(i) == max_freq .and. arr(i) > max_val) then\n                max_val = arr(i)\n            end if\n        end do\n    end function max_lucky_int\n\nend program main",
  "1399": "program main\n    implicit none\n\n    integer :: n\n\n    call get_arguments(n)\n\n    write (*, '(A, I0)') 'The number of groups with largest size is ', solve(n)\n\ncontains\n\n    subroutine get_arguments(n)\n        implicit none\n        integer, intent(out) :: n\n\n        if (command_argument_count() /= 1) then\n            write (*, '(A)') 'ERROR: Expected one argument'\n            stop 1\n        end if\n\n        call get_command_argument(1, buffer)\n        read (buffer, '(I0)', iostat=iostat) n\n        if (iostat /= 0) then\n            write (*, '(A)') 'ERROR: Invalid argument'\n            stop 1\n        end if\n    end subroutine get_arguments\n\n    function solve(n) result(groups)\n        implicit none\n        integer, value :: n\n        integer :: groups\n\n        integer :: i, j, k, l, m, n_digits, digit_sums(n), max_digit_sum, &\n                   group_size(n), group_index(n)\n\n        do i = 1, n\n            digit_sums(i) = 0\n            do j = 1, n_digits(i)\n                digit_sums(i) = digit_sums(i) + mod(i, 10)\n                i = i / 10\n            end do\n        end do\n\n        max_digit_sum = 0\n        do i = 1, n\n            if (digit_sums(i) > max_digit_sum) then\n                max_digit_sum = digit_sums(i)\n            end if\n        end do\n\n        groups = 0\n        do i = 1, n\n            if (digit_sums(i) == max_digit_sum) then\n                groups = groups + 1\n            end if\n        end do\n\n    contains\n\n        function n_digits(x) result(nd)\n            implicit none\n            integer, value :: x\n            integer :: nd\n\n            nd = 0\n            do while (x > 0)\n                nd = nd + 1\n                x = x / 10\n            end do\n        end function n_digits\n\n    end function solve\n\nend program main",
  "1403": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums = (/ 4, 3, 10, 9, 8 /)\n    integer, dimension(:), allocatable :: subseq\n    integer :: i, j, k, l, m, n_subseq, min_size, max_sum\n\n    call solve(nums, subseq, n_subseq, min_size, max_sum)\n\n    write (*, '(A, I0, A, I0, A)') 'Subsequence: ', subseq, &\n        ' (', n_subseq, ' elements)'\n    write (*, '(A, I0, A, I0, A)') 'Minimal size: ', min_size, &\n        ' (', n_subseq, ' elements)'\n    write (*, '(A, I0, A, I0, A)') 'Maximum sum: ', max_sum, &\n        ' (', n_subseq, ' elements)'\n\ncontains\n\n    subroutine solve(nums, subseq, n_subseq, min_size, max_sum)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer, allocatable, intent(out) :: subseq(:)\n        integer, intent(out) :: n_subseq, min_size, max_sum\n        integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n\n        ! Initialize variables\n        n_subseq = 0\n        min_size = huge(n_subseq)\n        max_sum = -huge(max_sum)\n\n        ! Loop over all possible subsequences\n        do i = 1, size(nums)\n            do j = i + 1, size(nums)\n                do k = j + 1, size(nums)\n                    do l = k + 1, size(nums)\n                        do m = l + 1, size(nums)\n                            do n = m + 1, size(nums)\n                                do o = n + 1, size(nums)\n                                    do p = o + 1, size(nums)\n                                        do q = p + 1, size(nums)\n                                            do r = q + 1, size(nums)\n                                                do s = r + 1, size(nums)\n                                                    do t = s + 1, size(nums)\n                                                        do u = t + 1, size(nums)\n                                                            do v = u + 1, size(nums)\n                                                                do w = v + 1, size(nums)\n                                                                    do x = w + 1, size(nums)\n                                                                        do y = x + 1, size(nums)\n                                                                            do z = y + 1, size(nums)\n                                                                                ! Check if subsequence satisfies conditions\n                                                                                if (sum(nums(i:z)) > sum(nums(1:i-1)) .and. &\n                                                                                    sum(nums(i:z)) > sum(nums(j:k-1)) .and. &\n                                                                                    sum(nums(i:z)) > sum(nums(l:m-1)) .and. &\n                                                                                    sum(nums(i:z)) > sum(nums(n:o-1)) .and. &\n                                                                                    sum(nums(i:z)) > sum(nums(p:q-1)) .and. &\n                                                                                    sum(nums(i:z)) > sum(nums(r:s-1)) .and. &\n                                                                                    sum(nums(i:z)) > sum(nums(t:u-1)) .and. &\n                                                                                    sum(nums(i:z)) > sum(nums(v:w-1)) .and. &\n                                                                                    sum(nums(i:z)) > sum(nums(x:y-1))) then\n                                                ",
  "1408": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    character(len=30), dimension(n) :: words\n    character(len=30), allocatable, dimension(:) :: substrs\n    integer :: i, j\n\n    ! Example 1\n    words(1) = 'mass '\n    words(2) = 'as '\n    words(3) = 'hero '\n    words(4) = 'superhero '\n\n    call get_substrs(words, substrs)\n    do i = 1, size(substrs)\n        write(*,*) trim(substrs(i))\n    end do\n\n    ! Example 2\n    words(1) = 'leetcode '\n    words(2) = 'et '\n    words(3) = 'code '\n\n    call get_substrs(words, substrs)\n    do i = 1, size(substrs)\n        write(*,*) trim(substrs(i))\n    end do\n\n    ! Example 3\n    words(1) = 'blue '\n    words(2) = 'green '\n    words(3) = 'bu '\n\n    call get_substrs(words, substrs)\n    if (size(substrs) > 0) then\n        do i = 1, size(substrs)\n            write(*,*) trim(substrs(i))\n        end do\n    else\n        write(*,*) 'No substring found'\n    end if\n\ncontains\n\n    subroutine get_substrs(words, substrs)\n        implicit none\n        character(len=*), intent(in) :: words(:)\n        character(len=*), allocatable, intent(out) :: substrs(:)\n        integer :: i, j, k, l\n        logical :: found\n\n        allocate(substrs(0))\n\n        do i = 1, size(words) - 1\n            do j = i + 1, size(words)\n                found = .false.\n                do k = 1, len(words(j))\n                    do l = 1, len(words(i))\n                        if (words(j)(k:k) == words(i)(l:l)) then\n                            found = .true.\n                            exit\n                        end if\n                    end do\n                    if (found) exit\n                end do\n                if (found) then\n                    allocate(character(len=len(words(i))) :: substrs(size(substrs)+1))\n                    substrs(size(substrs)) = words(i)\n                end if\n            end do\n        end do\n    end subroutine get_substrs\n\nend program main",
  "1413": "program minStartValue\n    implicit none\n\n    integer, parameter :: dp = selected_real_kind(15)\n\n    integer, dimension(:), allocatable :: nums\n    integer :: n, i, j, startValue, stepByStepSum\n    logical :: foundMin\n\n    ! read input\n    read(*,*) n\n    allocate(nums(n))\n    do i = 1, n\n        read(*,*) nums(i)\n    end do\n\n    ! find minimum positive start value\n    startValue = huge(startValue)\n    foundMin = .false.\n    do while (.not. foundMin)\n        stepByStepSum = startValue\n        do j = 1, n\n            if (nums(j) < 0) then\n                stepByStepSum = stepByStepSum + nums(j)\n            else\n                exit\n            end if\n        end do\n        if (stepByStepSum >= 1) then\n            foundMin = .true.\n        else\n            startValue = startValue - 1\n        end if\n    end do\n\n    ! print result\n    write(*,*) startValue\n\nend program minStartValue",
  "1417": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    character(len=:), allocatable :: result\n\n    s = \"a0b1c2\"\n    write(*,*) \"Input: \", s\n    result = solve(s)\n    write(*,*) \"Output: \", result\n\n    s = \"leetcode\"\n    write(*,*) \"Input: \", s\n    result = solve(s)\n    write(*,*) \"Output: \", result\n\n    s = \"1229857369\"\n    write(*,*) \"Input: \", s\n    result = solve(s)\n    write(*,*) \"Output: \", result\n\ncontains\n\n    function solve(s) result(result)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=:), allocatable :: result\n        integer :: i, j\n\n        allocate(character(len=size(s)) :: result)\n        do i = 1, size(s)\n            select case (s(i:i))\n                case (\"0\":\"9\")\n                    result(i:i) = s(i:i)\n                case default\n                    do j = 1, size(s)\n                        if (s(j:j) == s(i:i)) exit\n                    end do\n                    if (j > size(s)) then\n                        deallocate(result)\n                        result = \"\"\n                        return\n                    end if\n                    result(i:i) = s(j:j)\n            end select\n        end do\n    end function solve\n\nend program main",
  "1422": "program main\n    implicit none\n\n    character(len=500) :: s\n    integer :: i, j, n\n    integer :: max_score\n\n    ! read input\n    read(*,*) s\n\n    ! find the maximum score\n    max_score = -1\n    do i = 1, len(s)-1\n        do j = i+1, len(s)\n            if (s(i:j) /= '0' .and. s(i:j) /= '1') cycle\n            n = count(s(i:j) == '0') + count(s(i:j) == '1')\n            if (n > max_score) max_score = n\n        end do\n    end do\n\n    ! print output\n    write(*,*) max_score\n\nend program main",
  "1426": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: arr = (/ 1, 2, 3 /)\n    integer :: x\n    integer :: count\n\n    count = count_elements(arr)\n    write (*, '(I0)') count\n\ncontains\n\n    function count_elements(arr) result(count)\n        implicit none\n        integer, intent(in) :: arr(:)\n        integer :: count\n        integer :: i\n        logical :: found\n\n        count = 0\n        do i = 1, size(arr) - 1\n            if (any(arr(i+1:) == arr(i))) then\n                count = count + 1\n            end if\n        end do\n    end function count_elements\n\nend program main",
  "1427": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=:), allocatable :: s\n    integer, dimension(:,:), allocatable :: shift\n\n    ! read input\n    read(*,*) s\n    read(*,*) n\n    allocate(shift(n,2))\n    do i = 1, n\n        read(*,*) shift(i,:)\n    end do\n\n    ! solve problem\n    call solve(s, shift)\n\n    ! print output\n    write(*,'(a)') s\n\ncontains\n\n    subroutine solve(s, shift)\n        implicit none\n        character(len=:), allocatable :: s\n        integer, dimension(:,:), allocatable :: shift\n        integer :: i, direction, amount\n\n        do i = 1, size(shift,1)\n            direction = shift(i,1)\n            amount = shift(i,2)\n            if (direction == 0) then\n                call left_shift(s, amount)\n            else\n                call right_shift(s, amount)\n            end if\n        end do\n    end subroutine solve\n\n    subroutine left_shift(s, amount)\n        implicit none\n        character(len=:), allocatable :: s\n        integer :: amount\n        character(len=:), allocatable :: tmp\n\n        allocate(tmp, source=s(2:))\n        deallocate(s)\n        allocate(s, source=' '//tmp)\n        deallocate(tmp)\n    end subroutine left_shift\n\n    subroutine right_shift(s, amount)\n        implicit none\n        character(len=:), allocatable :: s\n        integer :: amount\n        character(len=:), allocatable :: tmp\n\n        allocate(tmp, source=s(1:size(s)-1))\n        deallocate(s)\n        allocate(s, source=tmp//' ')\n        deallocate(tmp)\n    end subroutine right_shift\n\nend program main",
  "1431": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: candies = [2, 3, 5, 1, 3]\n    integer :: extraCandies = 3\n    logical, dimension(n) :: result\n\n    result = solve(candies, extraCandies)\n\n    write (*, '(L1)') result\n\ncontains\n\n    function solve(candies, extraCandies) result(result)\n        implicit none\n        integer, intent(in) :: candies(:), extraCandies\n        logical, dimension(size(candies)) :: result\n        integer :: i\n\n        do i = 1, size(candies)\n            result(i) = (candies(i) + extraCandies) >= maxval(candies)\n        end do\n    end function solve\nend program main",
  "1436": "program main\n    implicit none\n\n    integer :: i, j\n    character(len=10) :: paths(10,2)\n    character(len=10) :: dest_city\n\n    ! Example 1\n    paths(1,:) = ['London ', 'New York']\n    paths(2,:) = ['New York ', 'Lima']\n    paths(3,:) = ['Lima ', 'Sao Paulo']\n    call solve(paths, dest_city)\n    write(*,'(a)') trim(dest_city) // ' ' // 'Sao Paulo'\n\n    ! Example 2\n    paths(:,1) = ['B', 'C', 'D']\n    paths(:,2) = ['C', 'A', 'B']\n    call solve(paths, dest_city)\n    write(*,'(a)') trim(dest_city) // ' ' // 'A'\n\n    ! Example 3\n    paths(:,:) = ['A', 'Z']\n    call solve(paths, dest_city)\n    write(*,'(a)') trim(dest_city) // ' ' // 'Z'\n\ncontains\n\nsubroutine solve(paths, dest_city)\n    implicit none\n    character(len=10), intent(in) :: paths(:,:)\n    character(len=10), intent(out) :: dest_city\n    logical :: visited(size(paths,1))\n    integer :: i, j\n\n    visited(:) = .false.\n    do i = 1, size(paths,1)\n        if (.not. visited(i)) then\n            do j = 1, size(paths,1)\n                if (visited(j)) cycle\n                if (paths(j,1) == paths(i,2)) then\n                    visited(j) = .true.\n                    exit\n                end if\n            end do\n        end if\n    end do\n\n    do i = 1, size(paths,1)\n        if (.not. visited(i)) then\n            dest_city = paths(i,1)\n            return\n        end if\n    end do\nend subroutine solve\n\nend program main",
  "1437": "program main\n    ! Solve the problem:\n    ! Given an binary array `nums` and an integer `k`, return `true` if all `1`s are at least `k` places away from each other, otherwise return `false`.\n    implicit none\n\n    integer, parameter :: k = 2\n    integer, dimension(8) :: nums = [1, 0, 0, 0, 1, 0, 0, 1]\n    logical :: result\n\n    print '(L1)', solve(nums, k)\n\ncontains\n\n    function solve(nums, k) result(result)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, intent(in) :: k\n        logical :: result\n        integer :: i, j, n\n\n        n = size(nums)\n        do i = 1, n - k\n            do j = i + 1, min(n, i + k)\n                if (nums(i) == 1 .and. nums(j) == 1) then\n                    result = .false.\n                    return\n                end if\n            end do\n        end do\n        result = .true.\n    end function solve\nend program main",
  "1446": "program main\n    implicit none\n\n    integer :: power, i, j\n    character(len=500) :: s\n\n    ! Example 1\n    s = \"leetcode \"\n    power = powerOfString(s)\n    write (*,*) power\n\n    ! Example 2\n    s = \"abbcccddddeeeeedcba \"\n    power = powerOfString(s)\n    write (*,*) power\n\ncontains\n\n    function powerOfString(s) result(power)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: power, count, i\n\n        power = 0\n        do i = 1, len(s) - 1\n            if (s(i:i+1) == s(i+1:i+2)) then\n                cycle\n            else\n                count = 1\n                do j = i + 1, len(s)\n                    if (s(j:j+1) == s(i:i+1)) then\n                        count = count + 1\n                    else\n                        exit\n                    end if\n                end do\n                power = max(power, count)\n            end if\n        end do\n    end function powerOfString\n\nend program main",
  "1450": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: startTime = [1, 2, 3]\n    integer, dimension(n) :: endTime = [3, 2, 7]\n    integer :: queryTime = 4\n    integer :: i\n\n    do i = 1, n\n        if (queryTime >= startTime(i) .and. queryTime <= endTime(i)) then\n            print '(I0)', i\n        end if\n    end do\n\nend program main",
  "1455": "program main\n    implicit none\n\n    character(len=100) :: sentence\n    character(len=10) :: searchWord\n    integer :: i, j, idx, minIdx\n    logical :: found\n\n    ! Example 1\n    sentence = \"i love eating burger \"\n    searchWord = \"burg \"\n    write(*,*) 'Example 1:'\n    write(*,*) 'Input: ', trim(sentence), ', ', trim(searchWord)\n    idx = findPrefixIndex(sentence, searchWord)\n    write(*,*) 'Output: ', idx\n\n    ! Example 2\n    sentence = \"this problem is an easy problem \"\n    searchWord = \"pro \"\n    write(*,*) 'Example 2:'\n    write(*,*) 'Input: ', trim(sentence), ', ', trim(searchWord)\n    idx = findPrefixIndex(sentence, searchWord)\n    write(*,*) 'Output: ', idx\n\n    ! Example 3\n    sentence = \"i am tired \"\n    searchWord = \"you \"\n    write(*,*) 'Example 3:'\n    write(*,*) 'Input: ', trim(sentence), ', ', trim(searchWord)\n    idx = findPrefixIndex(sentence, searchWord)\n    write(*,*) 'Output: ', idx\n\ncontains\n\n    function findPrefixIndex(sentence, searchWord) result(idx)\n        implicit none\n        character(len=*), intent(in) :: sentence\n        character(len=*), intent(in) :: searchWord\n        integer :: idx\n        logical :: found\n\n        idx = -1\n        found = .false.\n        do i = 1, size(sentence)\n            if (sentence(i:i+size(searchWord)-1) == searchWord) then\n                found = .true.\n                idx = i\n                exit\n            end if\n        end do\n\n        if (.not. found) then\n            idx = -1\n        end if\n    end function findPrefixIndex\nend program main",
  "1460": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: target = [1, 2, 3, 4]\n    integer, dimension(n) :: arr = [2, 4, 1, 3]\n    logical :: result\n\n    print '(L1)', solve(target, arr)\n\ncontains\n\n    function solve(target, arr) result(res)\n        implicit none\n        integer, intent(in) :: target(:), arr(:)\n        logical :: res\n\n        integer :: i, j, k\n        integer, allocatable :: tmp(:)\n\n        if (size(target) /= size(arr)) then\n            stop \"Error: arrays must have same size\"\n        end if\n\n        res = .false.\n\n        ! check if arr is already equal to target\n        if (all(target == arr)) then\n            res = .true.\n            return\n        end if\n\n        allocate(tmp(size(arr)))\n\n        ! try to find a non-empty subarray in arr that we can reverse\n        do i = 1, size(arr) - 1\n            if (arr(i) /= arr(i+1)) then\n                ! found a non-empty subarray, now check if we can reverse it\n                do j = i + 1, size(arr)\n                    if (arr(j) /= arr(j-1)) exit\n                end do\n                if (j > i + 1) then\n                    ! reverse the subarray\n                    do k = i + 1, (j - 1) / 2\n                        tmp(k) = arr(j - k + i)\n                        tmp(j - k + i) = arr(k)\n                    end do\n                    arr = tmp\n                    deallocate(tmp)\n                    allocate(tmp(size(arr)))\n                    tmp = arr\n                    arr = tmp\n                    deallocate(tmp)\n                    allocate(tmp(size(arr)))\n\n                    ! check if arr is now equal to target\n                    if (all(target == arr)) then\n                        res = .true.\n                        return\n                    end if\n                end if\n            end if\n        end do\n\n        deallocate(tmp)\n\n        res = .false.\n\n    end function solve\n\nend program main",
  "1464": "program main\n    implicit none\n\n    integer, parameter :: n = 500\n    integer, dimension(n) :: nums\n    integer :: i, j, max_val\n\n    ! Example 1\n    nums = [3, 4, 5, 2]\n    call solve(nums, i, j, max_val)\n    write (*, '(A, I0, A, I0, A, I0)') &\n        'Example 1: ', nums(i), ' * ', nums(j), ' = ', max_val\n\n    ! Example 2\n    nums = [1, 5, 4, 5]\n    call solve(nums, i, j, max_val)\n    write (*, '(A, I0, A, I0, A, I0)') &\n        'Example 2: ', nums(i), ' * ', nums(j), ' = ', max_val\n\n    ! Example 3\n    nums = [3, 7]\n    call solve(nums, i, j, max_val)\n    write (*, '(A, I0, A, I0, A, I0)') &\n        'Example 3: ', nums(i), ' * ', nums(j), ' = ', max_val\n\ncontains\n\n    subroutine solve(nums, i, j, max_val)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, intent(out) :: i, j, max_val\n\n        integer :: ii, jj, val\n\n        do ii = 1, size(nums) - 1\n            do jj = ii + 1, size(nums)\n                val = (nums(ii) - 1) * (nums(jj) - 1)\n                if (val > max_val) then\n                    max_val = val\n                    i = ii\n                    j = jj\n                end if\n            end do\n        end do\n    end subroutine solve\n\nend program main",
  "1469": "program lonely_nodes\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: unit_out = 6\n    type :: node\n        real(kind=DP) :: val\n        class(node), pointer :: left => null(), right => null()\n    end type\n    type(node), pointer :: root\n    integer :: i\n    character(len=*), parameter :: fmt = '(*(g0,:,\" \",:,\" \",:))'\n\n    call get_examples(root)\n    do i = 1, size(root%left)\n        if (associated(root%left(i)%left)) then\n            write (unit=unit_out, fmt=fmt) root%val, &\n                root%left(i)%val, root%left(i)%left%val\n        else\n            write (unit=unit_out, fmt=fmt) root%val, &\n                root%left(i)%val, \"None\"\n        end if\n    end do\n    deallocate (root)\n\ncontains\n\n    subroutine get_examples(root)\n        implicit none\n        type(node), pointer :: root\n        allocate (root)\n        root%val = 1.0_DP\n        allocate (root%left(2))\n        root%left(1)%val = 2.0_DP\n        allocate (root%left(2)%left)\n        root%left(2)%left%val = 3.0_DP\n        allocate (root%right)\n        root%right%val = 4.0_DP\n    end subroutine get_examples\n\nend program lonely_nodes",
  "1470": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(2*n) :: nums = [2,5,1,3,4,7]\n    integer, dimension(n) :: result\n\n    call solve(nums, n, result)\n\n    write (*, '(A)') 'Result:'\n    write (*, '(A)') result\n\ncontains\n\n    subroutine solve(nums, n, result)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(:), intent(in) :: nums\n        integer, dimension(:), intent(out) :: result\n        integer :: i\n\n        do i = 1, n\n            result(i) = nums(2*i-1)\n            result(i+n) = nums(2*i)\n        end do\n    end subroutine solve\nend program main",
  "1474": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 1000\n    type :: node\n        real(kind=DP), allocatable :: val(:)\n        class(node), pointer :: next => null()\n    end type node\n    type(node), pointer :: head, curr, prev\n    integer :: i, j, k, m, n\n    logical :: success\n\n    ! Examples\n    call test_example1()\n    call test_example2()\n\ncontains\n\n    subroutine test_example1()\n        implicit none\n        type(node), pointer :: head, curr\n        integer :: i\n        real(kind=DP), allocatable :: vals(:)\n\n        allocate(head)\n        head%val = [1._DP, 2._DP, 3._DP, 4._DP, 5._DP, 6._DP, 7._DP, &\n                    8._DP, 9._DP, 10._DP, 11._DP, 12._DP, 13._DP]\n        head%next => null()\n\n        do i = 1, size(head%val)\n            if (associated(head%next)) then\n                allocate(head%next)\n                head => head%next\n            else\n                exit\n            end if\n        end do\n\n        call traverse_and_remove(head, 2, 3)\n\n        write(*,*) \"Example 1:\"\n        write(*,*) \"Input: \", head%val\n        write(*,*) \"Output: \", head%val\n        write(*,*) \"\"\n    end subroutine test_example1\n\n    subroutine test_example2()\n        implicit none\n        type(node), pointer :: head, curr\n        integer :: i\n        real(kind=DP), allocatable :: vals(:)\n\n        allocate(head)\n        head%val = [1._DP, 2._DP, 3._DP, 4._DP, 5._DP, 6._DP, 7._DP, &\n                    8._DP, 9._DP, 10._DP, 11._DP]\n        head%next => null()\n\n        do i = 1, size(head%val)\n            if (associated(head%next)) then\n                allocate(head%next)\n                head => head%next\n            else\n                exit\n            end if\n        end do\n\n        call traverse_and_remove(head, 1, 3)\n\n        write(*,*) \"Example 2:\"\n        write(*,*) \"Input: \", head%val\n        write(*,*) \"Output: \", head%val\n        write(*,*) \"\"\n    end subroutine test_example2\n\n    function traverse_and_remove(head, m, n) result(new_head)\n        implicit none\n        type(node), pointer, intent(inout) :: head\n        integer, value :: m, n\n        type(node), pointer :: new_head, curr, prev\n        integer :: i\n\n        new_head => head\n        curr => head\n        do i = 1, m\n            if (.not. associated(curr%next)) exit\n            curr => curr%next\n        end do\n\n        do while (associated(curr%next))\n            prev => curr\n            curr => curr%next\n            deallocate(prev%next)\n            do i = 1, n\n                if (.not. associated(curr%next)) exit\n                curr => curr%next\n            end do\n        end do\n\n        return\n    end function traverse_and_remove\n\nend program main",
  "1475": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: prices = (/ 8, 4, 6, 2, 3 /)\n    integer, dimension(n) :: answer\n\n    call solve(prices, answer)\n\n    write (*, '(A)') 'Answer:'\n    write (*, '(*(I0, 1X))') answer\n\ncontains\n\n    subroutine solve(prices, answer)\n        implicit none\n        integer, intent(in) :: prices(:)\n        integer, intent(out) :: answer(:)\n\n        integer :: i, j, k\n\n        do i = 1, size(prices)\n            j = i + 1\n            do while (j <= size(prices) .and. prices(j) <= prices(i))\n                j = j + 1\n            end do\n\n            if (j <= size(prices)) then\n                k = j - 1\n                answer(i) = prices(i) - prices(k)\n            else\n                answer(i) = prices(i)\n            end if\n        end do\n    end subroutine solve\nend program main",
  "1480": "program main\n    ! Solves the problem \"Running Sum of 1d Array\" from LeetCode (https://leetcode.com/problems/running-sum-of-1d-array/)\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums\n    integer, dimension(n) :: runningSum\n\n    nums = [1, 2, 3, 4, 1]\n    runningSum = runningSumOfArray(nums)\n    write (*, '(A,*(I0,1X))') 'Running sum of ', nums, 'is', runningSum\n\ncontains\n\n    function runningSumOfArray(nums) result(runningSum)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer, dimension(size(nums)) :: runningSum\n\n        integer :: i\n\n        do i = 1, size(nums)\n            runningSum(i) = sum(nums(0:i-1))\n        end do\n    end function runningSumOfArray\nend program main",
  "1486": "program main\n    implicit none\n\n    integer :: n, start, i\n    integer, dimension(n) :: nums\n\n    do i = 1, n\n        nums(i) = start + 2 * (i - 1)\n    end do\n\n    print '(I0)', sum(nums)\n\nend program main",
  "1491": "program main\n    implicit none\n\n    integer, parameter :: dp = selected_real_kind(15, 307)\n\n    integer, dimension(:), allocatable :: salary\n    real(dp) :: avg\n\n    call get_array(salary)\n\n    avg = average(salary)\n\n    write (*, '(F8.5)') avg\n\ncontains\n\n    subroutine get_array(arr)\n        implicit none\n        integer, dimension(:), allocatable, intent(out) :: arr\n        integer :: i, n\n\n        read *, n\n        allocate(arr(n))\n\n        do i = 1, n\n            read *, arr(i)\n        end do\n    end subroutine get_array\n\n    function average(arr) result(avg)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        real(dp) :: avg\n        integer :: i, n\n\n        n = size(arr)\n        avg = sum(arr)\n        do i = 1, n\n            if (arr(i) == minval(arr)) then\n                avg = avg - arr(i)\n            else if (arr(i) == maxval(arr)) then\n                avg = avg - arr(i)\n            end if\n        end do\n        avg = avg / (n - 2)\n    end function average\n\nend program main",
  "1496": "program main\n    implicit none\n\n    character(len=3) :: path\n    logical :: result\n\n    ! Example 1\n    path = \"NES\"\n    result = crosses_path(path)\n    print *, result\n\n    ! Example 2\n    path = \"NESWW\"\n    result = crosses_path(path)\n    print *, result\n\ncontains\n\n    function crosses_path(path) result(crosses)\n        implicit none\n        character(len=*), intent(in) :: path\n        integer :: i, j, n\n        logical :: crosses\n        integer, allocatable :: x(:), y(:)\n\n        n = len(path)\n        allocate(x(n))\n        allocate(y(n))\n\n        x(1) = 0\n        y(1) = 0\n\n        do i = 2, n\n            select case (path(i-1:i-1))\n                case('N')\n                    y(i) = y(i-1) + 1\n                case('S')\n                    y(i) = y(i-1) - 1\n                case('E')\n                    x(i) = x(i-1) + 1\n                case('W')\n                    x(i) = x(i-1) - 1\n            end select\n        end do\n\n        crosses = .false.\n        do i = 1, n-1\n            do j = i+1, n\n                if (x(i) == x(j) .and. y(i) == y(j)) then\n                    crosses = .true.\n                    exit\n                end if\n            end do\n            if (crosses) exit\n        end do\n\n        deallocate(x)\n        deallocate(y)\n    end function crosses_path\nend program main",
  "1502": "program main\n    ! Solve the problem described in the task\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: arr = (/ 3, 5, 1 /)\n    logical :: result\n\n    result = canFormArithmeticProgression(arr)\n    print '(L1)', result\n\ncontains\n\n    function canFormArithmeticProgression(arr) result(result)\n        ! Return true if the array can be rearranged to form an arithmetic progression\n        implicit none\n        integer, intent(in) :: arr(:)\n        logical :: result\n        integer :: i, j, k, diff\n\n        do i = 1, size(arr)-1\n            do j = i+1, size(arr)\n                diff = arr(j) - arr(i)\n                do k = j+1, size(arr)\n                    if (arr(k) - arr(j) == diff) then\n                        exit\n                    end if\n                end do\n                if (k > size(arr)) then\n                    result = .true.\n                    return\n                end if\n            end do\n        end do\n        result = .false.\n    end function canFormArithmeticProgression\nend program main",
  "1507": "program main\n    implicit none\n\n    character(len=10) :: date\n    integer :: year, month, day\n\n    ! Example 1\n    date = \"20th Oct 2052\"\n    call convert_date(date, year, month, day)\n    write (*, '(I4, \"-\", I2.2, \"-\", I2.2)') year, month, day\n\n    ! Example 2\n    date = \"6th Jun 1933\"\n    call convert_date(date, year, month, day)\n    write (*, '(I4, \"-\", I2.2, \"-\", I2.2)') year, month, day\n\n    ! Example 3\n    date = \"26th May 1960\"\n    call convert_date(date, year, month, day)\n    write (*, '(I4, \"-\", I2.2, \"-\", I2.2)') year, month, day\n\ncontains\n\n    subroutine convert_date(date, year, month, day)\n        implicit none\n        character(len=*), intent(in) :: date\n        integer, intent(out) :: year, month, day\n\n        integer :: i\n        character(len=3) :: month_name\n\n        read (date, *) day, month_name, year\n\n        do i = 1, size(month_names)\n            if (month_names(i) == month_name) then\n                month = i\n                exit\n            end if\n        end do\n\n    end subroutine convert_date\n\nend program main",
  "1512": "program main\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: nums\n    integer :: i, j\n    integer :: good_pairs\n\n    ! Example 1\n    nums = [1, 2, 3, 1, 1, 3]\n    write (*, '(a, i0)') 'Example 1: ', good_pairs(nums)\n\n    ! Example 2\n    nums = [1, 1, 1, 1]\n    write (*, '(a, i0)') 'Example 2: ', good_pairs(nums)\n\n    ! Example 3\n    nums = [1, 2, 3]\n    write (*, '(a, i0)') 'Example 3: ', good_pairs(nums)\n\ncontains\n\n    function good_pairs(nums) result(count)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer :: count\n        integer :: i, j\n\n        count = 0\n        do i = 1, size(nums) - 1\n            do j = i + 1, size(nums)\n                if (nums(i) == nums(j)) then\n                    count = count + 1\n                end if\n            end do\n        end do\n    end function good_pairs\n\nend program main",
  "1518": "program main\n    implicit none\n\n    integer :: numBottles, numExchange, maxWaterBottles\n\n    numBottles = 9\n    numExchange = 3\n    write (*, '(A, I0)') 'Example 1: ', maxWaterBottles(numBottles, numExchange)\n\n    numBottles = 15\n    numExchange = 4\n    write (*, '(A, I0)') 'Example 2: ', maxWaterBottles(numBottles, numExchange)\n\ncontains\n\n    function maxWaterBottles(n, m) result(res)\n        implicit none\n        integer, value :: n, m\n        integer :: res\n\n        res = n + m - 1\n    end function maxWaterBottles\nend program main",
  "1523": "program main\n    implicit none\n\n    integer :: low, high, count\n\n    ! Example 1\n    low = 3\n    high = 7\n    print '(I0)', countOddNumbers(low, high)\n\n    ! Example 2\n    low = 8\n    high = 10\n    print '(I0)', countOddNumbers(low, high)\n\ncontains\n\n    function countOddNumbers(low, high) result(count)\n        implicit none\n        integer, intent(in) :: low, high\n        integer :: i, count\n\n        count = 0\n        do i = low, high\n            if (mod(i, 2) /= 0) then\n                count = count + 1\n            end if\n        end do\n    end function countOddNumbers\nend program main",
  "1528": "program main\n    implicit none\n\n    character(len=*), parameter :: s = \"codeleet \"\n    integer, parameter :: n = len_trim(s)\n    integer, parameter :: indices(n) = [4,5,6,7,0,2,1,3]\n    character(len=n) :: shuffled_string\n\n    call solve(s, indices, shuffled_string)\n\n    print '(A)', trim(shuffled_string)\n\ncontains\n\n    subroutine solve(s, indices, shuffled_string)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer, intent(in) :: indices(:)\n        character(len=*), intent(out) :: shuffled_string\n        integer :: i, j\n\n        do i = 1, size(indices)\n            j = indices(i)\n            if (j /= i) then\n                shuffled_string(j:j) = s(i:i)\n            end if\n        end do\n    end subroutine solve\n\nend program main",
  "1534": "program main\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: arr = (/ 3, 0, 1, 1, 9, 7 /)\n    integer, parameter :: a = 7, b = 2, c = 3\n    integer :: i, j, k\n    integer :: num_good_triplets\n\n    num_good_triplets = count_good_triplets(arr, a, b, c)\n    write (*, '(A, I0)') 'Number of good triplets: ', num_good_triplets\n\ncontains\n\n    function count_good_triplets(arr, a, b, c) result(num_good_triplets)\n        implicit none\n        integer, intent(in) :: arr(:)\n        integer, intent(in) :: a, b, c\n        integer :: i, j, k\n        logical :: condition_1, condition_2, condition_3\n        num_good_triplets = 0\n        do i = 1, size(arr) - 2\n            do j = i + 1, size(arr) - 1\n                do k = j + 1, size(arr)\n                    condition_1 = (0 <= i .and. i < j .and. j < k .and. k < size(arr))\n                    condition_2 = abs(arr(i) - arr(j)) <= a\n                    condition_3 = abs(arr(j) - arr(k)) <= b\n                    condition_4 = abs(arr(i) - arr(k)) <= c\n                    if (condition_1 .and. condition_2 .and. condition_3 .and. condition_4) then\n                        num_good_triplets = num_good_triplets + 1\n                    end if\n                end do\n            end do\n        end do\n    end function count_good_triplets\nend program main",
  "1539": "program main\n    implicit none\n\n    integer, parameter :: n = 10\n    integer, dimension(n) :: arr\n    integer :: k\n    integer :: result\n\n    ! Example 1\n    arr = [2, 3, 4, 7, 11]\n    k = 5\n    result = findKthMissingPositiveInteger(arr, k)\n    print '(A, I0)', 'Example 1: ', result\n\n    ! Example 2\n    arr = [1, 2, 3, 4]\n    k = 2\n    result = findKthMissingPositiveInteger(arr, k)\n    print '(A, I0)', 'Example 2: ', result\n\ncontains\n\n    function findKthMissingPositiveInteger(arr, k) result(result_)\n        implicit none\n        integer, intent(in) :: arr(:), k\n        integer :: result_\n        integer :: i, j\n\n        result_ = -1\n        do i = 1, size(arr) - 1\n            if (arr(i) + 1 /= arr(i+1)) then\n                exit\n            end if\n        end do\n\n        if (i == size(arr)) then\n            result_ = arr(size(arr)) + k\n        else\n            do j = i + 1, size(arr) - 1\n                if (arr(j) > arr(i) + k) then\n                    result_ = arr(i) + k\n                    exit\n                end if\n            end do\n        end if\n    end function findKthMissingPositiveInteger\n\nend program main",
  "1544": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    integer :: i\n\n    ! Examples\n    s = 'leEeetcode '\n    call solve(s)\n    print *, s\n\n    s = 'abBAcC '\n    call solve(s)\n    print *, s\n\n    s = 's '\n    call solve(s)\n    print *, s\n\ncontains\n\n    subroutine solve(s)\n        implicit none\n        character(len=*), intent(inout) :: s\n        logical :: is_good\n\n        do while (.not. is_good(s))\n            call reduce(s)\n        end do\n    end subroutine solve\n\n    function is_good(s) result(is_good_)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i\n\n        is_good_ = .true.\n        do i = 1, len(s) - 1\n            if (is_adjacent(s(i:i+1))) then\n                is_good_ = .false.\n                exit\n            end if\n        end do\n    end function is_good\n\n    subroutine reduce(s)\n        implicit none\n        character(len=*), intent(inout) :: s\n        integer :: i\n\n        do i = 1, len(s) - 1\n            if (is_adjacent(s(i:i+1))) then\n                call delete_char(s, i)\n                return\n            end if\n        end do\n    end subroutine reduce\n\n    logical function is_adjacent(s)\n        implicit none\n        character(len=2), intent(in) :: s\n\n        is_adjacent = (s(1:1) == lcase(s(2:2))) .or. &\n                       (s(1:1) == ucase(s(2:2)))\n    end function is_adjacent\n\n    subroutine delete_char(s, i)\n        implicit none\n        character(len=*), intent(inout) :: s\n        integer, value :: i\n\n        s = s(:i-1) // s(i+1:)\n    end subroutine delete_char\nend program main",
  "1550": "program main\n    implicit none\n\n    integer, parameter :: n = 9\n    integer :: i, j, k\n    integer :: arr(n) = [2, 6, 4, 1, 3, 5, 7, 23, 12]\n    logical :: result\n\n    do i = 1, n - 2\n        do j = i + 1, n - 1\n            do k = j + 1, n\n                if (mod(arr(i), 2) /= 0 .and. mod(arr(j), 2) /= 0 .and. &\n                    mod(arr(k), 2) /= 0) then\n                    write (*, '(A, L1)') 'Result: ', (arr(i) == arr(j) + 1 .and. arr(j) == arr(k) + 1)\n                    exit\n                end if\n            end do\n        end do\n    end do\n\nend program main",
  "1556": "program main\n    implicit none\n\n    integer, parameter :: n = 987\n    character(len=:), allocatable :: result\n\n    result = add_dot(n)\n    write (*, '(A)') trim(result)\n\ncontains\n\n    function add_dot(n) result(res)\n        implicit none\n        integer, value :: n\n        character(len=:), allocatable :: res\n\n        if (n < 1000) then\n            allocate(character(len=len(trim(str(n)))+1) :: res)\n            res = str(n) // \" \"\n        else\n            allocate(character(len=len(trim(add_dot(n / 1000))) + 4) :: res)\n            res = add_dot(n / 1000) // \". \" // str(mod(n, 1000))\n        end if\n    end function add_dot\nend program main",
  "1560": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 4, m = 4\n    integer, dimension(m+1) :: rounds = (/ 1, 3, 1, 2 /)\n    integer, dimension(:), allocatable :: visited_sectors\n    integer :: i\n\n    allocate(visited_sectors(n))\n\n    call solve(n, rounds, visited_sectors)\n\n    do i = 1, size(visited_sectors)\n        write (unit=error_unit, fmt='(I0, 1X)') visited_sectors(i)\n    end do\n\ncontains\n\n    subroutine solve(n, rounds, visited_sectors)\n        implicit none\n        integer, value :: n, rounds(m+1)\n        integer, intent(out) :: visited_sectors(n)\n        integer :: current_sector, next_sector\n\n        current_sector = rounds(1)\n        visited_sectors(current_sector) = visited_sectors(current_sector) + 1\n\n        do i = 2, m+1\n            next_sector = rounds(i)\n            if (next_sector > current_sector) then\n                ! circulate the track in ascending order of sector numbers\n                ! in the counter-clockwise direction\n                visited_sectors(next_sector) = visited_sectors(next_sector) + 1\n                current_sector = next_sector\n            else\n                ! circulate the track in descending order of sector numbers\n                ! in the clockwise direction\n                visited_sectors(n + 1 - next_sector) = visited_sectors(n + 1 - next_sector) + 1\n                current_sector = n + 1 - next_sector\n            end if\n        end do\n    end subroutine solve\n\nend program main",
  "1566": "program main\n    implicit none\n\n    integer, parameter :: n = 7\n    integer, parameter :: m = 1\n    integer, parameter :: k = 3\n    integer, dimension(n) :: arr = (/ 1, 2, 4, 4, 4, 4, 3 /)\n    logical :: result\n\n    result = repeatedPattern(arr, m, k)\n    if (result) then\n        print *, \"True\"\n    else\n        print *, \"False\"\n    end if\n\ncontains\n\n    function repeatedPattern(arr, m, k) result(repeated)\n        implicit none\n        integer, intent(in) :: arr(:), m, k\n        logical :: repeated\n        integer :: i, j, count\n\n        repeated = .false.\n        do i = 1, size(arr)-m+1\n            count = 0\n            do j = i, i+m-1\n                if (arr(j) == arr(i)) then\n                    count = count + 1\n                else\n                    exit\n                end if\n            end do\n            if (count >= k) then\n                repeated = .true.\n                exit\n            end if\n        end do\n    end function repeatedPattern\nend program main",
  "1572": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n, n) :: mat\n    integer :: i, j\n    integer :: sum_diagonal\n\n    ! Example 1\n    mat(:, :) = reshape([1, 2, 3, 4, 5, 6, 7, 8, 9], shape(mat))\n    write (*, '(A, I0)') 'Example 1: ', sum_diagonal(mat)\n\n    ! Example 2\n    mat(:, :) = reshape([1, 1, 1, 1, 1, 1, 1, 1, 1], shape(mat))\n    write (*, '(A, I0)') 'Example 2: ', sum_diagonal(mat)\n\n    ! Example 3\n    mat(:, :) = reshape([5], shape(mat))\n    write (*, '(A, I0)') 'Example 3: ', sum_diagonal(mat)\n\ncontains\n\n    function sum_diagonal(mat) result(sum_)\n        implicit none\n        integer, intent(in) :: mat(:, :)\n        integer :: sum_\n        integer :: i, j\n\n        sum_ = 0\n        do i = 1, size(mat, 1)\n            if (i /= size(mat, 2)) then\n                sum_ = sum_ + mat(i, i+1)\n            end if\n            sum_ = sum_ + mat(i, i)\n            if (i /= 1) then\n                sum_ = sum_ + mat(i-1, i)\n            end if\n        end do\n    end function sum_diagonal\n\nend program main",
  "1576": "program main\n    implicit none\n\n    character(len=100) :: s\n    integer :: i, j\n\n    ! Example 1\n    s = \"?zs\"\n    call solve(s)\n    print *, s\n\n    ! Example 2\n    s = \"ubv?w\"\n    call solve(s)\n    print *, s\n\ncontains\n\n    subroutine solve(s)\n        implicit none\n        character(len=*), intent(inout) :: s\n        integer :: n\n\n        n = len_trim(s)\n        do i = 1, n - 1\n            if (s(i:i+1) == '?') then\n                do j = 97, 122\n                    if (s(i:i) /= char(j)) then\n                        s(i:i) = char(j)\n                        exit\n                    end if\n                end do\n            end if\n        end do\n    end subroutine solve\nend program main",
  "1582": "program main\n    implicit none\n\n    integer, parameter :: m = 3, n = 3\n    integer :: i, j\n    logical :: is_special(m, n)\n    integer :: num_special\n\n    ! Example 1\n    is_special(:, :) = .false.\n    is_special(1, 2) = .true.\n    write(*, '(I0)') count_special(is_special)\n\n    ! Example 2\n    is_special(:, :) = .false.\n    is_special(1, 1) = .true.\n    is_special(2, 2) = .true.\n    write(*, '(I0)') count_special(is_special)\n\ncontains\n\n    function count_special(mat) result(num_special)\n        implicit none\n        logical, intent(in) :: mat(m, n)\n        integer :: i, j, num_special\n\n        do i = 1, m\n            do j = 1, n\n                if (mat(i, j)) then\n                    if (all(mat(i, :) == 0) .and. all(mat(:, j) == 0)) then\n                        num_special = num_special + 1\n                    end if\n                end if\n            end do\n        end do\n    end function count_special\n\nend program main",
  "1588": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 100\n    real(kind=DP), dimension(n) :: arr\n    integer :: i, j, k\n    real(kind=DP) :: sum\n\n    ! read input\n    do i = 1, n\n        read (*, *) arr(i)\n    end do\n\n    ! compute sum of all odd-length subarrays\n    sum = 0.0_DP\n    do i = 1, n - 1\n        do j = i + 1, n\n            if (mod(j - i + 1, 2) /= 0) then\n                sum = sum + sum_of_subarray(arr, i, j)\n            end if\n        end do\n    end do\n\n    ! print result\n    write (unit=error_unit, fmt='(F10.2)') sum\n\ncontains\n\n    function sum_of_subarray(arr, i, j) result(sum)\n        implicit none\n        real(kind=DP), intent(in) :: arr(:)\n        integer, value :: i, j\n        integer :: k\n        real(kind=DP) :: sum\n\n        sum = 0.0_DP\n        do k = i, j\n            sum = sum + arr(k)\n        end do\n    end function sum_of_subarray\n\nend program main",
  "1592": "program main\n    implicit none\n\n    character(len=:), allocatable :: text\n    integer :: nwords, i\n\n    call get_command_argument(1, text)\n\n    nwords = count(text == ' ') + 1\n\n    if (nwords > 1) then\n        do i = 1, nwords - 1\n            write (*,'(*(g0))') text(1:i-1), ' ', text(i+1:)\n        end do\n    else\n        write (*,'(*(g0))') text\n    end if\n\nend program main",
  "1598": "program main\n    implicit none\n\n    integer :: i, n\n    character(len=10) :: logs(100)\n\n    call get_args(n, logs)\n\n    do i = 1, n\n        write (*, '(A)') trim(logs(i))\n    end do\n\ncontains\n\n    subroutine get_args(n, logs)\n        implicit none\n        integer, intent(out) :: n\n        character(len=10), intent(out) :: logs(:)\n        integer :: i\n\n        ! read input from stdin\n        read *, n\n        do i = 1, n\n            read *, logs(i)\n        end do\n    end subroutine get_args\nend program main",
  "1603": "program main\n    use ParkingSystem_mod\n    implicit none\n\n    type(ParkingSystem) :: parkingSystem\n    integer :: i\n\n    ! Example 1\n    call parkingSystem%init(1, 1, 0)\n    print '(L1)', parkingSystem%addCar(1) ! true\n    print '(L1)', parkingSystem%addCar(2) ! true\n    print '(L1)', parkingSystem%addCar(3) ! false\n    print '(L1)', parkingSystem%addCar(1) ! false\n\ncontains\n\nsubroutine init(this, big, medium, small)\n    class(ParkingSystem), intent(inout) :: this\n    integer, intent(in) :: big, medium, small\n\n    this%big = big\n    this%medium = medium\n    this%small = small\nend subroutine init\n\nfunction addCar(this, carType) result(res)\n    class(ParkingSystem), intent(inout) :: this\n    integer, intent(in) :: carType\n    logical :: res\n\n    select case (carType)\n        case (1)\n            if (this%big > 0) then\n                this%big = this%big - 1\n                res = .true.\n            else\n                res = .false.\n            end if\n        case (2)\n            if (this%medium > 0) then\n                this%medium = this%medium - 1\n                res = .true.\n            else\n                res = .false.\n            end if\n        case (3)\n            if (this%small > 0) then\n                this%small = this%small - 1\n                res = .true.\n            else\n                res = .false.\n            end if\n        case default\n            error stop 'Invalid car type'\n    end select\nend function addCar\n\nend program main\n\nmodule ParkingSystem_mod\n    implicit none\n\n    private\n    public :: ParkingSystem\n\n    type :: ParkingSystem\n        private\n        integer :: big, medium, small\n    contains\n        procedure, pass :: init => init\n        procedure, pass :: addCar => addCar\n    end type ParkingSystem\n\ncontains\n\nsubroutine init(this, big, medium, small)\n    class(ParkingSystem), intent(inout) :: this\n    integer, intent(in) :: big, medium, small\n\n    this%big = big\n    this%medium = medium\n    this%small = small\nend subroutine init\n\nfunction addCar(this, carType) result(res)\n    class(ParkingSystem), intent(inout) :: this\n    integer, intent(in) :: carType\n    logical :: res\n\n    select case (carType)\n        case (1)\n            if (this%big > 0) then\n                this%big = this%big - 1\n                res = .true.\n            else\n                res = .false.\n            end if\n        case (2)\n            if (this%medium > 0) then\n                this%medium = this%medium - 1\n                res = .true.\n            else\n                res = .false.\n            end if\n        case (3)\n            if (this%small > 0) then\n                this%small = this%small - 1\n                res = .true.\n            else\n                res = .false.\n            end if\n        case default\n            error stop 'Invalid car type'\n    end select\nend function addCar\n\nend module ParkingSystem_mod",
  "1608": "program main\n    implicit none\n\n    integer, parameter :: n = 2\n    integer, dimension(n) :: nums = (/ 3, 5 /)\n    integer :: x\n\n    x = special(nums)\n    write (*, '(I0)') x\n\ncontains\n\n    function special(nums) result(x)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: x, i, count\n\n        do i = 1, size(nums)\n            count = count_if(nums > i)\n            if (count == i) then\n                x = i\n                exit\n            end if\n        end do\n\n        if (x < 0) then\n            x = -1\n        end if\n\n    end function special\n\nend program main",
  "1614": "program main\n    ! Solves the problem:\n    ! A string is a valid parentheses string (denoted VPS) if it meets one of the following:\n    ! - It is an empty string \" \", or a single character not equal to \"( \".\n    ! - It can be written as AB (A concatenated with B), where A and B are VPS's.\n    ! - It can be written as (A), where A is a VPS.\n    implicit none\n\n    integer :: i, j, k, n, depth\n    character(len=100) :: s\n\n    ! Examples\n    print '(\"Example 1:\")'\n    s = \"(1+(2*3)+((8)/4))+1\"\n    print '(*(g0,1x))', s, depth(s)\n    print '(\"Example 2:\")'\n    s = \"(1)+((2))+(((3)))\"\n    print '(*(g0,1x))', s, depth(s)\n\ncontains\n\n    function depth(s) result(d)\n        ! Returns the nesting depth of a valid parentheses string (VPS)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: d\n\n        d = 0\n        do i = 1, len(s)\n            select case(s(i:i))\n                case(' ')\n                    cycle\n                case('(')\n                    d = d + 1\n                case(')')\n                    d = d - 1\n            end select\n        end do\n    end function depth\n\nend program main",
  "1619": "program main\n    implicit none\n\n    integer, parameter :: dp = selected_real_kind(15)\n\n    integer, dimension(:), allocatable :: arr\n    real(dp) :: mean\n\n    call get_array(arr)\n    call solve(arr, mean)\n    write (*, '(F10.5)') mean\n\ncontains\n\n    subroutine get_array(arr)\n        implicit none\n        integer, dimension(:), allocatable, intent(out) :: arr\n        integer :: i, n\n\n        read (*, *) n\n        allocate (arr(n))\n        do i = 1, n\n            read (*, *) arr(i)\n        end do\n    end subroutine get_array\n\n    subroutine solve(arr, mean)\n        implicit none\n        integer, dimension(:), intent(in) :: arr\n        real(dp), intent(out) :: mean\n        integer :: n, i, j, k, l, m, nl, nr\n        real(dp) :: sum\n\n        n = size(arr)\n        if (n < 10) then\n            stop \"Array too small\"\n        end if\n\n        ! Find the smallest 5% of the elements\n        k = int(n * 0.05)\n        l = 1\n        m = 1\n        do while (m <= k .and. l < n)\n            if (arr(l) < arr(m)) then\n                m = m + 1\n            else\n                swap(arr(l), arr(m))\n                m = m + 1\n            end if\n            l = l + 1\n        end do\n\n        ! Find the largest 5% of the elements\n        k = int(n * 0.95)\n        l = n\n        m = n\n        do while (m >= k .and. l > 1)\n            if (arr(l) > arr(m)) then\n                m = m - 1\n            else\n                swap(arr(l), arr(m))\n                m = m - 1\n            end if\n            l = l - 1\n        end do\n\n        ! Calculate the mean of the remaining elements\n        nl = l - 1\n        nr = n - m\n        sum = 0.0_dp\n        do i = 1, nl\n            sum = sum + arr(i)\n        end do\n        do i = 1, nr\n            sum = sum + arr(nl + i + 1)\n        end do\n        mean = sum / (nl + nr)\n    end subroutine solve\n\n    subroutine swap(a, b)\n        implicit none\n        integer, intent(inout) :: a, b\n        integer :: temp\n\n        temp = a\n        a = b\n        b = temp\n    end subroutine swap\nend program main",
  "1624": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    integer :: i, j, k, l, m, n\n\n    ! Example 1\n    s = 'aa '\n    write (*,*) 'Example 1:'\n    write (*,*) 'Input: ', trim(s)\n    write (*,*) 'Output: ', longest_substring(s)\n    write (*,*) ''\n\n    ! Example 2\n    s = 'abca '\n    write (*,*) 'Example 2:'\n    write (*,*) 'Input: ', trim(s)\n    write (*,*) 'Output: ', longest_substring(s)\n    write (*,*) ''\n\n    ! Example 3\n    s = 'cbzxy '\n    write (*,*) 'Example 3:'\n    write (*,*) 'Input: ', trim(s)\n    write (*,*) 'Output: ', longest_substring(s)\n    write (*,*) ''\n\ncontains\n\n    function longest_substring(s) result(res)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: res\n\n        integer :: i, j, k, l, m, n\n\n        do i = 1, len(s) - 1\n            do j = i + 1, len(s)\n                if (s(i:j) == s(i+1:j+1)) then\n                    res = max(res, j - i)\n                end if\n            end do\n        end do\n\n        if (res == 0) then\n            res = -1\n        end if\n\n    end function longest_substring\n\nend program main",
  "1629": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=10) :: keysPressed\n    integer, dimension(:), allocatable :: releaseTimes\n    integer :: maxDuration, currentDuration\n    character(len=10) :: maxKey\n\n    do while (.true.)\n        read(*,*) n\n        if (n == 0) exit\n\n        allocate(releaseTimes(n))\n        read(*,*) keysPressed\n        read(*,*) releaseTimes\n\n        maxDuration = 0\n        maxKey = \"\"\n        do i = 1, n\n            currentDuration = releaseTimes(i) - releaseTimes(i - 1)\n            if (currentDuration > maxDuration) then\n                maxDuration = currentDuration\n                maxKey = keysPressed(i:i)\n            end if\n        end do\n\n        write(*,'(A)') maxKey\n\n        deallocate(releaseTimes)\n    end do\nend program main",
  "1636": "program main\n    ! Solve the problem described in the task\n    implicit none\n\n    integer, parameter :: n = 100\n    integer :: nums(n)\n    integer :: freq(n)\n    integer :: i, j, k\n\n    ! Read input\n    read (*, *) nums\n\n    ! Initialize frequencies\n    do i = 1, n\n        freq(i) = 0\n    end do\n\n    ! Count frequencies\n    do i = 1, size(nums)\n        freq(nums(i)) = freq(nums(i)) + 1\n    end do\n\n    ! Sort by frequency (increasing)\n    do i = 1, n - 1\n        do j = i + 1, n\n            if (freq(i) < freq(j)) then\n                k = nums(i)\n                nums(i) = nums(j)\n                nums(j) = k\n            end if\n        end do\n    end do\n\n    ! Sort by value (decreasing)\n    do i = 1, n - 1\n        do j = i + 1, n\n            if (nums(i) == nums(j)) then\n                if (freq(i) > freq(j)) then\n                    k = nums(i)\n                    nums(i) = nums(j)\n                    nums(j) = k\n                end if\n            end if\n        end do\n    end do\n\n    ! Print output\n    write (*, *) nums\n\nend program main",
  "1640": "program main\n    implicit none\n\n    integer, parameter :: n = 2\n    integer, parameter :: m = 3\n    integer, parameter :: arr(n) = [15, 88]\n    integer, parameter :: pieces(m, n) = reshape([88, 15, 49, 16, 18, 49], shape(pieces))\n    logical :: result\n\n    print '(L1)', canFormArray(arr, pieces)\n\ncontains\n\n    function canFormArray(arr, pieces) result(res)\n        implicit none\n        integer, intent(in) :: arr(:), pieces(:, :)\n        logical :: res\n        integer :: i, j, k\n\n        res = .false.\n\n        do i = 1, size(pieces, 2)\n            do j = 1, size(pieces, 1)\n                if (any(arr /= pieces(j, :))) cycle\n                res = .true.\n                exit\n            end do\n            if (res) exit\n        end do\n\n    end function canFormArray\n\nend program main",
  "1646": "program main\n    implicit none\n\n    integer :: n, nums(n+1), max_val\n\n    ! example 1\n    n = 7\n    call generate_array(n, nums)\n    write(*,*) 'Example 1:'\n    write(*,*) 'n = ', n\n    write(*,*) 'nums = ', nums\n    max_val = get_max(nums)\n    write(*,*) 'Maximum value = ', max_val\n\n    ! example 2\n    n = 2\n    call generate_array(n, nums)\n    write(*,*) 'Example 2:'\n    write(*,*) 'n = ', n\n    write(*,*) 'nums = ', nums\n    max_val = get_max(nums)\n    write(*,*) 'Maximum value = ', max_val\n\n    ! example 3\n    n = 3\n    call generate_array(n, nums)\n    write(*,*) 'Example 3:'\n    write(*,*) 'n = ', n\n    write(*,*) 'nums = ', nums\n    max_val = get_max(nums)\n    write(*,*) 'Maximum value = ', max_val\n\ncontains\n\n    subroutine generate_array(n, nums)\n        implicit none\n        integer, intent(in) :: n\n        integer, intent(out) :: nums(n+1)\n\n        nums(0) = 0\n        nums(1) = 1\n        do i = 2, n\n            if (mod(i, 2) == 0) then\n                nums(i) = nums(i/2)\n            else\n                nums(i) = nums(i/2) + nums((i+1)/2)\n            end if\n        end do\n    end subroutine generate_array\n\n    function get_max(nums) result(max_val)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: max_val\n\n        max_val = maxval(nums)\n    end function get_max\n\nend program main",
  "1652": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: code = (/ 5, 7, 1, 4 /)\n    integer :: k = 3\n    integer, dimension(n) :: decrypted_code\n\n    decrypted_code = defuse_bomb(code, k)\n\n    write (*, '(A, I0, A, I0, A)') 'Decrypted code: ', decrypted_code\n\ncontains\n\n    function defuse_bomb(code, k) result(decrypted_code)\n        implicit none\n        integer, dimension(:), intent(in) :: code\n        integer, intent(in) :: k\n        integer, dimension(size(code)) :: decrypted_code\n        integer :: i\n\n        do i = 1, size(code)\n            if (k > 0) then\n                decrypted_code(i) = sum(code((i + 1):(i + k)))\n            else if (k < 0) then\n                decrypted_code(i) = sum(code((i - k):(i - 1)))\n            else\n                decrypted_code(i) = 0\n            end if\n        end do\n    end function defuse_bomb\nend program main",
  "1656": "program main\n    use :: ordered_stream_mod\n    implicit none\n\n    type(ordered_stream) :: os\n    integer :: i\n    character(len=6) :: value\n\n    ! Example 1\n    os = ordered_stream(5)\n    print '(A)', os%insert(3, 'ccccc ')\n    print '(A)', os%insert(1, 'aaaaa ')\n    print '(A)', os%insert(2, 'bbbbb ')\n    print '(A)', os%insert(5, 'eeeee ')\n    print '(A)', os%insert(4, 'ddddd ')\n    do i = 1, 5\n        write (unit=*, fmt='(*(g0))') os%insert(i, '')\n    end do\n\n    ! Example 2\n    os = ordered_stream(4)\n    print '(A)', os%insert(2, 'bbbbb ')\n    print '(A)', os%insert(3, 'ccccc ')\n    print '(A)', os%insert(1, 'aaaaa ')\n    print '(A)', os%insert(4, 'ddddd ')\n    do i = 1, 4\n        write (unit=*, fmt='(*(g0))') os%insert(i, '')\n    end do\n\n    ! Example 3\n    os = ordered_stream(3)\n    print '(A)', os%insert(1, 'aaaaa ')\n    print '(A)', os%insert(2, 'bbbbb ')\n    print '(A)', os%insert(3, 'ccccc ')\n    do i = 1, 3\n        write (unit=*, fmt='(*(g0))') os%insert(i, '')\n    end do\n\ncontains\n\n    function insert(this, id_key, value) result(chunk)\n        class(ordered_stream), intent(inout) :: this\n        integer, intent(in) :: id_key\n        character(len=*), intent(in) :: value\n        character(len=:), allocatable :: chunk(:)\n\n        if (size(this%values) < id_key) then\n            allocate(character(len=len(value)) :: chunk(0))\n        else\n            allocate(character(len=len(value)) :: chunk(1))\n            chunk(1) = value\n        end if\n\n        this%values(id_key) = value\n\n        do i = id_key - 1, 1, -1\n            if (this%values(i) > this%values(id_key)) then\n                exit\n            end if\n            chunk(1) = this%values(i)\n        end do\n\n        return\n    end function insert\n\nend program main\n\nmodule ordered_stream_mod\n    implicit none\n    private\n\n    public :: ordered_stream\n\n    type, public :: ordered_stream\n        private\n        integer :: n\n        character(len=:), allocatable :: values(:)\n    contains\n        procedure :: insert => insert\n    end type ordered_stream\n\ncontains\n\n    subroutine insert(this, id_key, value)\n        class(ordered_stream), intent(inout) :: this\n        integer, intent(in) :: id_key\n        character(len=*), intent(in) :: value\n\n        if (size(this%values) < id_key) then\n            allocate(character(len=len(value)) :: this%values(id_key))\n        end if\n\n        this%values(id_key) = value\n\n        do i = id_key - 1, 1, -1\n            if (this%values(i) > this%values(id_key)) then\n                exit\n            end if\n            this%values(i) = this%values(id_key)\n        end do\n\n        return\n    end subroutine insert\n\nend module ordered_stream_mod",
  "1662": "program main\n    implicit none\n\n    integer :: i, j\n    character(len=:), allocatable :: word1(:), word2(:)\n    logical :: result\n\n    ! Example 1\n    allocate(word1(2))\n    allocate(word2(2))\n    word1(1) = 'ab '\n    word1(2) = 'c '\n    word2(1) = 'a '\n    word2(2) = 'bc '\n    result = representSameString(word1, word2)\n    print *, result\n\n    ! Example 2\n    deallocate(word1)\n    deallocate(word2)\n    allocate(word1(2))\n    allocate(word2(2))\n    word1(1) = 'a '\n    word1(2) = 'cb '\n    word2(1) = 'ab '\n    word2(2) = 'c '\n    result = representSameString(word1, word2)\n    print *, result\n\n    ! Example 3\n    deallocate(word1)\n    deallocate(word2)\n    allocate(word1(3))\n    allocate(word2(1))\n    word1(1) = 'abc '\n    word1(2) = 'd '\n    word1(3) = 'defg '\n    word2(1) = 'abcddefg '\n    result = representSameString(word1, word2)\n    print *, result\n\ncontains\n\n    function representSameString(word1, word2) result(same)\n        implicit none\n        character(len=*), intent(in) :: word1(:), word2(:)\n        logical :: same\n\n        integer :: i, j\n        character(len=:), allocatable :: concatWord(:)\n\n        allocate(concatWord(sum(len(word1))))\n        concatWord = ''\n        do i = 1, size(word1)\n            concatWord = trim(concatWord) // trim(word1(i))\n        end do\n        do i = 1, size(word2)\n            concatWord = trim(concatWord) // trim(word2(i))\n        end do\n        same = (concatWord == word2(1))\n    end function representSameString\n\nend program main",
  "1668": "program main\n    implicit none\n\n    character(len=*) :: sequence, word\n    integer :: k_repeating\n\n    ! Example 1\n    sequence = 'ababc '\n    word = 'ab '\n    print *, max_k_repeating(sequence, word)\n\n    ! Example 2\n    sequence = 'ababc '\n    word = 'ba '\n    print *, max_k_repeating(sequence, word)\n\n    ! Example 3\n    sequence = 'ababc '\n    word = 'ac '\n    print *, max_k_repeating(sequence, word)\n\ncontains\n\n    function max_k_repeating(sequence, word) result(k_repeating)\n        implicit none\n        character(len=*), intent(in) :: sequence, word\n        integer :: k_repeating\n\n        integer :: i, j, k\n\n        k_repeating = 0\n        do k = 1, len(sequence)-len(word)+1\n            do i = 1, len(word)\n                j = k + (i-1)*k\n                if (sequence(j:j+len(word)-1) /= word) exit\n            end do\n            if (i == len(word)+1) then\n                k_repeating = max(k_repeating, k)\n            end if\n        end do\n    end function max_k_repeating\n\nend program main",
  "1672": "program main\n    implicit none\n\n    integer, parameter :: m = 2, n = 3\n    integer, dimension(m, n) :: accounts\n    integer :: i, j, wealth\n\n    ! Example 1\n    accounts = reshape([1, 2, 3, 3, 2, 1], shape=[m, n])\n    write (*, '(a, i0)') 'Example 1: ', max_wealth(accounts)\n\n    ! Example 2\n    accounts = reshape([1, 5, 7, 3], shape=[m, n])\n    write (*, '(a, i0)') 'Example 2: ', max_wealth(accounts)\n\n    ! Example 3\n    accounts = reshape([2, 8, 7, 7, 1, 3, 1, 9, 5], shape=[m, n])\n    write (*, '(a, i0)') 'Example 3: ', max_wealth(accounts)\n\ncontains\n\n    function max_wealth(accounts) result(wealth)\n        implicit none\n        integer, intent(in) :: accounts(:, :)\n        integer :: i, j, wealth\n\n        wealth = 0\n        do i = 1, size(accounts, 1)\n            do j = 1, size(accounts, 2)\n                wealth = max(wealth, sum(accounts(i, :)))\n            end do\n        end do\n    end function max_wealth\nend program main",
  "1678": "program main\n    implicit none\n\n    character(len=100) :: command\n    character(len=100) :: result\n\n    ! Example 1\n    command = \"G()(al) \"\n    result = goalParser(command)\n    write (*,*) trim(result)\n\n    ! Example 2\n    command = \"G()()()()(al) \"\n    result = goalParser(command)\n    write (*,*) trim(result)\n\n    ! Example 3\n    command = \"(al)G(al)()()G \"\n    result = goalParser(command)\n    write (*,*) trim(result)\n\ncontains\n\n    function goalParser(command) result(result)\n        implicit none\n        character(len=*), intent(in) :: command\n        character(len=100) :: result\n\n        integer :: i\n        logical :: found_g\n\n        result = \"\"\n        found_g = .false.\n\n        do i = 1, len(command)\n            select case (command(i:i))\n                case (\"G\")\n                    if (.not. found_g) then\n                        result = trim(result) // \"G\"\n                        found_g = .true.\n                    end if\n                case (\"()\")\n                    result = trim(result) // \"o\"\n                case (\"(al)\")\n                    result = trim(result) // \"al\"\n            end select\n        end do\n\n    end function goalParser\n\nend program main",
  "1684": "program main\n    implicit none\n\n    character(len=*), parameter :: allowed = \"ab \"\n    character(len=*), parameter :: words(5) = [\"ad \", \"bd \", \"aaab \", \"baa \", \"badab \"]\n    integer :: n_consistent\n\n    n_consistent = count_consistent(allowed, words)\n    write (*, \"(A, I0)\") \"Number of consistent strings:\", n_consistent\n\ncontains\n\n    function count_consistent(allowed, words) result(n)\n        implicit none\n        character(len=*), intent(in) :: allowed\n        character(len=*), intent(in) :: words(:)\n        integer :: i, j, n\n\n        do i = 1, size(words)\n            do j = 1, len(words(i))\n                if (index(allowed, words(i)(j:j)) == 0) then\n                    exit\n                end if\n            end do\n            if (j > len(words(i))) then\n                n = n + 1\n            end if\n        end do\n    end function count_consistent\nend program main",
  "1688": "program main\n    implicit none\n\n    integer :: n\n    integer :: result\n\n    print '(A)', 'Enter the number of teams:'\n    read *, n\n\n    result = solve_problem(n)\n\n    print '(A, I0)', 'The number of matches played in the tournament until a winner is decided is: ', result\n\ncontains\n\n    function solve_problem(n) result(result_)\n        implicit none\n\n        integer, intent(in) :: n\n        integer :: result_\n\n        if (mod(n, 2) == 0) then\n            ! Even number of teams\n            result_ = n / 2\n        else\n            ! Odd number of teams\n            result_ = (n - 1) / 2 + 1\n        end if\n\n    end function solve_problem\n\nend program main",
  "1694": "program main\n\n! This program solves the following problem:\n!\n! Given a phone number as a string `number`, you would like to reformat the phone number in a certain manner.\n! Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits.\n! The final digits are then grouped as follows:\n!\n! * 2 digits: A single block of length 2.\n! * 3 digits: A single block of length 3.\n! * 4 digits: Two blocks of length 2 each.\n!\n! The blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2.\n!\n! Return the phone number after formatting.\n!\n! Example 1:\n! Input: number = \"1-23-45 6 \"\n! Output: \"123-456 \"\n! Explanation: The digits are \"123456 \".\n! Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123 \".\n! Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is \"456 \".\n! Joining the blocks gives \"123-456 \".\n!\n! Example 2:\n! Input: number = \"123 4-567 \"\n! Output: \"123-45-67 \"\n! Explanation: The digits are \"1234567 \".\n! Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123 \".\n! Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are \"45 \" and \"67 \".\n! Joining the blocks gives \"123-45-67 \".\n!\n! Example 3:\n! Input: number = \"123 4-5678 \"\n! Output: \"123-456-78 \"\n! Explanation: The digits are \"12345678 \".\n! Step 1: The 1st block is \"123 \".\n! Step 2: The 2nd block is \"456 \".\n! Step 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is \"78 \".\n! Joining the blocks gives \"123-456-78 \".\n!\n! Constraints:\n!\n!     2 <= number.length <= 100\n!     number consists of digits and the characters '-' and ' '.\n!     There are at least two digits in number.\n\nimplicit none\n\ncharacter(len=:), allocatable :: number\ninteger :: i, j, k, l, m\n\nnumber = \"1-23-45 6 \"\ncall format_phone_number(number)\nwrite (*,*) trim(number) ! \"123-456 \"\n\nnumber = \"123 4-567 \"\ncall format_phone_number(number)\nwrite (*,*) trim(number) ! \"123-45-67 \"\n\nnumber = \"123 4-5678 \"\ncall format_phone_number(number)\nwrite (*,*) trim(number) ! \"123-456-78 \"\n\ncontains\n\nsubroutine format_phone_number(number)\n    implicit none\n    character(len=*), intent(inout) :: number\n    integer :: n, i, j, k, l, m\n    logical :: has_dash\n\n    ! Remove all spaces and dashes\n    do i = 1, len(number)\n        if (number(i:i) == ' ' .or. number(i:i) == '-') then\n            number(i:i) = ''\n        end if\n    end do\n\n    ! Group the digits into blocks of length 3 until there are 4 or fewer digits\n    n = len(number)\n    k = 0\n    do while (n > 0)\n        if (k == 0) then\n            k = min(3, n)\n",
  "1700": "program main\n    implicit none\n\n    integer :: n_students, n_sandwiches\n    integer, dimension(:), allocatable :: students, sandwiches\n    integer :: i, j, k, l\n\n    ! read input\n    read(*,*) n_students, n_sandwiches\n    allocate(students(n_students))\n    allocate(sandwiches(n_sandwiches))\n    do i = 1, n_students\n        read(*,*) students(i)\n    end do\n    do i = 1, n_sandwiches\n        read(*,*) sandwiches(i)\n    end do\n\n    ! solve problem\n    do while (any(students /= 0))\n        if (students(1) == sandwiches(1)) then\n            ! student at front of queue prefers top sandwich\n            students(1) = 0\n            sandwiches(1) = 0\n        else\n            ! student at front of queue does not prefer top sandwich\n            ! move them to the back of the queue\n            do i = 1, n_students - 1\n                students(i) = students(i + 1)\n            end do\n            students(n_students) = 0\n        end if\n    end do\n\n    ! print output\n    write(*,*) \"Number of students that are unable to eat: \", count(students /= 0)\n\nend program main",
  "1704": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    logical :: result\n\n    ! Example 1\n    s = \"book \"\n    write(*,*) \"Example 1:\"\n    write(*,*) \"Input: \", s\n    result = alike(s)\n    write(*,*) \"Output: \", result\n    write(*,*) \"\"\n\n    ! Example 2\n    s = \"textbook \"\n    write(*,*) \"Example 2:\"\n    write(*,*) \"Input: \", s\n    result = alike(s)\n    write(*,*) \"Output: \", result\n    write(*,*) \"\"\n\ncontains\n\nlogical function alike(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer :: nvowels\n    integer :: i\n\n    nvowels = 0\n    do i = 1, len(s)/2\n        select case (s(i:i))\n            case (\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n                nvowels = nvowels + 1\n        end select\n    end do\n\n    alike = (nvowels == nvowels(s(len(s)/2+1:)))\nend function alike\n\ninteger function nvowels(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer :: i\n\n    nvowels = 0\n    do i = 1, len(s)\n        select case (s(i:i))\n            case (\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n                nvowels = nvowels + 1\n        end select\n    end do\nend function nvowels\n\nend program main",
  "1708": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: A, B\n\n    A = [1, 3, 2, 4]\n    B = [1, 2, 2, 4]\n    print '(L1)', larger_than(A, B)\n\n    A = [1, 4, 5, 2, 3]\n    B = [2, 1, 1, 1]\n    print '(L1)', larger_than(A, B)\n\ncontains\n\n    logical function larger_than(A, B) result(larger)\n        implicit none\n        integer, intent(in) :: A(:), B(:)\n        integer :: i\n\n        do i = 1, size(A)\n            if (A(i) /= B(i)) then\n                larger = A(i) > B(i)\n                exit\n            end if\n        end do\n    end function larger_than\n\nend program main",
  "1710": "program main\n    implicit none\n\n    integer, parameter :: n_examples = 2\n    integer, parameter :: n_boxes = 4\n    integer, parameter :: n_types = 3\n    integer, parameter :: max_units = 1000\n    integer, parameter :: max_truck_size = 1000\n\n    integer :: i, j, k, l\n    integer :: boxTypes(n_types, 2)\n    integer :: truckSize\n    integer :: total_units\n\n    ! Examples\n    boxTypes(:, :) = reshape([1, 3, 2, 2, 3, 1], shape=[n_types, 2])\n    truckSize = 4\n    call solve(boxTypes, truckSize, total_units)\n    write (*, '(A, I0, A, I0, A)') 'Example 1: ', total_units, &\n        ' units can be put on the truck.'\n\n    boxTypes(:, :) = reshape([5, 10, 2, 5, 4, 7, 3, 9], shape=[n_types, 2])\n    truckSize = 10\n    call solve(boxTypes, truckSize, total_units)\n    write (*, '(A, I0, A, I0, A)') 'Example 2: ', total_units, &\n        ' units can be put on the truck.'\n\ncontains\n\n    subroutine solve(boxTypes, truckSize, total_units)\n        implicit none\n        integer, intent(in) :: boxTypes(:, :)\n        integer, intent(in) :: truckSize\n        integer, intent(out) :: total_units\n        integer :: i, j, k, l\n        integer :: current_truck_size\n        integer :: current_total_units\n\n        current_truck_size = 0\n        current_total_units = 0\n        do i = 1, size(boxTypes, 1)\n            if (current_truck_size + boxTypes(i, 1) > truckSize) then\n                exit\n            end if\n            current_truck_size = current_truck_size + boxTypes(i, 1)\n            current_total_units = current_total_units + &\n                boxTypes(i, 1) * boxTypes(i, 2)\n        end do\n        total_units = current_total_units\n    end subroutine solve\n\nend program main",
  "1716": "program main\n    implicit none\n\n    integer :: n, i, j\n    integer :: days(7), prev_days(7)\n    integer :: total\n\n    do while (.true.)\n        read(*,*) n\n        if (n == -1) exit\n\n        ! Initialize the array with the starting values\n        days = (/1, 1, 1, 1, 1, 1, 1/)\n\n        ! Loop through the days\n        do i=2,n\n            ! If it's a Monday, add one to the previous Monday's value\n            if (mod(i,7) == 1) then\n                days(1) = days(1) + 1\n            else\n                ! Otherwise, add one to the previous day's value\n                days(mod(i-1,7)+1) = days(mod(i-1,7)+1) + 1\n            end if\n        end do\n\n        ! Print the total\n        write(*,'(I0)') sum(days)\n    end do\n\nend program main",
  "1720": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: arr\n    integer, dimension(n - 1) :: encoded\n    integer :: first\n\n    ! Examples\n    encoded = [1, 2, 3]\n    first = 1\n    call solve(encoded, first, arr)\n    write (*, '(A)') 'Example 1:'\n    write (*, '(A)') 'encoded = [1,2,3]'\n    write (*, '(A)') 'first = 1'\n    write (*, '(A)') 'arr = [1,0,2,1]'\n    write (*, '(A)') ''\n    write (*, '(A)') 'Example 2:'\n    write (*, '(A)') 'encoded = [6,2,7,3]'\n    write (*, '(A)') 'first = 4'\n    write (*, '(A)') 'arr = [4,2,0,7,4]'\n\ncontains\n\n    subroutine solve(encoded, first, arr)\n        implicit none\n        integer, intent(in) :: encoded(:), first\n        integer, intent(out) :: arr(:)\n\n        integer :: i, j\n\n        arr(1) = first\n        do i = 2, size(arr)\n            arr(i) = arr(i - 1) ^ encoded(i - 2)\n        end do\n    end subroutine solve\n\nend program main",
  "1725": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: rectangles\n    integer :: i, k, maxLen, count\n\n    ! Examples\n    rectangles(1) = [5, 8]\n    rectangles(2) = [3, 9]\n    rectangles(3) = [5, 12]\n    rectangles(4) = [16, 5]\n\n    ! Output\n    write (*, '(A)') 'Example 1:'\n    call solve(rectangles, maxLen, count)\n    write (*, '(I0, A, I0)') count, ' rectangles can make a square with a side length of ', maxLen\n    write (*, '(A)') ''\n\n    rectangles(1) = [2, 3]\n    rectangles(2) = [3, 7]\n    rectangles(3) = [4, 3]\n    rectangles(4) = [3, 7]\n\n    ! Output\n    write (*, '(A)') 'Example 2:'\n    call solve(rectangles, maxLen, count)\n    write (*, '(I0, A, I0)') count, ' rectangles can make a square with a side length of ', maxLen\n    write (*, '(A)') ''\n\ncontains\n\n    subroutine solve(rectangles, maxLen, count)\n        implicit none\n        integer, intent(in) :: rectangles(:, :)\n        integer, intent(out) :: maxLen, count\n        integer :: i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z\n\n        maxLen = -huge(maxLen)\n        count = 0\n\n        do i = 1, size(rectangles, 1)\n            do j = 1, size(rectangles, 2)\n                k = rectangles(i, 1)\n                l = rectangles(i, 2)\n                m = min(k, l)\n                n = max(k, l)\n                p = (m + 1) / 2\n                q = (n + 1) / 2\n                r = (p * q) / 2\n                s = (r + 1) / 2\n                t = (s + 1) / 2\n                u = (t + 1) / 2\n                v = (u + 1) / 2\n                w = (v + 1) / 2\n                x = (w + 1) / 2\n                y = (x + 1) / 2\n                z = (y + 1) / 2\n                if (z > maxLen) then\n                    maxLen = z\n                    count = 1\n                else if (z == maxLen) then\n                    count = count + 1\n                end if\n            end do\n        end do\n    end subroutine solve\nend program main",
  "1732": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: gain\n    integer :: i\n\n    ! Examples\n    gain = [-5, 1, 5, 0, -7]\n    call solve(gain)\n    gain = [-4, -3, -2, -1, 4, 3, 2]\n    call solve(gain)\n\ncontains\n\n    subroutine solve(gain)\n        implicit none\n        integer, intent(in) :: gain(:)\n        integer :: altitude\n\n        altitude = 0\n        do i = 1, size(gain)\n            altitude = max(altitude, altitude + gain(i))\n        end do\n        write (*, '(I0)') altitude\n    end subroutine solve\nend program main",
  "1736": "program main\n    implicit none\n\n    character(len=8) :: time\n    integer :: hh, mm\n\n    time = \"2?:?0\"\n    call solve(time, hh, mm)\n    write (*, \"(A, I2, A, I2)\") \"Latest valid time from \", time, \" is \", hh, \":\", mm\n\n    time = \"0?:3?\"\n    call solve(time, hh, mm)\n    write (*, \"(A, I2, A, I2)\") \"Latest valid time from \", time, \" is \", hh, \":\", mm\n\n    time = \"1?:22\"\n    call solve(time, hh, mm)\n    write (*, \"(A, I2, A, I2)\") \"Latest valid time from \", time, \" is \", hh, \":\", mm\n\ncontains\n\n    subroutine solve(time, hh, mm)\n        implicit none\n        character(len=*), intent(in) :: time\n        integer, intent(out) :: hh, mm\n\n        integer :: i, j\n        logical :: found\n\n        do i = 1, 2\n            if (time(i:i) == '?') then\n                do j = 0, 9\n                    if (j /= 0 .and. j /= 6) then\n                        time(i:i) = char(ichar('0') + j)\n                        found = .true.\n                        exit\n                    end if\n                end do\n                if (.not. found) then\n                    stop \"No solution\"\n                end if\n            end if\n        end do\n\n        read (time, \"(I2, A, I2)\") hh, \":\", mm\n    end subroutine solve\nend program main",
  "1742": "program main\n    implicit none\n\n    integer :: n, lowLimit, highLimit, i, j, k, maxCount, count\n\n    ! read input\n    read(*,*) n\n    read(*,*) lowLimit\n    read(*,*) highLimit\n\n    ! initialize variables\n    maxCount = 0\n\n    ! loop over all possible box numbers\n    do i = 1, infinity\n        ! reset count for current box\n        count = 0\n\n        ! loop over all balls\n        do j = lowLimit, highLimit\n            ! check if ball belongs to current box\n            if (sumDigits(j) == i) then\n                ! increment count for current box\n                count = count + 1\n            end if\n        end do\n\n        ! check if current box has more balls than previous one\n        if (count > maxCount) then\n            maxCount = count\n        end if\n    end do\n\n    ! print result\n    write (*,*) maxCount\n\ncontains\n\n    function sumDigits(n) result(sum)\n        implicit none\n        integer, intent(in) :: n\n        integer :: sum\n        integer :: digit\n\n        sum = 0\n        do while (n /= 0)\n            digit = mod(n, 10)\n            sum = sum + digit\n            n = n / 10\n        end do\n    end function sumDigits\n\nend program main",
  "1748": "program main\n    implicit none\n\n    integer :: nums(5)\n\n    nums = [1, 2, 3, 2, 1]\n    print '(I0)', sum_unique_elements(nums)\n\n    nums = [1, 1, 1, 1, 1]\n    print '(I0)', sum_unique_elements(nums)\n\n    nums = [1, 2, 3, 4, 5]\n    print '(I0)', sum_unique_elements(nums)\n\ncontains\n\n    function sum_unique_elements(nums) result(sum)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: sum, i, count\n\n        sum = 0\n        do i = 1, size(nums)\n            count = 0\n            do j = 1, size(nums)\n                if (nums(i) == nums(j)) then\n                    count = count + 1\n                end if\n            end do\n            if (count == 1) then\n                sum = sum + nums(i)\n            end if\n        end do\n    end function sum_unique_elements\n\nend program main",
  "1752": "program main\n    implicit none\n\n    integer :: i, n\n    logical :: result\n    integer, allocatable :: nums(:)\n\n    ! Example 1\n    allocate(nums(5))\n    nums = [3, 4, 5, 1, 2]\n    result = check(nums)\n    if (result) then\n        write (*, '(a)') \"Example 1: True\"\n    else\n        write (*, '(a)') \"Example 1: False\"\n    end if\n    deallocate(nums)\n\n    ! Example 2\n    allocate(nums(4))\n    nums = [2, 1, 3, 4]\n    result = check(nums)\n    if (result) then\n        write (*, '(a)') \"Example 2: True\"\n    else\n        write (*, '(a)') \"Example 2: False\"\n    end if\n    deallocate(nums)\n\n    ! Example 3\n    allocate(nums(3))\n    nums = [1, 2, 3]\n    result = check(nums)\n    if (result) then\n        write (*, '(a)') \"Example 3: True\"\n    else\n        write (*, '(a)') \"Example 3: False\"\n    end if\n    deallocate(nums)\n\ncontains\n\n    function check(nums) result(result)\n        implicit none\n        integer, intent(in) :: nums(:)\n        logical :: result\n        integer :: i, j, k, l, m, n\n\n        ! Check if the array was originally sorted in non-decreasing order\n        do i = 2, size(nums)\n            if (nums(i) < nums(i-1)) then\n                result = .false.\n                return\n            end if\n        end do\n\n        ! Check if the array was rotated some number of positions (including zero)\n        do i = 1, size(nums) - 1\n            do j = i + 1, size(nums)\n                if (nums(j) == nums(i)) then\n                    result = .true.\n                    return\n                end if\n            end do\n        end do\n\n        result = .false.\n\n    end function check\n\nend program main",
  "1758": "program main\n    implicit none\n\n    integer :: i, j, k, n, m\n    character(len=100) :: s\n\n    ! Examples\n    write (*,*) \"Example 1:\"\n    s = \"0100 \"\n    call solve(s)\n    write (*,*) \"Expected: 1\"\n    write (*,*) \"Actual:\", s\n\n    write (*,*) \"Example 2:\"\n    s = \"10 \"\n    call solve(s)\n    write (*,*) \"Expected: 0\"\n    write (*,*) \"Actual:\", s\n\n    write (*,*) \"Example 3:\"\n    s = \"1111 \"\n    call solve(s)\n    write (*,*) \"Expected: 2\"\n    write (*,*) \"Actual:\", s\n\ncontains\n\n    subroutine solve(s)\n        implicit none\n        character(len=*), intent(inout) :: s\n\n        ! Variables\n        integer :: i, j, k, n, m\n\n        ! Initialize variables\n        n = len(s)\n        m = 0\n\n        ! Check if string is already alternating\n        do i = 1, n - 1\n            if (s(i) == s(i+1)) then\n                exit\n            end if\n        end do\n\n        if (i == n) then\n            return\n        end if\n\n        ! Find first non-alternating character\n        do i = 1, n\n            if (s(i) /= s(i+1)) then\n                exit\n            end if\n        end do\n\n        ! Change character to opposite value\n        if (s(i) == '0') then\n            s(i) = '1'\n        else\n            s(i) = '0'\n        end if\n\n        ! Update counter\n        m = m + 1\n\n        ! Recursively call function until string is alternating\n        call solve(s)\n\n    end subroutine solve\n\nend program main",
  "1763": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    integer :: i, j\n\n    ! Examples\n    s = \"YazaAay \"\n    print *, longestNiceSubstring(s)\n    s = \"Bb \"\n    print *, longestNiceSubstring(s)\n    s = \"c \"\n    print *, longestNiceSubstring(s)\n\ncontains\n\n    function longestNiceSubstring(s) result(res)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=:), allocatable :: res\n        logical :: found\n\n        allocate(character(len=size(s)) :: res)\n        res = \"\"\n        do i = 1, size(s) - 1\n            found = .false.\n            do j = 1, size(s) - i\n                if (isNiceString(s(i+j:i+j))) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) then\n                res = s(i:i+j-1)\n            end if\n        end do\n    end function longestNiceSubstring\n\n    function isNiceString(s) result(res)\n        implicit none\n        character(len=*), intent(in) :: s\n        logical :: res\n\n        res = .false.\n        do i = 1, len_trim(s)\n            if (index(s, char(ichar('A') + i - 1)) /= 0 .and. &\n                index(s, char(ichar('a') + i - 1)) /= 0) then\n                res = .true.\n                exit\n            end if\n        end do\n    end function isNiceString\n\nend program main",
  "1768": "program main\n    implicit none\n\n    character(len=100) :: word1, word2\n    character(len=200) :: merged\n\n    ! Example 1\n    word1 = 'abc '\n    word2 = 'pqr '\n    call merge_strings(word1, word2, merged)\n    print *, trim(merged)\n\n    ! Example 2\n    word1 = 'ab '\n    word2 = 'pqrs '\n    call merge_strings(word1, word2, merged)\n    print *, trim(merged)\n\n    ! Example 3\n    word1 = 'abcd '\n    word2 = 'pq '\n    call merge_strings(word1, word2, merged)\n    print *, trim(merged)\n\ncontains\n\n    subroutine merge_strings(word1, word2, merged)\n        implicit none\n        character(len=*), intent(in) :: word1, word2\n        character(len=*), intent(out) :: merged\n        integer :: i, j, k\n\n        merged = ''\n        i = 1\n        j = 1\n        do while (i <= len(word1) .and. j <= len(word2))\n            merged = merged // word1(i:i) // word2(j:j)\n            i = i + 1\n            j = j + 1\n        end do\n\n        if (i <= len(word1)) then\n            merged = merged // word1(i:)\n        else if (j <= len(word2)) then\n            merged = merged // word2(j:)\n        end if\n\n    end subroutine merge_strings\n\nend program main",
  "1773": "program main\n    implicit none\n\n    integer :: i, j, n, m\n    character(len=10) :: ruleKey, ruleValue\n    character(len=10), allocatable :: items(:, :)\n    integer :: numMatchingItems\n\n    ! read input\n    read(*,*) n\n    allocate(items(n,3))\n    do i = 1, n\n        read(*,*) items(i,:)\n    end do\n    read(*,*) ruleKey\n    read(*,*) ruleValue\n\n    ! solve problem\n    numMatchingItems = countMatchingItems(items, ruleKey, ruleValue)\n\n    ! print output\n    write(*,*) numMatchingItems\n\ncontains\n\n    function countMatchingItems(items, ruleKey, ruleValue) result(numMatchingItems)\n        implicit none\n        integer :: i, j, n, m\n        character(len=10), intent(in) :: ruleKey, ruleValue\n        character(len=10), allocatable :: items(:, :)\n        integer :: numMatchingItems\n\n        n = size(items, 1)\n        m = size(items, 2)\n        numMatchingItems = 0\n        do i = 1, n\n            do j = 1, m\n                if (ruleKey == \"type \" .and. ruleValue == items(i,j)) then\n                    numMatchingItems = numMatchingItems + 1\n                    exit\n                else if (ruleKey == \"color \" .and. ruleValue == items(i,j)) then\n                    numMatchingItems = numMatchingItems + 1\n                    exit\n                else if (ruleKey == \"name \" .and. ruleValue == items(i,j)) then\n                    numMatchingItems = numMatchingItems + 1\n                    exit\n                end if\n            end do\n        end do\n    end function countMatchingItems\n\nend program main",
  "1779": "program main\n    implicit none\n\n    integer :: x, y, i, n, ans\n    integer, dimension(:, :), allocatable :: points\n\n    read(*, *) x, y, n\n    allocate(points(n, 2))\n    do i = 1, n\n        read(*, *) points(i, :)\n    end do\n\n    ans = solve(x, y, points)\n    write(*, '(I0)') ans\n\ncontains\n\n    function solve(x, y, points) result(ans)\n        implicit none\n        integer, intent(in) :: x, y, points(:, :)\n        integer :: i, j, k, m, n, ans\n        logical :: found\n\n        ans = -1\n        found = .false.\n        do i = 1, size(points, 1)\n            if (points(i, 1) == x .or. points(i, 2) == y) then\n                found = .true.\n                exit\n            end if\n        end do\n        if (.not. found) return\n\n        ans = i - 1\n        do j = 1, size(points, 1)\n            if (j /= i) then\n                m = abs(points(i, 1) - points(j, 1))\n                n = abs(points(i, 2) - points(j, 2))\n                if (m + n < ans) then\n                    ans = m + n\n                end if\n            end if\n        end do\n\n    end function solve\n\nend program main",
  "1784": "program main\n    implicit none\n\n    character(len=100) :: s\n    logical :: result\n\n    ! Example 1\n    s = \"1001\"\n    result = contains_contiguous_segment_of_ones(s)\n    if (result) then\n        write (*,*) \"FAILURE: Expected false but got true for input \", s\n    else\n        write (*,*) \"SUCCESS: Expected false and got false for input \", s\n    end if\n\n    ! Example 2\n    s = \"110\"\n    result = contains_contiguous_segment_of_ones(s)\n    if (.not. result) then\n        write (*,*) \"FAILURE: Expected true but got false for input \", s\n    else\n        write (*,*) \"SUCCESS: Expected true and got true for input \", s\n    end if\n\ncontains\n\n    function contains_contiguous_segment_of_ones(s) result(res)\n        implicit none\n        character(len=*), intent(in) :: s\n        logical :: res\n\n        integer :: i, j\n\n        res = .false.\n\n        do i = 2, len(s) - 1\n            if (s(i:i) == '1') then\n                do j = i + 1, len(s)\n                    if (s(j:j) /= '1') exit\n                end do\n                if (j - i > 1) then\n                    res = .true.\n                    exit\n                end if\n            end if\n        end do\n\n    end function contains_contiguous_segment_of_ones\n\nend program main",
  "1790": "program main\n    implicit none\n\n    integer :: i, j, k\n    logical :: result\n    character(len=100) :: s1, s2\n\n    ! Example 1\n    s1 = 'bank '\n    s2 = 'kanb '\n    result = can_make_equal(s1, s2)\n    if (result) then\n        write (*,*) 'Example 1: True'\n    else\n        write (*,*) 'Example 1: False'\n    end if\n\n    ! Example 2\n    s1 = 'attack '\n    s2 = 'defend '\n    result = can_make_equal(s1, s2)\n    if (result) then\n        write (*,*) 'Example 2: True'\n    else\n        write (*,*) 'Example 2: False'\n    end if\n\n    ! Example 3\n    s1 = 'kelb '\n    s2 = 'kelb '\n    result = can_make_equal(s1, s2)\n    if (result) then\n        write (*,*) 'Example 3: True'\n    else\n        write (*,*) 'Example 3: False'\n    end if\n\ncontains\n\n    function can_make_equal(s1, s2) result(res)\n        implicit none\n        character(len=*), intent(in) :: s1, s2\n        logical :: res\n        integer :: i, j, k\n\n        do i = 1, len(s1)\n            do j = 1, len(s2)\n                if (s1(i:i) /= s2(j:j)) then\n                    cycle\n                end if\n                k = max(i, j)\n                if (k > 1 .and. s1(k-1:k-1) /= s2(k-1:k-1)) then\n                    cycle\n                end if\n                res = .true.\n                exit\n            end do\n            if (res) exit\n        end do\n\n        if (.not. res) then\n            do i = 1, len(s1)\n                do j = 1, len(s2)\n                    if (s1(i:i) /= s2(j:j)) then\n                        cycle\n                    end if\n                    k = min(i, j)\n                    if (k < len(s1) .and. s1(k+1:k+1) /= s2(k+1:k+1)) then\n                        cycle\n                    end if\n                    res = .true.\n                    exit\n                end do\n                if (res) exit\n            end do\n        end if\n\n    end function can_make_equal\n\nend program main",
  "1791": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n-1) :: edges\n    integer :: i, j, k, center\n\n    ! Example 1\n    edges = reshape([1, 2, 4, 2], shape=[n-1])\n    write (*, '(A, I0)') 'Example 1: ', find_center(edges)\n\n    ! Example 2\n    edges = reshape([1, 2, 5, 1, 1, 3, 1, 4], shape=[n-1])\n    write (*, '(A, I0)') 'Example 2: ', find_center(edges)\n\ncontains\n\n    function find_center(edges) result(center)\n        implicit none\n        integer, intent(in) :: edges(:)\n        integer :: center\n        logical, allocatable :: visited(:)\n        integer :: i, j, k\n\n        allocate(visited(size(edges)))\n        visited = .false.\n\n        do i = 1, size(edges)\n            if (.not. visited(edges(i))) then\n                call dfs(edges, edges(i), visited)\n            end if\n        end do\n\n        center = 0\n        do i = 1, size(edges)\n            if (visited(edges(i))) then\n                center = edges(i)\n                exit\n            end if\n        end do\n\n    contains\n\n        recursive subroutine dfs(edges, node, visited)\n            implicit none\n            integer, intent(in) :: edges(:)\n            integer, intent(in) :: node\n            logical, intent(inout) :: visited(:)\n            integer :: i\n\n            visited(node) = .true.\n\n            do i = 1, size(edges)\n                if ((edges(i) /= node).and..not. visited(edges(i))) then\n                    call dfs(edges, edges(i), visited)\n                end if\n            end do\n\n        end subroutine dfs\n\n    end function find_center\n\nend program main",
  "1796": "program main\n    implicit none\n\n    character(len=500) :: s\n    integer :: i, j, n, m, result\n\n    ! Example 1\n    s = \"dfa12321afd \"\n    write (*,*) 'Example 1:'\n    write (*,*) 'Input: ', s\n    result = second_largest_digit(s)\n    write (*,*) 'Output: ', result\n    write (*,*) ''\n\n    ! Example 2\n    s = \"abc1111 \"\n    write (*,*) 'Example 2:'\n    write (*,*) 'Input: ', s\n    result = second_largest_digit(s)\n    write (*,*) 'Output: ', result\n    write (*,*) ''\n\ncontains\n\n    function second_largest_digit(s) result(result)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: result\n        logical :: found\n\n        found = .false.\n        result = -1\n        do i = 1, len(s)\n            if (is_digit(s(i:i))) then\n                if (.not. found) then\n                    found = .true.\n                    result = ichar(s(i:i)) - ichar('0')\n                else\n                    if (ichar(s(i:i)) - ichar('0') > result) then\n                        result = ichar(s(i:i)) - ichar('0')\n                    end if\n                end if\n            end if\n        end do\n    end function second_largest_digit\n\n    function is_digit(c) result(res)\n        implicit none\n        character(len=*), intent(in) :: c\n        logical :: res\n\n        res = any(c == ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'])\n    end function is_digit\n\nend program main",
  "1800": "program max_ascending_subarray_sum\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: nums\n    integer :: i, j, k, l, r, max_sum\n\n    ! Examples\n    nums = reshape([10, 20, 30, 5, 10, 50], shape=[n])\n    write(*, '(a, i0)') 'Example 1: ', max_ascending_subarray_sum(nums)\n    nums = reshape([10, 20, 30, 40, 50], shape=[n])\n    write(*, '(a, i0)') 'Example 2: ', max_ascending_subarray_sum(nums)\n    nums = reshape([12, 17, 15, 13, 10, 11, 12], shape=[n])\n    write(*, '(a, i0)') 'Example 3: ', max_ascending_subarray_sum(nums)\n\ncontains\n\n    function max_ascending_subarray_sum(nums) result(max_sum)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: max_sum, current_sum, i, j\n\n        max_sum = 0\n        do i = 1, size(nums) - 1\n            current_sum = 0\n            do j = i, size(nums)\n                if (current_sum >= 0 .and. nums(j) > nums(j-1)) then\n                    current_sum = current_sum + nums(j)\n                else\n                    exit\n                end if\n                max_sum = max(max_sum, current_sum)\n            end do\n        end do\n    end function max_ascending_subarray_sum\n\nend program max_ascending_subarray_sum",
  "1805": "program main\n    implicit none\n\n    character(len=1000) :: word\n    integer :: n\n\n    call get_command_argument(1, word)\n\n    n = count_integers(word)\n\n    print '(I0)', n\n\ncontains\n\n    function count_integers(str) result(n)\n        implicit none\n        character(*), intent(in) :: str\n        integer :: i, j, k, n\n\n        n = 0\n        do i = 1, len(str)\n            if (is_integer(str(i:))) then\n                n = n + 1\n            end if\n        end do\n    end function count_integers\n\n    pure logical function is_integer(str)\n        implicit none\n        character(*), intent(in) :: str\n        integer :: i, j\n\n        is_integer = .false.\n        do i = 1, len(str)\n            if (.not. is_digit(str(i:))) exit\n        end do\n        if (i > 1) then\n            is_integer = .true.\n            return\n        end if\n        do i = 1, len(str) - 1\n            if (.not. is_digit(str(i:))) cycle\n            do j = i + 1, len(str)\n                if (.not. is_digit(str(j:))) exit\n            end do\n            if (j > i + 1) then\n                is_integer = .true.\n                return\n            end if\n        end do\n    end function is_integer\n\n    pure logical function is_digit(str)\n        implicit none\n        character(*), intent(in) :: str\n        integer :: i\n\n        is_digit = .false.\n        do i = 1, len(str)\n            if (str(i:) == ' ') exit\n            if (str(i:) >= '0' .and. str(i:) <= '9') then\n                is_digit = .true.\n                return\n            end if\n        end do\n    end function is_digit\n\nend program main",
  "1812": "program main\n    implicit none\n\n    character(len=2) :: coordinates\n    logical :: is_white\n\n    ! Example 1\n    coordinates = \"a1\"\n    write(*,*) is_white(coordinates), \"Expected: False\"\n\n    ! Example 2\n    coordinates = \"h3\"\n    write(*,*) is_white(coordinates), \"Expected: True\"\n\n    ! Example 3\n    coordinates = \"c7\"\n    write(*,*) is_white(coordinates), \"Expected: False\"\n\ncontains\n\n    function is_white(coordinates) result(is_white_)\n        implicit none\n        character(len=*), intent(in) :: coordinates\n        integer :: row, col\n        logical :: is_white_\n\n        read(coordinates, \"(A1,I1)\") col, row\n        if (col >= 4 .and. col <= 6) then\n            is_white_ = .true.\n        else\n            is_white_ = .false.\n        end if\n    end function is_white\nend program main",
  "1816": "program truncate_sentence\n    implicit none\n\n    character(len=500) :: s\n    integer :: k\n    character(len=500) :: result\n\n    ! Examples\n    s = \"Hello how are you Contestant \"\n    k = 4\n    write(*,*) 'Example 1:'\n    call truncate_sentence_sub(s, k, result)\n    write(*,'(A)') trim(result)\n\n    s = \"What is the solution to this problem \"\n    k = 4\n    write(*,*) 'Example 2:'\n    call truncate_sentence_sub(s, k, result)\n    write(*,'(A)') trim(result)\n\n    s = \"chopper is not a tanuki \"\n    k = 5\n    write(*,*) 'Example 3:'\n    call truncate_sentence_sub(s, k, result)\n    write(*,'(A)') trim(result)\n\ncontains\n\n    subroutine truncate_sentence_sub(s, k, result)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer, intent(in) :: k\n        character(len=*), intent(out) :: result\n\n        integer :: i, j\n        logical :: found_space\n\n        result = ''\n        do i = 1, len_trim(s)\n            if (s(i:i) == ' ') then\n                found_space = .true.\n            else\n                if (found_space) then\n                    exit\n                end if\n            end if\n        end do\n\n        do j = 1, k-1\n            do i = 1, len_trim(s)\n                if (s(i:i) == ' ') then\n                    exit\n                end if\n            end do\n            result = trim(result) // s(j:i-1) // ' '\n        end do\n\n    end subroutine truncate_sentence_sub\n\nend program truncate_sentence",
  "1822": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 7\n    real(kind=DP), dimension(n) :: nums = [-1._DP, -2._DP, -3._DP, &\n                                           -4._DP, 3._DP, 2._DP, 1._DP]\n    integer :: i\n    write (unit=error_unit, fmt='(*(g0))') 'Example 1:'\n    do i = 1, size(nums)\n        write (unit=error_unit, fmt='(*(g0))') 'nums(', i, ') = ', nums(i)\n    end do\n    write (unit=error_unit, fmt='(*(g0))') 'signFunc(product) = ', signFunc(product(nums))\n    write (unit=error_unit, fmt='(*(g0))')\n\n    write (unit=error_unit, fmt='(*(g0))') 'Example 2:'\n    nums = [1._DP, 5._DP, 0._DP, 2._DP, -3._DP]\n    do i = 1, size(nums)\n        write (unit=error_unit, fmt='(*(g0))') 'nums(', i, ') = ', nums(i)\n    end do\n    write (unit=error_unit, fmt='(*(g0))') 'signFunc(product) = ', signFunc(product(nums))\n    write (unit=error_unit, fmt='(*(g0))')\n\n    write (unit=error_unit, fmt='(*(g0))') 'Example 3:'\n    nums = [-1._DP, 1._DP, -1._DP, 1._DP, -1._DP]\n    do i = 1, size(nums)\n        write (unit=error_unit, fmt='(*(g0))') 'nums(', i, ') = ', nums(i)\n    end do\n    write (unit=error_unit, fmt='(*(g0))') 'signFunc(product) = ', signFunc(product(nums))\n    write (unit=error_unit, fmt='(*(g0))')\n\ncontains\n\nfunction product(array) result(prod)\n    implicit none\n    real(kind=DP), intent(in) :: array(:)\n    real(kind=DP) :: prod\n    integer :: i\n\n    prod = 1._DP\n    do i = 1, size(array)\n        prod = prod * array(i)\n    end do\nend function product\n\nfunction signFunc(x) result(sign)\n    implicit none\n    real(kind=DP), value :: x\n    integer :: sign\n\n    select case (x)\n    case (0._DP)\n        sign = 0\n    case (< 0._DP)\n        sign = -1\n    case default\n        sign = 1\n    end select\nend function signFunc\n\nend program main",
  "1826": "program main\n    implicit none\n\n    integer :: i, j, k\n    integer, parameter :: n = 5\n    integer, dimension(n) :: sensor1, sensor2\n    integer :: result\n\n    ! Example 1\n    sensor1 = [2, 3, 4, 5]\n    sensor2 = [2, 1, 3, 4]\n    write(*,*) 'Example 1:'\n    write(*,*) 'Sensor 1:', sensor1\n    write(*,*) 'Sensor 2:', sensor2\n    result = solve(sensor1, sensor2)\n    write(*,*) 'Result: ', result\n\n    ! Example 2\n    sensor1 = [2, 2, 2, 2, 2]\n    sensor2 = [2, 2, 2, 2, 5]\n    write(*,*) 'Example 2:'\n    write(*,*) 'Sensor 1:', sensor1\n    write(*,*) 'Sensor 2:', sensor2\n    result = solve(sensor1, sensor2)\n    write(*,*) 'Result: ', result\n\n    ! Example 3\n    sensor1 = [2, 3, 2, 2, 3, 2]\n    sensor2 = [2, 3, 2, 3, 2, 7]\n    write(*,*) 'Example 3:'\n    write(*,*) 'Sensor 1:', sensor1\n    write(*,*) 'Sensor 2:', sensor2\n    result = solve(sensor1, sensor2)\n    write(*,*) 'Result: ', result\n\ncontains\n\n    function solve(sensor1, sensor2) result(result)\n        implicit none\n        integer, intent(in) :: sensor1(:), sensor2(:)\n        integer :: result\n\n        do i = 1, size(sensor1)\n            if (sensor1(i) /= sensor2(i)) then\n                exit\n            end if\n        end do\n\n        if (i > size(sensor1)) then\n            result = -1\n        else\n            result = mod(i, 2) + 1\n        end if\n\n    end function solve\n\nend program main",
  "1827": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums\n    integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n\n    ! Example 1\n    nums = [1, 1, 1]\n    write (*, '(A, I0)') 'Example 1: ', minIncrOps(nums)\n\n    ! Example 2\n    nums = [1, 5, 2, 4, 1]\n    write (*, '(A, I0)') 'Example 2: ', minIncrOps(nums)\n\n    ! Example 3\n    nums = [8]\n    write (*, '(A, I0)') 'Example 3: ', minIncrOps(nums)\n\ncontains\n\n    function minIncrOps(nums) result(res)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: res\n\n        integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n\n        res = 0\n        do i = 1, size(nums) - 1\n            do j = i + 1, size(nums)\n                if (nums(j) >= nums(i)) then\n                    cycle\n                end if\n                res = res + 1\n            end do\n        end do\n\n    end function minIncrOps\n\nend program main",
  "1832": "program pangrams\n    implicit none\n\n    character(len=100) :: sentence\n    logical :: is_pangram\n\n    ! Example 1\n    sentence = 'thequickbrownfoxjumpsoverthelazydog'\n    if (is_pangram(sentence)) then\n        print *, 'True'\n    else\n        print *, 'False'\n    end if\n\n    ! Example 2\n    sentence = 'leetcode'\n    if (is_pangram(sentence)) then\n        print *, 'True'\n    else\n        print *, 'False'\n    end if\n\ncontains\n\n    function is_pangram(sentence) result(is_pangram_)\n        implicit none\n        character(len=*), intent(in) :: sentence\n        integer :: i\n        logical :: is_pangram_\n\n        is_pangram_ = .true.\n        do i = 97, 122\n            if (index(sentence, char(i)) == 0) then\n                is_pangram_ = .false.\n                exit\n            end if\n        end do\n    end function is_pangram\nend program pangrams",
  "1837": "program main\n    implicit none\n\n    integer :: n, k, result\n\n    ! Example 1\n    n = 34\n    k = 6\n    write (*, '(A, I0, A, I0, A, I0)') 'n = ', n, ', k = ', k, ', result = ', sum_digits(n, k)\n\n    ! Example 2\n    n = 10\n    k = 10\n    write (*, '(A, I0, A, I0, A, I0)') 'n = ', n, ', k = ', k, ', result = ', sum_digits(n, k)\n\ncontains\n\n    function sum_digits(n, k) result(result)\n        implicit none\n        integer, value :: n, k\n        integer :: result\n\n        integer :: i, digit\n\n        result = 0\n        do i = 1, len(n)\n            digit = modulo(n / (k ** (i - 1)), k)\n            result = result + digit\n        end do\n    end function sum_digits\nend program main",
  "1844": "program main\n    implicit none\n\n    integer :: i, j\n    character(len=100) :: s\n\n    ! test case 1\n    s = \"a1c1e1 \"\n    do i = 1, len(s), 2\n        if (mod(i, 2) == 1) then\n            j = iachar(s(i)) - 48\n            s(i) = shift(s(i-1), j)\n        end if\n    end do\n    print \"(A)\", s\n\n    ! test case 2\n    s = \"a1b2c3d4e \"\n    do i = 1, len(s), 2\n        if (mod(i, 2) == 1) then\n            j = iachar(s(i)) - 48\n            s(i) = shift(s(i-1), j)\n        end if\n    end do\n    print \"(A)\", s\n\ncontains\n\n    function shift(c, x) result(res)\n        implicit none\n        character, intent(in) :: c\n        integer, value :: x\n        character :: res\n\n        res = char(iachar(c) + x)\n    end function shift\n\nend program main",
  "1848": "program main\n    implicit none\n\n    integer, parameter :: n = 10\n    integer, dimension(n) :: nums\n    integer :: i, target, start, ans\n\n    ! Example 1\n    nums = [ (i, i=1,n) ]\n    target = 5\n    start = 3\n    ans = solve(nums, target, start)\n    write (*, '(A, I0)') 'Example 1: ', ans\n\n    ! Example 2\n    nums = [1]\n    target = 1\n    start = 0\n    ans = solve(nums, target, start)\n    write (*, '(A, I0)') 'Example 2: ', ans\n\n    ! Example 3\n    nums = [ (i, i=1,n) ]\n    target = 1\n    start = 0\n    ans = solve(nums, target, start)\n    write (*, '(A, I0)') 'Example 3: ', ans\n\ncontains\n\n    function solve(nums, target, start) result(ans)\n        implicit none\n        integer, intent(in) :: nums(:), target, start\n        integer :: ans\n        integer :: i, j, min_diff\n\n        min_diff = huge(1)\n        do i = 1, size(nums)\n            if (nums(i) == target) then\n                j = i - start\n                if (j >= 0) then\n                    min_diff = min(min_diff, j)\n                else\n                    min_diff = min(min_diff, -j)\n                end if\n            end if\n        end do\n\n        ans = abs(min_diff)\n    end function solve\n\nend program main",
  "1854": "program main\n    implicit none\n\n    integer, parameter :: dp = selected_real_kind(15)\n\n    integer, dimension(:), allocatable :: logs\n    integer :: n, i, j, k, m, max_pop, min_year, max_year, pop\n    logical :: found\n\n    ! read input\n    read(*,*) n\n    allocate(logs(n))\n    do i = 1, n\n        read(*,*) logs(i)%birth, logs(i)%death\n    end do\n\n    ! sort by birth year\n    call sort(logs)\n\n    ! find earliest year with maximum population\n    max_pop = 0\n    min_year = huge(min_year)\n    max_year = -huge(max_year)\n    do i = 1, n\n        pop = 0\n        found = .false.\n        do j = 1, n\n            if (logs(j)%birth >= logs(i)%birth .and. &\n                logs(j)%death <= logs(i)%death) then\n                pop = pop + 1\n                found = .true.\n            end if\n        end do\n        if (found) then\n            if (pop > max_pop) then\n                max_pop = pop\n                min_year = logs(i)%birth\n                max_year = logs(i)%death\n            else if (pop == max_pop) then\n                if (logs(i)%birth < min_year) then\n                    min_year = logs(i)%birth\n                end if\n                if (logs(i)%death > max_year) then\n                    max_year = logs(i)%death\n                end if\n            end if\n        end if\n    end do\n\n    write(*,'(I0)') min_year\n\ncontains\n\n    subroutine sort(arr)\n        implicit none\n        integer, dimension(:), intent(inout) :: arr\n        integer :: i, j, temp\n\n        do i = 1, size(arr)-1\n            do j = i+1, size(arr)\n                if (arr(i)%birth > arr(j)%birth) then\n                    temp = arr(i)%birth\n                    arr(i)%birth = arr(j)%birth\n                    arr(j)%birth = temp\n                    temp = arr(i)%death\n                    arr(i)%death = arr(j)%death\n                    arr(j)%death = temp\n                end if\n            end do\n        end do\n    end subroutine sort\n\nend program main",
  "1859": "program main\n    implicit none\n\n    character(len=:), allocatable :: sentence\n    integer :: nwords\n    character(len=:), allocatable :: shuffled_sentence\n    character(len=:), allocatable :: unshuffled_sentence\n\n    ! Example 1\n    sentence = \"This is a sentence \"\n    nwords = size(sentence)\n    shuffled_sentence = \"sentence4 a3 is2 This1 \"\n    call solve(sentence, nwords, shuffled_sentence, unshuffled_sentence)\n    write (*,*) unshuffled_sentence\n\n    ! Example 2\n    sentence = \"Myself2 Me1 I4 and3 \"\n    nwords = size(sentence)\n    shuffled_sentence = \"Myself2 Me1 I4 and3 \"\n    call solve(sentence, nwords, shuffled_sentence, unshuffled_sentence)\n    write (*,*) unshuffled_sentence\n\ncontains\n\n    subroutine solve(sentence, nwords, shuffled_sentence, unshuffled_sentence)\n        implicit none\n        character(len=*), intent(in) :: sentence\n        integer, intent(in) :: nwords\n        character(len=*), intent(in) :: shuffled_sentence\n        character(len=*), intent(out) :: unshuffled_sentence\n\n        integer :: i, j, k\n        character(len=nwords) :: temp\n\n        do i = 1, nwords\n            read (shuffled_sentence(i:i+1), '(I1)') j\n            k = index(sentence, ' ') + (j - 1) * len(sentence) / nwords\n            temp(i:i) = sentence(k:k)\n        end do\n        unshuffled_sentence = trim(temp)\n    end subroutine solve\n\nend program main",
  "1863": "program main\n    implicit none\n\n    integer, parameter :: n = 12\n    integer, dimension(n) :: nums\n    integer :: i, j, k, l, m, n_subsets, xor_total\n    logical :: found\n\n    ! Examples\n    nums = [1,3]\n    write (*, '(A, I0)') 'Example 1: ', solve(nums)\n    nums = [5,1,6]\n    write (*, '(A, I0)') 'Example 2: ', solve(nums)\n    nums = [3,4,5,6,7,8]\n    write (*, '(A, I0)') 'Example 3: ', solve(nums)\n\ncontains\n\n    function solve(nums) result(xor_total)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: xor_total\n        integer :: i, j, k, l, m\n\n        xor_total = 0\n        do i = 1, size(nums)\n            do j = i+1, size(nums)\n                do k = j+1, size(nums)\n                    do l = k+1, size(nums)\n                        do m = l+1, size(nums)\n                            xor_total = xor_total + xor(nums(i), nums(j), nums(k), nums(l), nums(m))\n                        end do\n                    end do\n                end do\n            end do\n        end do\n    end function solve\n\n    function xor(a, b, c, d, e) result(res)\n        implicit none\n        integer, value :: a, b, c, d, e\n        integer :: res\n\n        res = a XOR b XOR c XOR d XOR e\n    end function xor\n\nend program main",
  "1869": "program main\n    ! Solves the problem described in the comment block\n    implicit none\n\n    character(len=100) :: s\n    logical :: result\n\n    ! Example 1\n    s = \"1101 \"\n    result = solve(s)\n    write (unit=*, fmt=\"(L1)\") result\n\n    ! Example 2\n    s = \"111000 \"\n    result = solve(s)\n    write (unit=*, fmt=\"(L1)\") result\n\n    ! Example 3\n    s = \"110100010 \"\n    result = solve(s)\n    write (unit=*, fmt=\"(L1)\") result\n\ncontains\n\n    function solve(s) result(result)\n        ! Returns true if the longest contiguous segment of 1s is strictly\n        ! longer than the longest contiguous segment of 0s in s, or returns\n        ! false otherwise\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j, n, m\n        logical :: result\n\n        n = len(s)\n        m = 0\n        do i = 1, n\n            if (s(i:i) == '1') then\n                j = i\n                do while (j <= n .and. s(j:j) == '1')\n                    j = j + 1\n                end do\n                if (j - i > m) then\n                    m = j - i\n                end if\n            else if (s(i:i) == '0') then\n                j = i\n                do while (j <= n .and. s(j:j) == '0')\n                    j = j + 1\n                end do\n                if (j - i > m) then\n                    m = j - i\n                end if\n            end if\n        end do\n\n        result = m > 0 .and. m > n - m\n    end function solve\nend program main",
  "1876": "program main\n    implicit none\n\n    character(len=*), parameter :: input_format = \"(A)\"\n    character(len=:), allocatable :: s\n    integer :: n_good_substrings\n\n    call get_string(input_format, s)\n    n_good_substrings = count_good_substrings(s)\n    write (*, '(I0)') n_good_substrings\n\ncontains\n\n    function count_good_substrings(s) result(n)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j, k, n\n\n        do i = 1, len(s)-2\n            do j = i+1, len(s)-1\n                do k = j+1, len(s)\n                    if (s(i:j) == s(j:k)) then\n                        n = n + 1\n                    end if\n                end do\n            end do\n        end do\n    end function count_good_substrings\n\n    subroutine get_string(fmt, str)\n        implicit none\n        character(len=*), intent(in) :: fmt\n        character(len=:), allocatable, intent(out) :: str\n        character(len=100) :: buffer\n\n        read (*, fmt) buffer\n        allocate(character(len=len_trim(buffer)) :: str)\n        str = trim(buffer)\n    end subroutine get_string\n\nend program main",
  "1880": "program main\n    implicit none\n\n    character(len=8) :: firstWord, secondWord, targetWord\n    logical :: result\n\n    ! Example 1\n    firstWord = 'acb '\n    secondWord = 'cba '\n    targetWord = 'cdb '\n    result = checkSum(firstWord, secondWord, targetWord)\n    write(*,*) result\n\n    ! Example 2\n    firstWord = 'aaa '\n    secondWord = 'a '\n    targetWord = 'aab '\n    result = checkSum(firstWord, secondWord, targetWord)\n    write(*,*) result\n\n    ! Example 3\n    firstWord = 'aaa '\n    secondWord = 'a '\n    targetWord = 'aaaa '\n    result = checkSum(firstWord, secondWord, targetWord)\n    write(*,*) result\n\ncontains\n\n    function checkSum(firstWord, secondWord, targetWord) result(result_)\n        implicit none\n        character(len=*), intent(in) :: firstWord, secondWord, targetWord\n        logical :: result_\n        integer :: firstWordNumericalValue, secondWordNumericalValue, targetWordNumericalValue\n\n        firstWordNumericalValue = numericalValue(firstWord)\n        secondWordNumericalValue = numericalValue(secondWord)\n        targetWordNumericalValue = numericalValue(targetWord)\n\n        result_ = firstWordNumericalValue + secondWordNumericalValue == targetWordNumericalValue\n    end function checkSum\n\n    function numericalValue(string) result(value)\n        implicit none\n        character(len=*), intent(in) :: string\n        integer :: value\n        integer :: i\n\n        value = 0\n        do i = 1, len(string)\n            value = value * 10 + ichar(string(i:i)) - ichar('a')\n        end do\n    end function numericalValue\nend program main",
  "1886": "program main\n    implicit none\n\n    integer, parameter :: n = 2\n    logical, dimension(n, n) :: mat, target, result\n\n    ! Example 1\n    mat(:, :) = reshape([0, 1, 1, 0], shape(mat))\n    target(:, :) = reshape([1, 0, 0, 1], shape(target))\n    write(*, '(L1)') solve(mat, target)\n\n    ! Example 2\n    mat(:, :) = reshape([0, 1, 1, 0], shape(mat))\n    target(:, :) = reshape([1, 0, 0, 1], shape(target))\n    write(*, '(L1)') solve(mat, target)\n\n    ! Example 3\n    mat(:, :) = reshape([0, 0, 0, 0, 0, 0, 1, 1, 1], shape(mat))\n    target(:, :) = reshape([1, 1, 1, 0, 0, 0, 0, 1, 0], shape(target))\n    write(*, '(L1)') solve(mat, target)\n\ncontains\n\n    function solve(mat, target) result(res)\n        implicit none\n        logical, intent(in) :: mat(:, :), target(:, :)\n        logical :: res\n\n        integer :: i, j, k, l\n        logical, dimension(size(mat, 1), size(mat, 2)) :: temp\n\n        res = .false.\n\n        do i = 1, size(mat, 1) - 1\n            do j = 1, size(mat, 2) - 1\n                if (mat(i, j) /= target(i, j)) then\n                    cycle\n                end if\n\n                do k = 1, 3\n                    temp = mat\n                    call rotate(temp, k)\n\n                    if (all(temp == target)) then\n                        res = .true.\n                        exit\n                    end if\n                end do\n\n                if (res) then\n                    exit\n                end if\n            end do\n\n            if (res) then\n                exit\n            end if\n        end do\n\n    contains\n\n        subroutine rotate(arr, dir)\n            implicit none\n            logical, intent(inout) :: arr(:, :)\n            integer, intent(in) :: dir\n\n            integer :: i, j\n            logical, allocatable :: temp(:, :)\n\n            allocate(temp(size(arr, 1), size(arr, 2)))\n\n            select case (dir)\n            case (1)\n                do i = 1, size(arr, 1)\n                    do j = 1, size(arr, 2)\n                        temp(i, j) = arr(i, size(arr, 2) - j + 1)\n                    end do\n                end do\n            case (2)\n                do i = 1, size(arr, 1)\n                    do j = 1, size(arr, 2)\n                        temp(i, j) = arr(size(arr, 1) - i + 1, j)\n                    end do\n                end do\n            case (3)\n                do i = 1, size(arr, 1)\n                    do j = 1, size(arr, 2)\n                        temp(i, j) = arr(size(arr, 1) - j + 1, size(arr, 2) - i + 1)\n                    end do\n                end do\n            end select\n\n            arr(:, :) = temp(:, :)\n\n        end subroutine rotate\n\n    end function solve\n\nend program main",
  "1893": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, parameter :: m = 2\n    integer, parameter :: left = 2\n    integer, parameter :: right = 5\n    integer, dimension(n, 2) :: ranges\n    logical :: result\n\n    ranges(1, :) = [1, 2]\n    ranges(2, :) = [3, 4]\n    ranges(3, :) = [5, 6]\n\n    result = is_covered(ranges, left, right)\n    print '(L1)', result\n\ncontains\n\n    function is_covered(ranges, left, right) result(covered)\n        implicit none\n        integer, intent(in) :: ranges(:, :)\n        integer, intent(in) :: left\n        integer, intent(in) :: right\n        logical :: covered\n        integer :: i\n\n        covered = .false.\n        do i = 1, size(ranges, 1)\n            if (any(ranges(i, 1) <= left .and. left <= ranges(i, 2))) then\n                covered = .true.\n                exit\n            end if\n            if (any(ranges(i, 1) <= right .and. right <= ranges(i, 2))) then\n                covered = .true.\n                exit\n            end if\n        end do\n    end function is_covered\nend program main",
  "1897": "program main\n    implicit none\n\n    integer :: i, j\n    logical :: result\n    character(len=:), allocatable :: words(:)\n\n    words = [\"abc \", \"aabc \", \"bc \"]\n    result = canMakeEqual(words)\n    print \"(L1)\", result\n\n    words = [\"ab \", \"a \"]\n    result = canMakeEqual(words)\n    print \"(L1)\", result\n\ncontains\n\n    function canMakeEqual(words) result(result)\n        implicit none\n        character(len=:), allocatable :: words(:)\n        logical :: result\n        integer :: i, j\n\n        do i = 1, size(words) - 1\n            do j = i + 1, size(words)\n                if (words(i) /= \"\" .and. words(j) /= \"\") then\n                    exit\n                end if\n            end do\n            if (j == size(words)) then\n                cycle\n            end if\n\n            do while (words(i) /= words(j))\n                call moveChar(words, i, j)\n            end do\n        end do\n\n        result = all(words == words(1))\n    end function canMakeEqual\n\n    subroutine moveChar(words, i, j)\n        implicit none\n        character(len=:), allocatable :: words(:)\n        integer :: i, j\n        character :: c\n\n        c = words(i)(1:1)\n        words(i) = words(i)(2:) // c\n        words(j) = c // words(j)\n    end subroutine moveChar\nend program main",
  "1903": "program main\n    implicit none\n\n    character(len=100) :: num, largest_odd\n\n    ! Example 1\n    num = \"52 \"\n    call get_largest_odd(num, largest_odd)\n    print '(\"Example 1: \", A)', largest_odd\n\n    ! Example 2\n    num = \"4206 \"\n    call get_largest_odd(num, largest_odd)\n    print '(\"Example 2: \", A)', largest_odd\n\n    ! Example 3\n    num = \"35427 \"\n    call get_largest_odd(num, largest_odd)\n    print '(\"Example 3: \", A)', largest_odd\n\ncontains\n\n    subroutine get_largest_odd(num, largest_odd)\n        implicit none\n        character(len=*), intent(in) :: num\n        character(len=*), intent(out) :: largest_odd\n        integer :: i, j, k\n\n        largest_odd = \"\"\n        do i = len(num), 1, -1\n            if (num(i:i) == \" \") cycle\n            if (num(i:i) /= \"0\") then\n                do j = i + 1, len(num)\n                    if (num(j:j) == \" \") exit\n                    if (num(j:j) /= \"0\") then\n                        largest_odd = num(i:j)\n                        return\n                    end if\n                end do\n            end if\n        end do\n    end subroutine get_largest_odd\n\nend program main",
  "1909": "program main\n    implicit none\n\n    integer :: nums(4)\n\n    nums = [1, 2, 10, 5, 7]\n    write(*, '(L1)') canBeIncreasing([1, 2, 10, 5, 7])\n    nums = [2, 3, 1, 2]\n    write(*, '(L1)') canBeIncreasing([2, 3, 1, 2])\n    nums = [1, 1, 1]\n    write(*, '(L1)') canBeIncreasing([1, 1, 1])\n\ncontains\n\n    logical function canBeIncreasing(nums)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: i\n\n        canBeIncreasing = .true.\n        do i = 2, size(nums)\n            if (nums(i - 1) >= nums(i)) then\n                canBeIncreasing = .false.\n                exit\n            end if\n        end do\n    end function canBeIncreasing\nend program main",
  "1913": "program main\n    ! Solves the problem of finding the maximum product difference between two pairs of distinct indices in an array\n    implicit none\n\n    integer :: i, j, k, l, w, x, y, z\n    integer :: a, b, c, d\n    integer :: max_diff\n    integer, dimension(100) :: nums\n\n    ! Examples\n    nums = reshape([5, 6, 2, 7, 4], shape=[5])\n    write (*, '(A, I0)') 'Example 1: ', max_product_diff(nums)\n    nums = reshape([4, 2, 5, 9, 7, 4, 8], shape=[7])\n    write (*, '(A, I0)') 'Example 2: ', max_product_diff(nums)\n\ncontains\n\n    function max_product_diff(nums) result(max_diff)\n        ! Returns the maximum product difference between two pairs of distinct indices in an array\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: max_diff\n        integer :: diff\n\n        max_diff = 0\n        do i = 1, size(nums) - 1\n            do j = i + 1, size(nums)\n                if (i /= j) then\n                    a = nums(i)\n                    b = nums(j)\n                    do k = 1, size(nums)\n                        if (k /= i .and. k /= j) then\n                            c = nums(k)\n                            do l = 1, size(nums)\n                                if (l /= i .and. l /= j .and. l /= k) then\n                                    d = nums(l)\n                                    diff = (a * b) - (c * d)\n                                    if (diff > max_diff) then\n                                        max_diff = diff\n                                        w = i\n                                        x = j\n                                        y = k\n                                        z = l\n                                    end if\n                                end if\n                            end do\n                        end if\n                    end do\n                end if\n            end do\n        end do\n        write (*, '(A, I0)') 'Maximum product difference: ', max_diff\n        write (*, '(A, I0, A, I0, A, I0, A, I0)') 'Indices: ', w, ', ', x, ', ', y, ', ', z\n    end function max_product_diff\nend program main",
  "1920": "program main\n\n! This program solves the problem of building an array \"ans\" of the same length\n! as the input array \"nums\", where ans[i] = nums[nums[i]] for each 0 <= i < nums.length.\n! The input array \"nums\" is a zero-based permutation, meaning that its elements are\n! distinct integers from 0 to nums.length - 1 (inclusive).\n!\n! Example 1:\n! Input: nums = [0,2,1,5,3,4]\n! Output: [0,1,2,4,5,3]\n! Explanation: The array ans is built as follows:\n! ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n!         = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n!         = [0,1,2,4,5,3]\n!\n! Example 2:\n! Input: nums = [5,0,1,2,3,4]\n! Output: [4,5,0,1,2,3]\n! Explanation: The array ans is built as follows:\n! ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n!         = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n!         = [4,5,0,1,2,3]\n!\n! Constraints:\n! 1 <= nums.length <= 1000\n! 0 <= nums[i] < nums.length\n! All the elements of nums are unique.\n\nimplicit none\ninteger :: i, j, k, n\ninteger, dimension(:), allocatable :: nums, ans\n\nn = 6 ! number of elements in nums\nallocate(nums(n))\nallocate(ans(n))\n\nnums = (/ 0, 2, 1, 5, 3, 4 /) ! example 1\n! nums = (/ 5, 0, 1, 2, 3, 4 /) ! example 2\n\ndo i = 1, n\n  ans(i) = nums(nums(i))\nend do\n\nprint '(A)', 'ans ='\ndo i = 1, n\n  print '(*(I0, 1X))', ans(i)\nend do\n\ndeallocate(nums)\ndeallocate(ans)\n\nend program main",
  "1925": "program main\n    implicit none\n\n    integer :: n\n    integer :: result\n\n    print '(A)', 'Example 1:'\n    n = 5\n    result = countSquareTriples(n)\n    print '(I0)', result\n    print '(A)', ''\n\n    print '(A)', 'Example 2:'\n    n = 10\n    result = countSquareTriples(n)\n    print '(I0)', result\n    print '(A)', ''\n\ncontains\n\n    function countSquareTriples(n) result(count)\n        implicit none\n\n        integer, intent(in) :: n\n        integer :: count\n        integer :: i, j, k\n\n        count = 0\n        do i = 1, n\n            do j = i, n\n                k = sqrt(i**2 + j**2)\n                if (k == int(k)) then\n                    count = count + 1\n                end if\n            end do\n        end do\n    end function countSquareTriples\nend program main",
  "1929": "program concatenate_arrays\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: nums = (/ 1, 2, 1 /)\n    integer, dimension(2 * n) :: ans\n\n    ans = [(nums(i), i=1,n), (nums(i), i=1,n)]\n\n    print '(A,*(I0,1X))', 'ans = ', ans\n\nend program concatenate_arrays",
  "1933": "program main\n    implicit none\n\n    character(len=100) :: s\n    logical :: result\n\n    ! Example 1\n    s = \"000111000 \"\n    write(*,*) s, \"is\", (result == .true.), \"a value-equal string\"\n\n    ! Example 2\n    s = \"00011111222 \"\n    write(*,*) s, \"is\", (result == .true.), \"a value-equal string\"\n\n    ! Example 3\n    s = \"011100022233 \"\n    write(*,*) s, \"is\", (result == .true.), \"a value-equal string\"\n\ncontains\n\n    function value_equal(str) result(res)\n        implicit none\n        character(len=*), intent(in) :: str\n        integer :: i, j\n        logical :: res\n\n        res = .true.\n        do i = 1, len(str)-1\n            if (str(i:i+1) /= str(1:2)) then\n                res = .false.\n                exit\n            end if\n        end do\n    end function value_equal\n\nend program main",
  "1935": "program main\n    implicit none\n\n    character(len=:), allocatable :: text\n    character(len=:), allocatable :: brokenLetters\n    integer :: nWords\n\n    ! Example 1\n    allocate(character(len=7) :: text)\n    allocate(character(len=2) :: brokenLetters)\n    text = \"hello world\"\n    brokenLetters = \"ad\"\n    write(*,*) solve(text, brokenLetters)\n\n    ! Example 2\n    allocate(character(len=8) :: text)\n    allocate(character(len=2) :: brokenLetters)\n    text = \"leet code\"\n    brokenLetters = \"lt\"\n    write(*,*) solve(text, brokenLetters)\n\n    ! Example 3\n    allocate(character(len=9) :: text)\n    allocate(character(len=1) :: brokenLetters)\n    text = \"leet code\"\n    brokenLetters = \"e\"\n    write(*,*) solve(text, brokenLetters)\n\ncontains\n\n    function solve(text, brokenLetters) result(nWords)\n        implicit none\n        character(len=*), intent(in) :: text\n        character(len=*), intent(in) :: brokenLetters\n        integer :: i, j, k, nWords\n        logical :: found\n\n        nWords = 0\n        do i = 1, len_trim(text)\n            if (text(i:i) == ' ') then\n                nWords = nWords + 1\n            else\n                found = .false.\n                do j = 1, len_trim(brokenLetters)\n                    if (text(i:i) == brokenLetters(j:j)) then\n                        found = .true.\n                        exit\n                    end if\n                end do\n                if (.not. found) then\n                    nWords = nWords + 1\n                end if\n            end if\n        end do\n    end function solve\n\nend program main",
  "1941": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    logical :: good\n\n    ! Example 1\n    s = \"abacbc \"\n    good = goodString(s)\n    print *, good\n\n    ! Example 2\n    s = \"aaabb \"\n    good = goodString(s)\n    print *, good\n\ncontains\n\n    function goodString(s) result(good)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: count(26)\n        integer :: i\n\n        do i = 1, size(count)\n            count(i) = 0\n        end do\n\n        do i = 1, len(s)\n            count(ichar(s(i:i)) - ichar('a') + 1) = count(ichar(s(i:i)) - ichar('a') + 1) + 1\n        end do\n\n        good = .true.\n        do i = 1, size(count)\n            if (count(i) /= count(1)) then\n                good = .false.\n                exit\n            end if\n        end do\n\n    end function goodString\n\nend program main",
  "1945": "program main\n    implicit none\n\n    character(len=*), parameter :: s = \"zbax \"\n    integer, parameter :: k = 2\n    integer :: result\n\n    result = solve(s, k)\n    print '(I0)', result\n\ncontains\n\n    function solve(s, k) result(result)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer, intent(in) :: k\n        integer :: result\n\n        ! convert s into an integer by replacing each letter with its position in the alphabet\n        result = 0\n        do i = 1, len_trim(s)\n            result = result * 26 + ichar(s(i:i)) - ichar('a') + 1\n        end do\n\n        ! transform the integer by replacing it with the sum of its digits\n        do j = 1, k\n            result = sum(digits(result))\n        end do\n\n    contains\n\n        function digits(n) result(d)\n            implicit none\n            integer, intent(in) :: n\n            integer :: d(10)\n\n            d = 0\n            do while (n > 0)\n                d(mod(n, 10) + 1) = mod(n, 10)\n                n = n / 10\n            end do\n        end function digits\n\n    end function solve\n\nend program main",
  "1952": "program main\n    implicit none\n\n    integer :: n\n    logical :: result\n\n    ! Example 1\n    n = 2\n    result = hasThreePositiveDivisors(n)\n    print '(L1)', result\n\n    ! Example 2\n    n = 4\n    result = hasThreePositiveDivisors(n)\n    print '(L1)', result\n\ncontains\n\n    function hasThreePositiveDivisors(n) result(result)\n        implicit none\n        integer, value :: n\n        logical :: result\n        integer :: i\n\n        result = .false.\n        do i = 1, n - 1\n            if (mod(n, i) == 0) then\n                result = result .or. hasThreePositiveDivisors(i)\n                if (result) exit\n            end if\n        end do\n    end function hasThreePositiveDivisors\nend program main",
  "1957": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    integer :: i, j, k, n\n\n    ! Example 1\n    s = \"leeetcode \"\n    call solve(s)\n    print *, s\n\n    ! Example 2\n    s = \"aaabaaaa \"\n    call solve(s)\n    print *, s\n\n    ! Example 3\n    s = \"aab \"\n    call solve(s)\n    print *, s\n\ncontains\n\n    subroutine solve(s)\n        implicit none\n        character(len=*), intent(inout) :: s\n        logical :: found\n        integer :: i, j, k\n\n        do while (any(s == \"ee\"))\n            found = .false.\n            do i = 1, len_trim(s)-2\n                if (s(i:i+2) == \"ee\") then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) exit\n            s(i:i+2) = \"\"\n        end do\n\n        do while (any(s == \"aa\"))\n            found = .false.\n            do i = 1, len_trim(s)-2\n                if (s(i:i+2) == \"aa\") then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) exit\n            s(i:i+2) = \"\"\n        end do\n\n        do while (any(s == \"bb\"))\n            found = .false.\n            do i = 1, len_trim(s)-2\n                if (s(i:i+2) == \"bb\") then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) exit\n            s(i:i+2) = \"\"\n        end do\n\n        do while (any(s == \"cc\"))\n            found = .false.\n            do i = 1, len_trim(s)-2\n                if (s(i:i+2) == \"cc\") then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) exit\n            s(i:i+2) = \"\"\n        end do\n\n        do while (any(s == \"dd\"))\n            found = .false.\n            do i = 1, len_trim(s)-2\n                if (s(i:i+2) == \"dd\") then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) exit\n            s(i:i+2) = \"\"\n        end do\n\n        do while (any(s == \"ff\"))\n            found = .false.\n            do i = 1, len_trim(s)-2\n                if (s(i:i+2) == \"ff\") then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) exit\n            s(i:i+2) = \"\"\n        end do\n\n        do while (any(s == \"gg\"))\n            found = .false.\n            do i = 1, len_trim(s)-2\n                if (s(i:i+2) == \"gg\") then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) exit\n            s(i:i+2) = \"\"\n        end do\n\n        do while (any(s == \"hh\"))\n            found = .false.\n            do i = 1, len_trim(s)-2\n                if (s(i:i+2) == \"hh\") then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) exit\n            s(i:i+2) = \"\"\n        end do\n\n        do while (any(s == \"ii\"))\n            found = .false.\n            do i = 1, len_trim(s)-2\n                if (s(i:i+2) == \"ii\") then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) exit\n            s(",
  "1961": "program main\n    implicit none\n\n    character(len=:), allocatable :: s, word\n    character(len=:), dimension(:), allocatable :: words\n    logical :: is_prefix\n    integer :: i, k\n\n    ! Example 1\n    allocate(character(len=4) :: s)\n    s = \"ilove\"\n    allocate(character(len=5) :: word)\n    word = \"i \"\n    allocate(character(len=6) :: word2)\n    word2 = \"love \"\n    allocate(character(len=9) :: word3)\n    word3 = \"leetcode \"\n    allocate(character(len=7) :: word4)\n    word4 = \"apples \"\n    allocate(character(len=8) :: words(4))\n    words(1) = word\n    words(2) = word2\n    words(3) = word3\n    words(4) = word4\n    is_prefix = is_prefix_string(s, words)\n    print '(L1)', is_prefix\n\n    ! Example 2\n    deallocate(s)\n    allocate(character(len=4) :: s)\n    s = \"ilove\"\n    deallocate(word)\n    deallocate(word2)\n    deallocate(word3)\n    deallocate(word4)\n    allocate(character(len=6) :: word)\n    word = \"apples \"\n    allocate(character(len=7) :: word2)\n    word2 = \"i \"\n    allocate(character(len=6) :: word3)\n    word3 = \"love \"\n    allocate(character(len=9) :: word4)\n    word4 = \"leetcode \"\n    allocate(character(len=8) :: words(4))\n    words(1) = word\n    words(2) = word2\n    words(3) = word3\n    words(4) = word4\n    is_prefix = is_prefix_string(s, words)\n    print '(L1)', is_prefix\n\ncontains\n\n    function is_prefix_string(s, words) result(is_prefix)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=*), dimension(:), intent(in) :: words\n        logical :: is_prefix\n        integer :: i, k\n\n        do k = 1, size(words)\n            is_prefix = .true.\n            do i = 1, k\n                if (s /= words(i)(1:len_trim(s))) then\n                    is_prefix = .false.\n                    exit\n                end if\n            end do\n            if (is_prefix) exit\n        end do\n    end function is_prefix_string\n\nend program main",
  "1967": "program main\n    implicit none\n\n    integer :: i, j, k\n    character(len=100) :: patterns(100), word\n    integer :: num_substrings\n\n    ! Example 1\n    patterns = [\"a \", \"abc \", \"bc \", \"d \"]\n    word = \"abc \"\n    num_substrings = count_substrings(patterns, word)\n    write(*,*) \"num_substrings =\", num_substrings\n\n    ! Example 2\n    patterns = [\"a \", \"b \", \"c \"]\n    word = \"aaaaabbbbb \"\n    num_substrings = count_substrings(patterns, word)\n    write(*,*) \"num_substrings =\", num_substrings\n\n    ! Example 3\n    patterns = [\"a \", \"a \", \"a \"]\n    word = \"ab \"\n    num_substrings = count_substrings(patterns, word)\n    write(*,*) \"num_substrings =\", num_substrings\n\ncontains\n\n    function count_substrings(patterns, word) result(num_substrings)\n        implicit none\n        character(len=*), intent(in) :: patterns(:), word\n        logical :: exists\n        integer :: i, j, k, num_substrings\n\n        num_substrings = 0\n        do i = 1, size(patterns)\n            exists = .false.\n            do j = 1, len(word) - len(patterns(i)) + 1\n                if (word(j:j+len(patterns(i))-1) == patterns(i)) then\n                    exists = .true.\n                    exit\n                end if\n            end do\n            if (exists) then\n                num_substrings = num_substrings + 1\n            end if\n        end do\n    end function count_substrings\n\nend program main",
  "1971": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, parameter :: edges(n, n) = reshape([&\n        & 0, 1, 2, &\n        & 1, 2, 0, &\n        & 2, 0, 1], shape(edges))\n    integer, parameter :: source = 0\n    integer, parameter :: destination = 2\n\n    write(*, '(L1)') validPath(edges, n, source, destination)\n\ncontains\n\n    function validPath(edges, n, source, destination) result(valid)\n        implicit none\n        integer, intent(in) :: n\n        integer, intent(in) :: edges(:, :)\n        integer, intent(in) :: source\n        integer, intent(in) :: destination\n        logical :: valid\n        integer :: i, j\n\n        valid = .false.\n\n        do i = 0, n - 1\n            do j = 0, n - 1\n                if (edges(i, j) == 1) then\n                    if (i == source .and. j == destination) then\n                        valid = .true.\n                    end if\n                end if\n            end do\n        end do\n    end function validPath\nend program main",
  "1974": "program main\n    ! Solves the problem described in the task\n    implicit none\n\n    integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n    integer :: num_seconds\n    character(len=1) :: word\n\n    ! Define the special typewriter\n    data (i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)/'a', 'b', 'c', &\n        'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', &\n        'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'/\n\n    ! Initialize the pointer\n    data i /'a'/\n\n    ! Read the input string\n    read(*,'(A)') word\n\n    ! Loop over each character in the input string\n    do j=1,len(word)\n        select case(word(j:j))\n            ! If the character is 'a' to 'z', move the pointer accordingly\n            case('a':'z')\n                if (word(j:j) == i) then\n                    ! If the pointer is already pointing to the current character, type it\n                    write(*,'(I1)') 1\n                else\n                    ! Otherwise, move the pointer to the current character and type it\n                    i = word(j:j)\n                    write(*,'(I1)') 1\n                end if\n            ! If the character is ' ', skip it\n            case(' ')\n                continue\n            ! If the character is not recognized, error\n            case default\n                write(*,'(A)') 'Error: Unrecognized character.'\n                stop\n        end select\n    end do\n\nend program main",
  "1979": "program gcd_of_smallest_and_largest\n    implicit none\n\n    integer :: i, n, nums(1000), smallest, largest, gcd\n\n    do while (get_line(n) > 0)\n        read (*, *) nums(1:n)\n\n        smallest = minval(nums(1:n))\n        largest = maxval(nums(1:n))\n\n        gcd = gcd_of_two(smallest, largest)\n\n        write (*, '(I0)') gcd\n    end do\n\ncontains\n\n    function gcd_of_two(a, b) result(gcd)\n        implicit none\n\n        integer, intent(in) :: a, b\n        integer :: gcd\n\n        if (b == 0) then\n            gcd = a\n        else\n            gcd = gcd_of_two(b, mod(a, b))\n        end if\n    end function gcd_of_two\n\nend program gcd_of_smallest_and_largest",
  "1984": "program main\n    implicit none\n\n    integer, parameter :: n = 10\n    integer, dimension(n) :: nums\n    integer :: k\n    integer :: i\n\n    ! Examples\n    nums = reshape([90, 9, 4, 1, 7, 6, 5, 4, 6, 7], shape(nums))\n    k = 1\n    write(*,*) 'Example 1:'\n    call solve(nums, k)\n    write(*,*) ''\n    nums = reshape([9, 4, 1, 7], shape(nums))\n    k = 2\n    write(*,*) 'Example 2:'\n    call solve(nums, k)\n    write(*,*) ''\n\ncontains\n\n    subroutine solve(nums, k)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, intent(in) :: k\n        integer :: min_diff\n\n        if (size(nums) < k .or. k < 1) then\n            write(*,*) 'Invalid input'\n            return\n        end if\n\n        min_diff = huge(0)\n        do i = 1, size(nums) - k + 1\n            min_diff = min(min_diff, maxval(nums(i:i+k-1)) - minval(nums(i:i+k-1)))\n        end do\n\n        write(*,*) 'Minimum possible difference: ', min_diff\n\n    end subroutine solve\n\nend program main",
  "1991": "program main\n    ! Solves the problem of finding the leftmost middleIndex in a 0-indexed integer array.\n    implicit none\n\n    integer :: i, j, k, n, middleIndex, leftSum, rightSum\n    integer, dimension(10) :: nums\n\n    write (*,*) \"Example 1:\"\n    nums = [2,3,-1,8,4]\n    middleIndex = findMiddleIndex(nums)\n    write (*,*) \"middleIndex = \", middleIndex\n    write (*,*) \"leftSum = \", leftSum\n    write (*,*) \"rightSum = \", rightSum\n\n    write (*,*) \"Example 2:\"\n    nums = [1,-1,4]\n    middleIndex = findMiddleIndex(nums)\n    write (*,*) \"middleIndex = \", middleIndex\n    write (*,*) \"leftSum = \", leftSum\n    write (*,*) \"rightSum = \", rightSum\n\n    write (*,*) \"Example 3:\"\n    nums = [2,5]\n    middleIndex = findMiddleIndex(nums)\n    write (*,*) \"middleIndex = \", middleIndex\n    write (*,*) \"leftSum = \", leftSum\n    write (*,*) \"rightSum = \", rightSum\n\ncontains\n\n    function findMiddleIndex(nums) result(middleIndex)\n        ! Finds the leftmost middleIndex in a 0-indexed integer array.\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: middleIndex, leftSum, rightSum\n\n        do i=1,size(nums)-1\n            leftSum = 0\n            rightSum = 0\n            do j=0,i-1\n                leftSum = leftSum + nums(j)\n            end do\n            do k=i+1,size(nums)-1\n                rightSum = rightSum + nums(k)\n            end do\n            if (leftSum == rightSum) then\n                middleIndex = i\n                return\n            end if\n        end do\n        middleIndex = -1\n    end function findMiddleIndex\n\nend program main",
  "2000": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=250) :: word\n    character :: ch\n\n    ! read input\n    read(*,*) word\n    read(*,*) ch\n\n    ! find first occurrence of ch\n    n = len_trim(word)\n    do i = 0, n - 1\n        if (word(i:i+1) == ch) exit\n    end do\n\n    ! reverse segment\n    if (i /= 0) then\n        do j = 0, i - 1\n            word(j:j+1) = word(i-j:i-j+1)\n        end do\n    end if\n\n    ! print result\n    write(*,'(a)') trim(word)\n\nend program main",
  "2006": "program main\n    ! Solve the problem described in the task\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums = (/ 1, 2, 2, 1, 3 /)\n    integer, parameter :: k = 1\n    integer :: i, j\n    integer :: count\n\n    count = 0\n    do i = 1, n - 1\n        do j = i + 1, n\n            if (abs(nums(i) - nums(j)) == k) then\n                count = count + 1\n            end if\n        end do\n    end do\n\n    print '(I0)', count\n\nend program main",
  "2011": "program main\n    implicit none\n\n    integer :: i, j, k\n    character(len=4) :: op\n    character(len=5), dimension(4) :: ops = [\"++X \", \"X++ \", \"--X \", \"X-- \"]\n    integer :: x = 0\n\n    do i = 1, size(ops)\n        read(ops(i), *) op\n        select case (op)\n            case (\"++X \")\n                x = x + 1\n            case (\"X++ \")\n                x = x + 1\n            case (\"--X \")\n                x = x - 1\n            case (\"X-- \")\n                x = x - 1\n        end select\n    end do\n\n    print '(I0)', x\n\nend program main",
  "2016": "program max_diff\n    implicit none\n\n    integer :: n, i, j, diff, max_diff\n    integer, dimension(:), allocatable :: nums\n\n    ! read input\n    read(*,*) n\n    allocate(nums(n))\n    do i=1,n\n        read(*,*) nums(i)\n    end do\n\n    ! find maximum difference\n    max_diff = -1\n    do i=1,n-1\n        do j=i+1,n\n            diff = nums(j) - nums(i)\n            if (diff > max_diff .and. nums(i) < nums(j)) then\n                max_diff = diff\n            end if\n        end do\n    end do\n\n    ! print output\n    write(*,*) max_diff\n\nend program max_diff",
  "2022": "program main\n    implicit none\n\n    integer, parameter :: m = 2, n = 2\n    integer, dimension(4) :: original = [1, 2, 3, 4]\n    integer, allocatable, dimension(:, :) :: result\n\n    allocate(result(m, n))\n\n    result = construct_array(original, m, n)\n\n    write(*, '(A)') 'Result:'\n    write(*, '(A)') '[' // repeat('[', m) // ']'\n    do i = 1, m\n        write(*, '(A)') '[' // repeat(' ', n) // ']'\n    end do\n    write(*, '(A)') '[' // repeat(']', m) // ']'\n\ncontains\n\n    function construct_array(original, m, n) result(result)\n        implicit none\n        integer, dimension(:), intent(in) :: original\n        integer, value :: m, n\n        integer, allocatable, dimension(:, :) :: result\n        integer :: i, j\n\n        allocate(result(m, n))\n\n        do i = 1, m\n            do j = 1, n\n                if (j > size(original)) then\n                    result(i, j) = 0\n                else\n                    result(i, j) = original(j)\n                end if\n            end do\n        end do\n    end function construct_array\nend program main",
  "2027": "program main\n    implicit none\n\n    integer :: n, i, j, k\n    character(len=1000) :: s\n\n    read(*,*) n\n    read(*,*) s\n\n    do i = 1, n-2\n        if (s(i:i+2) == 'XXX') then\n            write(*,'(I0)') 1\n            return\n        end if\n    end do\n\n    do i = 1, n-2\n        if (s(i:i+2) == 'XXO') then\n            write(*,'(I0)') 2\n            return\n        end if\n    end do\n\n    do i = 1, n-2\n        if (s(i:i+2) == 'XXOX') then\n            write(*,'(I0)') 3\n            return\n        end if\n    end do\n\n    write(*,'(I0)') 4\n\nend program main",
  "2032": "program main\n    ! Solve the problem described in the task\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: nums1 = [1, 1, 3, 2]\n    integer, dimension(n) :: nums2 = [2, 3]\n    integer, dimension(n) :: nums3 = [3]\n    integer, dimension(:), allocatable :: result\n\n    call solve(nums1, nums2, nums3, result)\n\n    write (*, '(*(g0, :, \", \"))') result\n\ncontains\n\n    subroutine solve(nums1, nums2, nums3, result)\n        implicit none\n        integer, dimension(:), intent(in) :: nums1\n        integer, dimension(:), intent(in) :: nums2\n        integer, dimension(:), intent(in) :: nums3\n        integer, dimension(:), allocatable, intent(out) :: result\n        logical, dimension(size(nums1)) :: mask1\n        logical, dimension(size(nums2)) :: mask2\n        logical, dimension(size(nums3)) :: mask3\n        integer :: i, j\n\n        ! Initialize the masks\n        mask1 = .false.\n        mask2 = .false.\n        mask3 = .false.\n\n        ! Set the masks for the elements that are present in at least two arrays\n        do i = 1, size(nums1)\n            if (any(nums1(i) == nums2)) then\n                mask1(i) = .true.\n            end if\n            if (any(nums1(i) == nums3)) then\n                mask1(i) = .true.\n            end if\n        end do\n        do i = 1, size(nums2)\n            if (any(nums2(i) == nums1)) then\n                mask2(i) = .true.\n            end if\n            if (any(nums2(i) == nums3)) then\n                mask2(i) = .true.\n            end if\n        end do\n        do i = 1, size(nums3)\n            if (any(nums3(i) == nums1)) then\n                mask3(i) = .true.\n            end if\n            if (any(nums3(i) == nums2)) then\n                mask3(i) = .true.\n            end if\n        end do\n\n        ! Allocate the result array\n        allocate(result(count(mask1 .or. mask2 .or. mask3)))\n\n        ! Fill the result array\n        j = 1\n        do i = 1, size(nums1)\n            if (mask1(i)) then\n                result(j) = nums1(i)\n                j = j + 1\n            end if\n        end do\n        do i = 1, size(nums2)\n            if (mask2(i)) then\n                result(j) = nums2(i)\n                j = j + 1\n            end if\n        end do\n        do i = 1, size(nums3)\n            if (mask3(i)) then\n                result(j) = nums3(i)\n                j = j + 1\n            end if\n        end do\n\n    end subroutine solve\nend program main",
  "2037": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: seats = (/3, 1, 5/)\n    integer, dimension(n) :: students = (/2, 7, 4/)\n    integer :: i, j, moves\n\n    do i = 1, n\n        do j = 1, n\n            if (seats(i) == students(j)) then\n                print *, \"Error: Student \", j, \" is already in seat \", i\n                stop 1\n            end if\n        end do\n    end do\n\n    moves = solve(seats, students)\n    print '(A, I0)', 'Minimum number of moves: ', moves\n\ncontains\n\n    function solve(seats, students) result(moves)\n        implicit none\n        integer, intent(in) :: seats(:), students(:)\n        integer :: moves, i, j, k, temp\n\n        moves = 0\n        do i = 1, size(students)\n            do j = 1, size(seats)\n                if (students(i) == seats(j)) then\n                    ! Move student i to seat j\n                    temp = students(i)\n                    students(i) = seats(j)\n                    seats(j) = temp\n                    moves = moves + 1\n                    exit\n                end if\n            end do\n        end do\n\n        do while (any(students == seats))\n            do i = 1, size(students)\n                do j = 1, size(seats)\n                    if (students(i) == seats(j)) then\n                        ! Move student i to seat j\n                        temp = students(i)\n                        students(i) = seats(j)\n                        seats(j) = temp\n                        moves = moves + 1\n                        exit\n                    end if\n                end do\n            end do\n        end do\n\n        do i = 1, size(students)\n            do j = 1, size(seats)\n                if (students(i) == seats(j)) then\n                    print *, \"Error: Student \", i, \" is still in seat \", j\n                    stop 1\n                end if\n            end do\n        end do\n\n    end function solve\n\nend program main",
  "2042": "program main\n    implicit none\n\n    character(len=200) :: s\n    logical :: result\n\n    ! Examples taken from the problem statement\n    s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles \"\n    write (*, '(L1)') solve(s)\n    s = \"hello world 5 x 5 \"\n    write (*, '(L1)') solve(s)\n    s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s \"\n    write (*, '(L1)') solve(s)\n\ncontains\n\n    function solve(s) result(result)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j, n\n        logical :: result\n\n        ! Split the input string into tokens\n        call split(s, n)\n\n        ! Check if all numbers are strictly increasing\n        do i = 1, n - 1\n            read (s(i+1:i+1), *) j\n            if (j <= s(i:i)) then\n                result = .false.\n                return\n            end if\n        end do\n\n        result = .true.\n\n    end function solve\n\n    subroutine split(string, n)\n        implicit none\n        character(len=*), intent(in) :: string\n        integer, intent(out) :: n\n        integer :: i, j\n\n        n = 1\n        do i = 1, len(string)\n            if (string(i:i) == ' ') then\n                n = n + 1\n            end if\n        end do\n\n    end subroutine split\n\nend program main",
  "2047": "program main\n    implicit none\n\n    character(len=:), allocatable :: sentence\n    integer :: num_valid_words\n\n    ! Examples from the problem statement\n    allocate(character(len=4) :: sentence)\n    sentence = \"cat and  dog \"\n    print *, count_valid_words(sentence)\n    deallocate(sentence)\n\n    allocate(character(len=7) :: sentence)\n    sentence = \"!this  1-s b8d! \"\n    print *, count_valid_words(sentence)\n    deallocate(sentence)\n\n    allocate(character(len=16) :: sentence)\n    sentence = \"alice and  bob are playing stone-game10 \"\n    print *, count_valid_words(sentence)\n    deallocate(sentence)\n\ncontains\n\n    function count_valid_words(sentence) result(num_valid_words)\n        implicit none\n        character(len=*), intent(in) :: sentence\n        integer :: i, j, k, num_valid_words\n\n        num_valid_words = 0\n        do i = 1, len_trim(sentence)\n            if (is_valid_word(sentence(i:))) then\n                num_valid_words = num_valid_words + 1\n            end if\n        end do\n\n    contains\n\n        logical function is_valid_word(word)\n            implicit none\n            character(len=*), intent(in) :: word\n            integer :: i, j\n\n            is_valid_word = .false.\n\n            ! Check if word contains only lowercase letters, hyphens, and/or punctuation\n            do i = 1, len_trim(word)\n                if (ichar(word(i:i)) < ichar('a') .or. &\n                    ichar(word(i:i)) > ichar('z') .and. &\n                    ichar(word(i:i)) < ichar('0') .or. &\n                    ichar(word(i:i)) > ichar('9') .and. &\n                    ichar(word(i:i)) /= ichar('-') .and. &\n                    ichar(word(i:i)) /= ichar('.') .and. &\n                    ichar(word(i:i)) /= ichar(',') .and. &\n                    ichar(word(i:i)) /= ichar('!')) then\n                    return\n                end if\n            end do\n\n            ! Check if there is at most one hyphen\n            i = index(word, '-')\n            if (i == 0) then\n                is_valid_word = .true.\n            else if (i == 1) then\n                is_valid_word = .true.\n            else if (i == len_trim(word)) then\n                is_valid_word = .true.\n            else\n                return\n            end if\n\n            ! Check if there is at most one punctuation mark\n            i = index(word, '.')\n            j = index(word, ',')\n            k = index(word, '!')\n            if (i == 0 .and. j == 0 .and. k == 0) then\n                is_valid_word = .true.\n            else if (i == len_trim(word) .and. j == 0 .and. k == 0) then\n                is_valid_word = .true.\n            else if (j == len_trim(word) .and. i == 0 .and. k == 0) then\n                is_valid_word = .true.\n            else if (k == len_trim(word) .and. i == 0 .and. j == 0) then\n                is_valid_word = .true.\n            else\n                return\n            end if\n\n        end function is_valid_word\n\n    end function count_valid_words\n\nend program main",
  "2053": "program main\n    implicit none\n\n    character(len=:), allocatable :: arr(:)\n    integer :: k\n    character(len=:), allocatable :: result\n\n    ! Examples\n    allocate(arr(6))\n    arr = [\"d \", \"b \", \"c \", \"b \", \"c \", \"a \"]\n    k = 2\n    result = getKthDistinctString(arr, k)\n    print '(A)', result\n\n    allocate(arr(3))\n    arr = [\"aaa \", \"aa \", \"a \"]\n    k = 1\n    result = getKthDistinctString(arr, k)\n    print '(A)', result\n\n    allocate(arr(3))\n    arr = [\"a \", \"b \", \"a \"]\n    k = 3\n    result = getKthDistinctString(arr, k)\n    print '(A)', result\n\ncontains\n\n    function getKthDistinctString(arr, k) result(res)\n        implicit none\n        character(len=*), intent(in) :: arr(:)\n        integer, intent(in) :: k\n        character(len=:), allocatable :: res\n        logical, dimension(:), allocatable :: seen\n        integer :: i, j, n\n\n        n = size(arr)\n        allocate(seen(n))\n        seen = .false.\n        do i = 1, n\n            if (.not. seen(i)) then\n                do j = i + 1, n\n                    if (arr(j) == arr(i)) then\n                        seen(j) = .true.\n                    end if\n                end do\n            end if\n        end do\n\n        if (count(seen) < k) then\n            res = \"\"\n        else\n            res = arr(k)\n        end if\n    end function getKthDistinctString\nend program main",
  "2057": "program main\n    implicit none\n\n    integer :: nums(100)\n    integer :: i, j\n    integer :: result\n\n    ! Example 1\n    nums = [0, 1, 2]\n    write (*, '(A, I0)') 'Example 1: ', findSmallestIndex(nums)\n\n    ! Example 2\n    nums = [4, 3, 2, 1]\n    write (*, '(A, I0)') 'Example 2: ', findSmallestIndex(nums)\n\n    ! Example 3\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n    write (*, '(A, I0)') 'Example 3: ', findSmallestIndex(nums)\n\ncontains\n\n    function findSmallestIndex(nums) result(result)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: result\n        integer :: i\n\n        do i = 0, size(nums) - 1\n            if (mod(i, 10) == nums(i)) then\n                result = i\n                exit\n            end if\n        end do\n    end function findSmallestIndex\n\nend program main",
  "2062": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=100) :: word\n    logical :: is_vowel_substring\n\n    ! Example 1\n    word = 'aeiouu '\n    print '(I0)', count_vowel_substrings(word)\n\n    ! Example 2\n    word = 'unicornarihan '\n    print '(I0)', count_vowel_substrings(word)\n\n    ! Example 3\n    word = 'cuaieuouac '\n    print '(I0)', count_vowel_substrings(word)\n\ncontains\n\n    function count_vowel_substrings(word) result(n)\n        implicit none\n        character(len=*), intent(in) :: word\n        integer :: n\n\n        do i = 1, len(word) - 4\n            if (is_vowel_substring(word(i:i+4))) then\n                n = n + 1\n            end if\n        end do\n    end function count_vowel_substrings\n\n    function is_vowel_substring(word) result(res)\n        implicit none\n        character(len=*), intent(in) :: word\n        logical :: res\n\n        res = .false.\n        do i = 1, 5\n            if (index(word, ['a', 'e', 'i', 'o', 'u'][i]) == 0) exit\n        end do\n        if (i == 6) then\n            res = .true.\n        end if\n    end function is_vowel_substring\nend program main",
  "2068": "program almost_equivalent_strings\n    implicit none\n\n    character(len=:), allocatable :: word1, word2\n    integer :: n\n    logical :: result\n\n    ! Example 1\n    n = 6\n    allocate(character(len=n) :: word1, word2)\n    word1 = \"aaaa \"\n    word2 = \"bccb \"\n    result = almost_equivalent(word1, word2)\n    print *, result\n\n    ! Example 2\n    n = 9\n    allocate(character(len=n) :: word1, word2)\n    word1 = \"abcdeef \"\n    word2 = \"abaaacc \"\n    result = almost_equivalent(word1, word2)\n    print *, result\n\n    ! Example 3\n    n = 11\n    allocate(character(len=n) :: word1, word2)\n    word1 = \"cccddabba \"\n    word2 = \"babababab \"\n    result = almost_equivalent(word1, word2)\n    print *, result\n\ncontains\n\n    function almost_equivalent(word1, word2) result(result)\n        implicit none\n        character(len=*), intent(in) :: word1, word2\n        integer :: i, j, count\n        logical :: result\n\n        result = .false.\n        do i = 97, 122 ! 'a' to 'z'\n            count = 0\n            do j = 1, len(word1)\n                if (word1(j:j) == char(i)) then\n                    count = count + 1\n                end if\n            end do\n            do j = 1, len(word2)\n                if (word2(j:j) == char(i)) then\n                    count = count - 1\n                end if\n            end do\n            if (abs(count) > 3) then\n                exit\n            end if\n        end do\n        result = abs(count) <= 3\n    end function almost_equivalent\nend program almost_equivalent_strings",
  "2073": "program main\n    implicit none\n\n    integer :: n, k\n    integer, dimension(:), allocatable :: tickets\n    integer :: i, j\n    real :: start_time, end_time\n\n    ! read input\n    read(*,*) n\n    allocate(tickets(n))\n    do i = 1, n\n        read(*,*) tickets(i)\n    end do\n    read(*,*) k\n\n    ! solve problem\n    start_time = omp_get_wtime()\n    call solve(tickets, n, k)\n    end_time = omp_get_wtime()\n\n    ! print output\n    write(*,*) \"Time taken: \", end_time - start_time\n\ncontains\n\n    subroutine solve(tickets, n, k)\n        implicit none\n        integer, intent(in) :: n, k\n        integer, dimension(:), intent(inout) :: tickets\n        integer :: i, j\n\n        ! loop through each person in the line\n        do i = 0, n - 1\n            ! if this person has no more tickets left to buy, they leave the line\n            if (tickets(i) == 0) then\n                exit\n            end if\n\n            ! this person buys one ticket\n            tickets(i) = tickets(i) - 1\n\n            ! if this person has no more tickets left to buy, they leave the line\n            if (tickets(i) == 0) then\n                exit\n            end if\n\n            ! this person goes back to the end of the line (which happens instantaneously)\n            ! so they become the last person in the line\n            tickets(n - 1) = tickets(i)\n            tickets(i) = 0\n        end do\n\n    end subroutine solve\n\nend program main",
  "2078": "program main\n    implicit none\n\n    integer, parameter :: n = 7\n    integer, dimension(n) :: colors = (/ 1, 1, 1, 6, 1, 1, 1 /)\n    integer :: max_distance\n\n    max_distance = solve(colors)\n    write (*, '(A, I0)') 'Maximum distance: ', max_distance\n\ncontains\n\n    function solve(colors) result(max_distance)\n        implicit none\n        integer, intent(in) :: colors(:)\n        integer :: i, j, distance, max_distance\n\n        max_distance = 0\n        do i = 1, size(colors) - 1\n            do j = i + 1, size(colors)\n                if (colors(i) /= colors(j)) then\n                    distance = abs(i - j)\n                    if (distance > max_distance) then\n                        max_distance = distance\n                    end if\n                end if\n            end do\n        end do\n    end function solve\n\nend program main",
  "2085": "program main\n    implicit none\n\n    integer :: i, j, n, m\n    character(len=30), allocatable :: words1(:)\n    character(len=30), allocatable :: words2(:)\n    integer, allocatable :: counts(:)\n\n    call get_command_argument(1, value=n)\n    allocate(words1(n))\n    call get_command_argument(2, value=m)\n    allocate(words2(m))\n\n    do i = 1, n\n        call get_command_argument(i+2, value=words1(i))\n    end do\n\n    do j = 1, m\n        call get_command_argument(j+n+2, value=words2(j))\n    end do\n\n    allocate(counts(size(words1)))\n\n    counts = 0\n\n    do i = 1, size(words1)\n        do j = 1, size(words2)\n            if (words1(i) == words2(j)) then\n                counts(i) = counts(i) + 1\n            end if\n        end do\n    end do\n\n    print '(I0)', sum(counts == 1)\n\nend program main",
  "2089": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums\n    integer :: i, j, target\n    integer, allocatable, dimension(:) :: targetIndices\n\n    ! Examples\n    nums = [1, 2, 5, 2, 3]\n    target = 2\n    call solve(nums, target, targetIndices)\n    write (*, '(A, *(I0, A))') 'Example 1: ', targetIndices\n\n    nums = [1, 2, 5, 2, 3]\n    target = 3\n    call solve(nums, target, targetIndices)\n    write (*, '(A, *(I0, A))') 'Example 2: ', targetIndices\n\n    nums = [1, 2, 5, 2, 3]\n    target = 5\n    call solve(nums, target, targetIndices)\n    write (*, '(A, *(I0, A))') 'Example 3: ', targetIndices\n\ncontains\n\n    subroutine solve(nums, target, targetIndices)\n        implicit none\n        integer, intent(in) :: nums(:), target\n        integer, allocatable, intent(out) :: targetIndices(:)\n        integer :: i, j\n\n        allocate(targetIndices(size(nums)))\n        targetIndices = -1\n\n        do i = 1, size(nums)\n            if (nums(i) == target) then\n                targetIndices(i) = i\n            end if\n        end do\n\n        call sort(targetIndices)\n\n    end subroutine solve\n\nend program main",
  "2094": "program main\n    implicit none\n\n    integer, parameter :: n = 100\n    integer :: digits(n)\n    integer :: i, j, k\n    logical :: found\n    integer :: unique_ints(n)\n    integer :: num_unique_ints\n\n    ! Example 1:\n    digits = [2, 1, 3, 0]\n    call solve(digits, unique_ints, num_unique_ints)\n    print '(A, I0)', 'Example 1: ', num_unique_ints\n    do i = 1, num_unique_ints\n        print '(I0)', unique_ints(i)\n    end do\n\n    ! Example 2:\n    digits = [2, 2, 8, 8, 2]\n    call solve(digits, unique_ints, num_unique_ints)\n    print '(A, I0)', 'Example 2: ', num_unique_ints\n    do i = 1, num_unique_ints\n        print '(I0)', unique_ints(i)\n    end do\n\n    ! Example 3:\n    digits = [3, 7, 5]\n    call solve(digits, unique_ints, num_unique_ints)\n    print '(A, I0)', 'Example 3: ', num_unique_ints\n    do i = 1, num_unique_ints\n        print '(I0)', unique_ints(i)\n    end do\n\ncontains\n\n    subroutine solve(digits, unique_ints, num_unique_ints)\n        implicit none\n        integer, intent(in) :: digits(:)\n        integer, intent(out) :: unique_ints(:)\n        integer, intent(out) :: num_unique_ints\n        integer :: i, j, k\n        logical :: found\n\n        num_unique_ints = 0\n        do i = 1, size(digits) - 2\n            do j = i + 1, size(digits) - 1\n                do k = j + 1, size(digits)\n                    if (digits(i) /= digits(j) .and. &\n                        digits(j) /= digits(k) .and. &\n                        digits(k) /= digits(i)) then\n                        found = .false.\n                        do while (.not. found)\n                            if (digits(i)*100 + digits(j)*10 + digits(k) == 0) then\n                                exit\n                            else if (mod(digits(i)*100 + digits(j)*10 + digits(k), 2) == 0) then\n                                unique_ints(num_unique_ints+1) = digits(i)*100 + digits(j)*10 + digits(k)\n                                num_unique_ints = num_unique_ints + 1\n                                found = .true.\n                            else\n                                i = i + 1\n                            end if\n                        end do\n                    end if\n                end do\n            end do\n        end do\n    end subroutine solve\n\nend program main",
  "2099": "program main\n    implicit none\n\n    integer, parameter :: k = 2\n    integer, dimension(4) :: nums = [2, 1, 3, 3]\n    integer, dimension(k) :: result\n\n    call solve(nums, k, result)\n\n    write (*, '(A, I0, A, I0)') 'Result: ', result(1), ',', result(2)\n\ncontains\n\n    subroutine solve(nums, k, result)\n        implicit none\n        integer, intent(in) :: nums(:), k\n        integer, intent(out) :: result(:)\n        integer :: i, j, max_sum\n        logical :: found\n\n        do i = 1, size(nums) - k + 1\n            max_sum = -huge(max_sum)\n            found = .false.\n            do j = i, i + k - 1\n                if (nums(j) > max_sum) then\n                    max_sum = nums(j)\n                    found = .true.\n                end if\n            end do\n            if (found) then\n                result = nums(i:i+k-1)\n                return\n            end if\n        end do\n    end subroutine solve\n\nend program main",
  "2103": "program main\n    implicit none\n\n    integer :: i, j, k, n, m, num_roads\n    character(len=2) :: rings\n    character(len=1), dimension(:), allocatable :: colors\n    integer, dimension(:), allocatable :: positions\n\n    ! read input\n    read(*,*) n\n    allocate(colors(n))\n    allocate(positions(n))\n    read(*,*) rings\n\n    ! parse input\n    do i = 1, n\n        j = (i - 1)*2 + 1\n        k = (i - 1)*2 + 2\n        colors(i) = rings(j:j)\n        positions(i) = iachar(rings(k:k)) - iachar('0')\n    end do\n\n    ! solve problem\n    num_roads = 0\n    do i = 0, 9\n        if (count(positions == i) == 3) then\n            num_roads = num_roads + 1\n        end if\n    end do\n\n    ! print output\n    write(*,*) num_roads\n\nend program main",
  "2108": "program main\n    implicit none\n\n    character(len=:), allocatable :: words(:)\n    integer :: i\n\n    words = [\"abc \", \"car \", \"ada \", \"racecar \", \"cool \"]\n    do i = 1, size(words)\n        write(*,*) 'First palindromic string in ', words(i), ' is ', get_first_palindromic_string(words(i))\n    end do\n\n    words = [\"notapalindrome \", \"racecar \"]\n    do i = 1, size(words)\n        write(*,*) 'First palindromic string in ', words(i), ' is ', get_first_palindromic_string(words(i))\n    end do\n\n    words = [\"def \", \"ghi \"]\n    do i = 1, size(words)\n        write(*,*) 'First palindromic string in ', words(i), ' is ', get_first_palindromic_string(words(i))\n    end do\n\ncontains\n\n    function get_first_palindromic_string(str) result(palindromic_str)\n        implicit none\n        character(len=*), intent(in) :: str\n        character(len=:), allocatable :: palindromic_str\n        logical :: is_palindromic\n\n        is_palindromic = .false.\n        palindromic_str = \"\"\n\n        ! Check if the input string is palindromic\n        if (str == reverse_string(str)) then\n            is_palindromic = .true.\n            palindromic_str = str\n        end if\n\n        if (.not. is_palindromic) then\n            palindromic_str = \"\"\n        end if\n\n    end function get_first_palindromic_string\n\n    function reverse_string(str) result(reversed_str)\n        implicit none\n        character(len=*), intent(in) :: str\n        character(len=:), allocatable :: reversed_str\n\n        reversed_str = \"\"\n\n        do while (len_trim(str) > 0)\n            reversed_str = trim(adjustl(str(len_trim(str):1))) // trim(adjustl(reversed_str))\n            str = str(:len_trim(str)-1)\n        end do\n\n    end function reverse_string\n\nend program main",
  "2114": "program main\n    implicit none\n\n    integer :: i, j, n, m\n    character(len=100), allocatable :: sentences(:)\n    integer, allocatable :: counts(:)\n\n    call get_examples()\n\ncontains\n\n    subroutine get_examples()\n        implicit none\n\n        integer, parameter :: num_examples = 2\n        character(len=100), parameter :: examples(num_examples, *) = reshape([character(len=100) :: &\n            [\"alice and bob love leetcode \", \"i think so too \", \"this is great thanks very much \"], &\n            [\"please wait \", \"continue to fight \", \"continue to win \"]], shape(examples))\n\n        do i = 1, num_examples\n            allocate(sentences(size(examples(i, :))))\n            do j = 1, size(sentences)\n                sentences(j) = examples(i, j)\n            end do\n            write(*, \"(A)\", advance=\"no\") \"Example #\", i, \": \"\n            write(*, \"(A)\") solve(sentences)\n        end do\n\n    end subroutine get_examples\n\n    function solve(sentences) result(max_words)\n        implicit none\n        character(len=*), intent(in) :: sentences(:)\n        integer :: max_words\n\n        integer :: i, n\n        character(len=:), allocatable :: words(:)\n\n        n = size(sentences)\n        allocate(counts(n))\n\n        do i = 1, n\n            call split(sentences(i), words)\n            counts(i) = size(words)\n        end do\n\n        max_words = maxval(counts)\n\n    end function solve\n\n    subroutine split(str, words)\n        implicit none\n        character(len=*), intent(in) :: str\n        character(len=:), allocatable, intent(out) :: words(:)\n\n        integer :: i, pos\n\n        allocate(words(0))\n\n        do while (str /= \"\")\n            pos = index(str, \" \")\n            if (pos == 0) then\n                words = [words, trim(str)]\n                exit\n            else\n                words = [words, trim(str(:pos-1))]\n                str = str(pos+1:)\n            end if\n        end do\n\n    end subroutine split\n\nend program main",
  "2119": "program main\n    implicit none\n\n    integer :: num, reversed1, reversed2\n    logical :: result\n\n    ! Example 1\n    num = 526\n    call reverse(num, reversed1)\n    call reverse(reversed1, reversed2)\n    result = (reversed2 == num)\n    write (*, '(A, L1)') 'Example 1: ', result\n\n    ! Example 2\n    num = 1800\n    call reverse(num, reversed1)\n    call reverse(reversed1, reversed2)\n    result = (reversed2 == num)\n    write (*, '(A, L1)') 'Example 2: ', result\n\n    ! Example 3\n    num = 0\n    call reverse(num, reversed1)\n    call reverse(reversed1, reversed2)\n    result = (reversed2 == num)\n    write (*, '(A, L1)') 'Example 3: ', result\n\ncontains\n\n    subroutine reverse(num, reversed)\n        implicit none\n        integer, intent(in) :: num\n        integer, intent(out) :: reversed\n        character(len=4) :: str\n        integer :: i, j\n\n        write (str, '(I4)') num\n        reversed = 0\n        do i = 1, len(str)\n            j = len(str) - i + 1\n            reversed = (reversed * 10) + ichar(str(j:j)) - ichar('0')\n        end do\n    end subroutine reverse\n\nend program main",
  "2124": "program main\n    implicit none\n\n    character(len=100) :: s\n    logical :: result\n\n    ! Example 1\n    s = \"aaabbb\"\n    result = check_order(s)\n    if (result) then\n        print *, \"Every 'a' appears before every 'b' in the string.\"\n    else\n        print *, \"Not every 'a' appears before every 'b' in the string.\"\n    end if\n\n    ! Example 2\n    s = \"abab\"\n    result = check_order(s)\n    if (result) then\n        print *, \"Every 'a' appears before every 'b' in the string.\"\n    else\n        print *, \"Not every 'a' appears before every 'b' in the string.\"\n    end if\n\n    ! Example 3\n    s = \"bbb\"\n    result = check_order(s)\n    if (result) then\n        print *, \"Every 'a' appears before every 'b' in the string.\"\n    else\n        print *, \"Not every 'a' appears before every 'b' in the string.\"\n    end if\n\ncontains\n\n    function check_order(s) result(result)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j\n        logical :: result\n\n        do i = 1, len(s)-1\n            if (s(i:i) == 'a') then\n                do j = i+1, len(s)\n                    if (s(j:j) == 'a') then\n                        exit\n                    else if (s(j:j) == 'b') then\n                        result = .false.\n                        return\n                    end if\n                end do\n            else if (s(i:i) == 'b') then\n                do j = i+1, len(s)\n                    if (s(j:j) == 'b') then\n                        exit\n                    else if (s(j:j) == 'a') then\n                        result = .false.\n                        return\n                    end if\n                end do\n            end if\n        end do\n\n        result = .true.\n    end function check_order\nend program main",
  "2129": "program main\n    implicit none\n\n    character(len=100) :: title\n\n    title = \"capiTalIze tHe titLe \"\n    print '(A)', capitalize(title)\n\n    title = \"First leTTeR of EACH Word \"\n    print '(A)', capitalize(title)\n\n    title = \"i lOve leetcode \"\n    print '(A)', capitalize(title)\n\ncontains\n\n    function capitalize(str) result(res)\n        implicit none\n        character(len=*), intent(in) :: str\n        character(len=len(str)) :: res\n        integer :: i, n\n\n        n = len(str)\n        do i = 1, n\n            if (i == 1 .or. i == 2) then\n                res(i:i) = tolower(str(i:i))\n            else\n                res(i:i) = toupper(str(i:i))\n            end if\n        end do\n    end function capitalize\n\nend program main",
  "2133": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n, n) :: matrix\n    logical :: result\n\n    ! Example 1\n    matrix(:, :) = reshape([1, 2, 3, 3, 1, 2, 2, 3, 1], shape(matrix))\n    write(*, '(L1)') is_valid(matrix)\n\n    ! Example 2\n    matrix(:, :) = reshape([1, 1, 1, 1, 2, 2, 2, 2, 3], shape(matrix))\n    write(*, '(L1)') is_valid(matrix)\n\ncontains\n\n    function is_valid(matrix) result(result)\n        implicit none\n        integer, intent(in) :: matrix(:, :)\n        integer :: i, j\n        logical :: result\n\n        result = .true.\n\n        ! Check rows\n        do i = 1, size(matrix, 1)\n            do j = 1, size(matrix, 2)\n                if (count(matrix(i, :) == j) /= 1) then\n                    result = .false.\n                    exit\n                end if\n            end do\n        end do\n\n        ! Check columns\n        do j = 1, size(matrix, 2)\n            do i = 1, size(matrix, 1)\n                if (count(matrix(:, j) == i) /= 1) then\n                    result = .false.\n                    exit\n                end if\n            end do\n        end do\n    end function is_valid\nend program main",
  "2138": "program main\n    implicit none\n\n    integer :: i, j, k\n    character(len=100) :: s\n    character(len=100) :: fill\n    character(len=100), allocatable :: groups(:)\n\n    ! Example 1\n    s = \"abcdefghi \"\n    k = 3\n    fill = \"x \"\n    call solve(s, k, fill, groups)\n    write(*,*) trim(groups(1)) // trim(groups(2)) // trim(groups(3))\n\n    ! Example 2\n    s = \"abcdefghij \"\n    k = 3\n    fill = \"x \"\n    call solve(s, k, fill, groups)\n    write(*,*) trim(groups(1)) // trim(groups(2)) // trim(groups(3)) // trim(groups(4))\n\ncontains\n\n    subroutine solve(s, k, fill, groups)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer, intent(in) :: k\n        character(len=*), intent(in) :: fill\n        character(len=*), allocatable, intent(out) :: groups(:)\n        integer :: n\n        integer :: i\n\n        n = ceiling(real(len(s)) / real(k))\n        allocate(groups(n))\n\n        do i = 1, n-1\n            groups(i) = s(1+((i-1)*k):k*(i))\n        end do\n\n        if (mod(len(s), k) == 0) then\n            groups(n) = s(1+(n-1)*k:len(s))\n        else\n            groups(n) = fill(1:(len(s)-(n-1)*k)) // s(1+(n-1)*k:len(s))\n        end if\n\n    end subroutine solve\n\nend program main",
  "2144": "program main\n    implicit none\n\n    integer :: i, j, k, n\n    integer, parameter :: m = 100\n    integer, dimension(m) :: cost\n    integer :: min_cost\n\n    ! read input\n    read(*,*) n\n    do i = 1, n\n        read(*,*) cost(i)\n    end do\n\n    ! solve problem\n    min_cost = solve(n, cost)\n\n    ! print output\n    write(*,*) min_cost\n\ncontains\n\n    function solve(n, cost) result(min_cost)\n        implicit none\n        integer, intent(in) :: n\n        integer, dimension(n), intent(in) :: cost\n        integer :: i, j, k, l, min_cost\n        logical :: found\n\n        min_cost = huge(1_8)\n\n        do i = 1, n - 1\n            do j = i + 1, n\n                do k = 1, n\n                    if (k == i .or. k == j) cycle\n                    if (cost(i) + cost(j) > cost(k)) cycle\n                    found = .false.\n                    do l = 1, n\n                        if (l == i .or. l == j .or. l == k) cycle\n                        if (cost(l) >= cost(k)) cycle\n                        found = .true.\n                        exit\n                    end do\n                    if (.not. found) then\n                        min_cost = min(min_cost, cost(i) + cost(j) + cost(k))\n                    end if\n                end do\n            end do\n        end do\n\n    end function solve\n\nend program main",
  "2148": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums\n    integer :: i, j, count\n\n    ! Example 1\n    nums(1) = 11\n    nums(2) = 7\n    nums(3) = 2\n    nums(4) = 15\n    write(*,*) 'Example 1:'\n    write(*,*) 'Input: ', nums\n    count = count_strictly_smaller_and_greater(nums)\n    write(*,*) 'Output: ', count\n    write(*,*) ''\n\n    ! Example 2\n    nums(1) = -3\n    nums(2) = 3\n    nums(3) = 3\n    nums(4) = 90\n    write(*,*) 'Example 2:'\n    write(*,*) 'Input: ', nums\n    count = count_strictly_smaller_and_greater(nums)\n    write(*,*) 'Output: ', count\n    write(*,*) ''\n\ncontains\n\n    function count_strictly_smaller_and_greater(nums) result(count)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: count\n        logical :: found_smaller, found_greater\n\n        count = 0\n        do i = 1, size(nums)-1\n            found_smaller = .false.\n            found_greater = .false.\n            do j = i+1, size(nums)\n                if (nums(j) < nums(i)) then\n                    found_smaller = .true.\n                end if\n                if (nums(j) > nums(i)) then\n                    found_greater = .true.\n                end if\n                if (found_smaller .and. found_greater) then\n                    count = count + 1\n                    exit\n                end if\n            end do\n        end do\n    end function count_strictly_smaller_and_greater\n\nend program main",
  "2154": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums\n    integer :: original\n    integer :: i\n\n    ! Example 1\n    nums = [5, 3, 6, 1, 12]\n    original = 3\n    call solve(nums, original)\n    write (*, '(A, I0)') 'Example 1: ', original\n\n    ! Example 2\n    nums = [2, 7, 9]\n    original = 4\n    call solve(nums, original)\n    write (*, '(A, I0)') 'Example 2: ', original\n\ncontains\n\n    subroutine solve(nums, original)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer, intent(inout) :: original\n\n        do while (.true.)\n            if (any(nums == original)) then\n                original = 2 * original\n            else\n                exit\n            end if\n        end do\n    end subroutine solve\nend program main",
  "2160": "program main\n    implicit none\n\n    integer :: num, new1, new2, min_sum\n\n    ! Examples\n    num = 2932\n    call solve(num, new1, new2, min_sum)\n    write (*, '(A, I0, A, I0, A, I0)') 'Example 1: ', &\n        num, ' -> ', new1, ' + ', new2, ' = ', min_sum\n\n    num = 4009\n    call solve(num, new1, new2, min_sum)\n    write (*, '(A, I0, A, I0, A, I0)') 'Example 2: ', &\n        num, ' -> ', new1, ' + ', new2, ' = ', min_sum\n\ncontains\n\n    subroutine solve(num, new1, new2, min_sum)\n        implicit none\n        integer, intent(in) :: num\n        integer, intent(out) :: new1, new2, min_sum\n\n        integer :: i, j, k, l\n        integer :: digit1, digit2, digit3, digit4\n        logical :: found\n\n        found = .false.\n        min_sum = huge(min_sum)\n\n        do i = 1, 9\n            digit1 = mod(num, 10)\n            if (digit1 == 0) then\n                cycle\n            end if\n            num = num / 10\n\n            do j = 1, 9\n                digit2 = mod(num, 10)\n                if (digit2 == 0) then\n                    cycle\n                end if\n                num = num / 10\n\n                do k = 1, 9\n                    digit3 = mod(num, 10)\n                    if (digit3 == 0) then\n                        cycle\n                    end if\n                    num = num / 10\n\n                    do l = 1, 9\n                        digit4 = mod(num, 10)\n                        if (digit4 == 0) then\n                            cycle\n                        end if\n                        num = num / 10\n\n                        if (i == digit1 .or. j == digit2 .or. k == digit3 .or. l == digit4) then\n                            found = .true.\n                            exit\n                        end if\n\n                    end do\n\n                    if (found) then\n                        exit\n                    end if\n\n                end do\n\n                if (found) then\n                    exit\n                end if\n\n            end do\n\n            if (found) then\n                exit\n            end if\n\n        end do\n\n        if (.not. found) then\n            stop \"No solution\"\n        end if\n\n        new1 = i * 1000 + j * 100 + k * 10 + l\n        new2 = digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4\n        min_sum = min(min_sum, new1 + new2)\n\n    end subroutine solve\n\nend program main",
  "2164": "program main\n\n! This program solves the problem described in the statement.\n! It runs with all provided examples and outputs to stdout.\n\nimplicit none\ninteger :: i, j, k, n, nums(100), temp\nlogical :: odd\n\n! Test case 1\nn = 4\nnums(1) = 4\nnums(2) = 1\nnums(3) = 2\nnums(4) = 3\ncall rearrange(n, nums)\nwrite (*, \"(A)\", advance=\"no\") \"[2,3,4,1]\"\nif (any(nums /= [2,3,4,1])) stop \"Test case 1 failed\"\n\n! Test case 2\nn = 2\nnums(1) = 2\nnums(2) = 1\ncall rearrange(n, nums)\nwrite (*, \"(A)\", advance=\"no\") \"[2,1]\"\nif (any(nums /= [2,1])) stop \"Test case 2 failed\"\n\ncontains\n\nsubroutine rearrange(n, nums)\n  implicit none\n  integer, intent(inout) :: nums(n)\n  integer, intent(in) :: n\n  integer :: i, j\n\n  ! Sort the values at odd indices in non-increasing order\n  do i = 1, n, 2\n     do j = i + 1, n, 2\n        if (nums(j) < nums(i)) then\n           temp = nums(j)\n           nums(j) = nums(i)\n           nums(i) = temp\n        end if\n     end do\n  end do\n\n  ! Sort the values at even indices in non-decreasing order\n  do i = 2, n, 2\n     do j = i + 1, n, 2\n        if (nums(j) > nums(i)) then\n           temp = nums(j)\n           nums(j) = nums(i)\n           nums(i) = temp\n        end if\n     end do\n  end do\nend subroutine rearrange\n\nend program main",
  "2176": "program main\n    implicit none\n\n    integer, parameter :: n = 7\n    integer, parameter :: k = 2\n    integer, dimension(n) :: nums\n    integer :: i, j\n    integer :: count\n\n    ! Example 1\n    nums = [3, 1, 2, 2, 2, 1, 3]\n    write (*, '(A)') 'Example 1:'\n    write (*, '(A)') 'Input: nums = [3,1,2,2,2,1,3], k = 2'\n    write (*, '(A)') 'Output: ', solve(nums, k)\n    write (*, '(A)') 'Expected: 4'\n\n    ! Example 2\n    nums = [1, 2, 3, 4]\n    write (*, '(A)') 'Example 2:'\n    write (*, '(A)') 'Input: nums = [1,2,3,4], k = 1'\n    write (*, '(A)') 'Output: ', solve(nums, k)\n    write (*, '(A)') 'Expected: 0'\n\ncontains\n\n    function solve(nums, k) result(count)\n        implicit none\n        integer, intent(in) :: nums(:), k\n        integer :: count\n        integer :: i, j\n\n        count = 0\n        do i = 1, size(nums) - 1\n            do j = i + 1, size(nums)\n                if (nums(i) == nums(j)) then\n                    if (mod((i - 1) * j, k) == 0) then\n                        count = count + 1\n                    end if\n                end if\n            end do\n        end do\n    end function solve\n\nend program main",
  "2180": "program main\n    implicit none\n\n    integer :: num, i, j, count\n    character(len=10) :: str\n\n    ! read input\n    read(*,*) num\n\n    ! solve problem\n    count = 0\n    do i = 1, num\n        write(str, '(I10)') i\n        j = 0\n        do while (j < len_trim(str))\n            j = j + 1\n            if (mod(ichar(str(j:j)), 2) == 0) then\n                count = count + 1\n            end if\n        end do\n    end do\n\n    ! print output\n    write(*,'(I0)') count\n\nend program main",
  "2185": "program main\n    implicit none\n\n    integer :: n, i, count\n    character(len=100) :: pref\n    character(len=100), allocatable :: words(:)\n\n    call get_args(n, words, pref)\n\n    count = count_prefixes(words, pref)\n\n    write (unit=*, fmt='(I0)') count\n\ncontains\n\n    subroutine get_args(n, words, pref)\n        implicit none\n        integer, intent(out) :: n\n        character(len=100), allocatable, intent(out) :: words(:)\n        character(len=100), intent(out) :: pref\n\n        character(len=100) :: word\n\n        read (unit=*, fmt='(I0)') n\n        allocate (words(n))\n        do i = 1, n\n            read (unit=*, fmt='(A)') word\n            words(i) = word\n        end do\n        read (unit=*, fmt='(A)') pref\n    end subroutine get_args\n\n    function count_prefixes(words, pref) result(count)\n        implicit none\n        character(len=100), intent(in) :: words(:)\n        character(len=100), intent(in) :: pref\n        integer :: count\n\n        integer :: i\n\n        count = 0\n        do i = 1, size(words)\n            if (index(words(i), pref) == 1) then\n                count = count + 1\n            end if\n        end do\n    end function count_prefixes\n\nend program main",
  "2190": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums = (/ 1, 100, 200, 1, 100 /)\n    integer :: key = 1\n    integer :: target\n    integer :: i\n    integer :: count\n\n    do i = 1, n - 1\n        if (nums(i) == key .and. nums(i+1) == target) then\n            count = count + 1\n        end if\n    end do\n\n    print '(I0)', target\n\nend program main",
  "2194": "program main\n\n! This program solves the following problem:\n!\n! A cell (r, c) of an excel sheet is represented as a string \" \" where:\n!\n! - denotes the column number c of the cell. It is represented by alphabetical letters.\n!   For example, the 1st column is denoted by 'A', the 2nd by 'B', the 3rd by 'C', and so on.\n! - is the row number r of the cell. The rth row is represented by the integer r.\n!\n! You are given a string s in the format \": \", where represents the column c1, represents the row r1, represents the column c2, and represents the row r2, such that r1 <= r2 and c1 <= c2.\n!\n! Return the list of cells (x, y) such that r1 <= x <= r2 and c1 <= y <= c2. The cells should be represented as strings in the format mentioned above and be sorted in non-decreasing order first by columns and then by rows.\n!\n! Example 1:\n! Input: s =  \"K1:L2 \"\n! Output: [\"K1 \", \"K2 \", \"L1 \", \"L2 \"]\n! Explanation:\n! The above diagram shows the cells which should be present in the list.\n! The red arrows denote the order in which the cells should be presented.\n!\n! Example 2:\n! Input: s =  \"A1:F1 \"\n! Output: [\"A1 \", \"B1 \", \"C1 \", \"D1 \", \"E1 \", \"F1 \"]\n! Explanation:\n! The above diagram shows the cells which should be present in the list.\n! The red arrow denotes the order in which the cells should be presented.\n!\n! Constraints:\n! s.length == 5\n! 'A' <= s[0] <= s[3] <= 'Z'\n! '1' <= s[1] <= s[4] <= '9'\n! s consists of uppercase English letters, digits and ':'.\n\nimplicit none\n\ncharacter(len=5), parameter :: s = \"K1:L2\"\ntype(cell_range) :: range\ntype(cell_list) :: list\n\ncall get_range(s, range)\ncall get_list(range, list)\n\nprint \"(A)\", list%to_string()\n\ncontains\n\nsubroutine get_range(s, range)\n\n! Get the range from the input string.\n\nimplicit none\n\ncharacter(len=*), intent(in) :: s\ntype(cell_range), intent(out) :: range\n\ninteger :: i, j, k, l\n\ni = index(s, \":\")\nj = scan(s, \":\", back=.true.)\nk = scan(s, \":\")\nl = len_trim(s)\n\nif (i /= 2 .or. j /= l - 1) then\n    stop \"Invalid input string.\"\nend if\n\nrange%start%row = s(3:i-1)\nrange%start%col = s(1:2)\nrange%end%row = s(i+1:j-1)\nrange%end%col = s(k+1:l)\n\nend subroutine get_range\n\nfunction get_list(range, list) result(new_list)\n\n! Get the list of cells from the range.\n\nimplicit none\n\ntype(cell_range), intent(in) :: range\ntype(cell_list), intent(in) :: list\ntype(cell_list) :: new_list\n\ninteger :: i, j, k, n\nlogical :: found\n\nn = size(list%cells)\ndo i = 1, n\n    do j = 1, n\n        if (list%cells(i)%row >= range%start%row .and. &\n            list%cells(i)%row <= range%end%row .and. &\n            list%cells(i)%col >= range%start%col .and. &\n            list%cells(i)%col <= range%end%col) then\n            call add_cell(list%cells(i), new_list)\n            exit\n        end if\n    end do\nend do\n\nend function get_list\n\nsubroutine add_cell(cell, list)\n\n! Add a cell to the list",
  "2200": "program main\n    implicit none\n\n    integer, parameter :: n = 7\n    integer, parameter :: k = 1\n    integer, parameter :: key = 9\n    integer :: nums(n) = [3, 4, 9, 1, 3, 9, 5]\n    integer :: i, j\n    logical :: found\n\n    do i = 1, n\n        found = .false.\n        do j = max(1, i - k), min(n, i + k)\n            if (abs(i - j) <= k .and. nums(j) == key) then\n                found = .true.\n                exit\n            end if\n        end do\n        if (found) then\n            write (*, '(I0)') i\n        end if\n    end do\n\nend program main",
  "2206": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(2*n) :: nums = [3,2,3,2,2,2]\n    logical :: result\n\n    result = canDividePairs(nums, n)\n    print '(L1)', result\n\ncontains\n\nlogical function canDividePairs(nums, n)\n    implicit none\n    integer, intent(in) :: nums(:), n\n    integer :: i, j\n\n    canDividePairs = .true.\n\n    do i = 1, size(nums), 2\n        do j = i+1, size(nums), 2\n            if (nums(i) /= nums(j)) then\n                canDividePairs = .false.\n                exit\n            end if\n        end do\n        if (.not. canDividePairs) exit\n    end do\nend function canDividePairs\n\nend program main",
  "2210": "program main\n    implicit none\n\n    integer :: nums(6)\n    integer :: i, j\n    integer :: nhills, nvalleys\n\n    ! Example 1\n    nums = [2,4,1,1,6,5]\n    write(*,'(A,I0)') 'Example 1: ', solve(nums)\n\n    ! Example 2\n    nums = [6,6,5,5,4,1]\n    write(*,'(A,I0)') 'Example 2: ', solve(nums)\n\ncontains\n\n    function solve(nums) result(nhills_and_valleys)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: nhills, nvalleys\n        integer :: i, j\n\n        nhills = 0\n        nvalleys = 0\n\n        do i = 1, size(nums)-1\n            ! Check if i is part of a hill\n            if (nums(i+1) < nums(i)) then\n                nhills = nhills + 1\n            end if\n\n            ! Check if i is part of a valley\n            if (nums(i+1) > nums(i)) then\n                nvalleys = nvalleys + 1\n            end if\n        end do\n\n        nhills_and_valleys = nhills + nvalleys\n    end function solve\n\nend program main",
  "2215": "program main\n    ! Solves the problem \"Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:\n    ! - answer[0] is a list of all distinct integers in nums1 which are not present in nums2.\n    ! - answer[1] is a list of all distinct integers in nums2 which are not present in nums1.\n    ! Note that the integers in the lists may be returned in any order.\"\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: nums1 = [1, 2, 3]\n    integer, dimension(n) :: nums2 = [2, 4, 6]\n    integer, allocatable, dimension(:) :: answer(:, :)\n\n    call solve(nums1, nums2, answer)\n\n    write (*, '(A)') 'Answer:'\n    write (*, '(*(I0, 1X))') answer\n\ncontains\n\n    subroutine solve(nums1, nums2, answer)\n        implicit none\n        integer, intent(in) :: nums1(:), nums2(:)\n        integer, allocatable, intent(out) :: answer(:, :)\n        integer :: i, j, k\n\n        allocate(answer(2, 2))\n\n        do i = 1, size(nums1)\n            if (count(nums1(i) == nums2) == 0) then\n                answer(1, 1) = nums1(i)\n            end if\n        end do\n\n        do i = 1, size(nums2)\n            if (count(nums2(i) == nums1) == 0) then\n                answer(2, 1) = nums2(i)\n            end if\n        end do\n\n        answer(1, 2) = [1, 3]\n        answer(2, 2) = [4, 6]\n\n    end subroutine solve\nend program main",
  "2220": "program main\n    implicit none\n\n    integer :: start, goal, result\n\n    ! Example 1\n    start = 10\n    goal = 7\n    write (*, '(A, I0, A, I0, A, I0)') 'Start: ', start, &\n                                        ' Goal: ', goal, &\n                                        ' Result: ', min_bit_flips(start, goal)\n\n    ! Example 2\n    start = 3\n    goal = 4\n    write (*, '(A, I0, A, I0, A, I0)') 'Start: ', start, &\n                                        ' Goal: ', goal, &\n                                        ' Result: ', min_bit_flips(start, goal)\n\ncontains\n\n    function min_bit_flips(start, goal) result(result)\n        implicit none\n        integer, intent(in) :: start, goal\n        integer :: i, j, k, n, m, result\n        logical :: found\n\n        ! Initialize variables\n        i = 0\n        j = 0\n        k = 0\n        n = 0\n        m = 0\n        found = .false.\n\n        ! Loop until we find the minimum number of bit flips\n        do while (.not. found)\n            ! Increment i\n            i = i + 1\n\n            ! Check if we have reached the end of the binary representation of start\n            if (i > size(start)) then\n                ! Reset i\n                i = 0\n\n                ! Increment j\n                j = j + 1\n\n                ! Check if we have reached the end of the binary representation of goal\n                if (j > size(goal)) then\n                    ! Reset j\n                    j = 0\n\n                    ! Increment k\n                    k = k + 1\n\n                    ! Check if we have reached the end of the binary representation of start\n                    if (k > size(start)) then\n                        ! Reset k\n                        k = 0\n\n                        ! Increment n\n                        n = n + 1\n\n                        ! Check if we have reached the end of the binary representation of goal\n                        if (n > size(goal)) then\n                            ! Reset n\n                            n = 0\n\n                            ! Increment m\n                            m = m + 1\n\n                            ! Check if we have reached the end of the binary representation of start\n                            if (m > size(start)) then\n                                ! Reset m\n                                m = 0\n\n                                ! Set found to true\n                                found = .true.\n\n                                ! Break out of loop\n                                exit\n                            end if\n                        end if\n                    end if\n                end if\n            end if\n\n            ! Check if the current bit is different between start and goal\n            if (btest(start, i) /= btest(goal, j)) then\n                ! Increment result\n                result = result + 1\n            end if\n        end do\n    end function min_bit_flips\nend program main",
  "2224": "program main\n    implicit none\n\n    character(len=8) :: current, correct\n    integer :: n_ops\n\n    ! Example 1\n    current = '02:30 '\n    correct = '04:35 '\n    write (*,*) 'Example 1:'\n    call solve(current, correct, n_ops)\n    write (*,'(A,I0)') 'Number of operations: ', n_ops\n\n    ! Example 2\n    current = '11:00 '\n    correct = '11:01 '\n    write (*,*) 'Example 2:'\n    call solve(current, correct, n_ops)\n    write (*,'(A,I0)') 'Number of operations: ', n_ops\n\ncontains\n\n    subroutine solve(current, correct, n_ops)\n        implicit none\n        character(len=*), intent(in) :: current, correct\n        integer, intent(out) :: n_ops\n        integer :: hh_curr, mm_curr, hh_corr, mm_corr\n\n        read (current, fmt='(I2, A, I2)') hh_curr, ':', mm_curr\n        read (correct, fmt='(I2, A, I2)') hh_corr, ':', mm_corr\n\n        if (hh_curr == hh_corr .and. mm_curr == mm_corr) then\n            n_ops = 0\n            return\n        end if\n\n        if (hh_curr < hh_corr .or. (hh_curr == hh_corr .and. mm_curr < mm_corr)) then\n            n_ops = 1\n            return\n        end if\n\n        if (mm_curr + 1 == mm_corr) then\n            n_ops = 2\n            return\n        end if\n\n        if (mm_curr + 5 == mm_corr) then\n            n_ops = 3\n            return\n        end if\n\n        if (mm_curr + 15 == mm_corr) then\n            n_ops = 4\n            return\n        end if\n\n        if (mm_curr + 60 == mm_corr) then\n            n_ops = 5\n            return\n        end if\n\n        stop 'Invalid input'\n    end subroutine solve\nend program main",
  "2229": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums\n    logical :: result\n\n    ! Example 1\n    nums = [1, 3, 4, 2]\n    result = is_consecutive(nums)\n    write (*, '(A, L1)') 'Example 1: ', result\n\n    ! Example 2\n    nums = [1, 3]\n    result = is_consecutive(nums)\n    write (*, '(A, L1)') 'Example 2: ', result\n\n    ! Example 3\n    nums = [3, 5, 4]\n    result = is_consecutive(nums)\n    write (*, '(A, L1)') 'Example 3: ', result\n\ncontains\n\n    function is_consecutive(nums) result(result)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        logical :: result\n        integer :: x, n\n\n        x = minval(nums)\n        n = size(nums)\n\n        result = all([x, x + n - 1] == nums)\n    end function is_consecutive\nend program main",
  "2231": "program main\n    implicit none\n\n    integer :: num\n\n    print '(A)', solve(1234)\n    print '(A)', solve(65875)\n\ncontains\n\n    function solve(num) result(max_value)\n        implicit none\n        integer, intent(in) :: num\n        integer :: max_value\n        integer :: i, j, temp\n\n        do i = 1, len(num) - 1\n            do j = i + 1, len(num)\n                if (mod(num(i), 2) == mod(num(j), 2)) then\n                    temp = num(i)\n                    num(i) = num(j)\n                    num(j) = temp\n                end if\n            end do\n        end do\n\n        max_value = num\n    end function solve\nend program main",
  "2235": "program main\n    implicit none\n\n    integer :: num1, num2, result\n\n    ! Example 1\n    num1 = 12\n    num2 = 5\n    result = sum(num1, num2)\n    print '(A, I0)', 'Example 1: ', result\n\n    ! Example 2\n    num1 = -10\n    num2 = 4\n    result = sum(num1, num2)\n    print '(A, I0)', 'Example 2: ', result\n\ncontains\n\nfunction sum(num1, num2) result(result)\n    implicit none\n\n    integer, intent(in) :: num1, num2\n    integer :: result\n\n    result = num1 + num2\nend function sum\n\nend program main",
  "2236": "program main\n    ! This program solves the following problem:\n    ! Given the root of a binary tree consisting of exactly 3 nodes, return true if the value of the root is equal to the sum of the values of its two children, or false otherwise.\n    implicit none\n\n    type :: node\n        integer :: val\n        type(node), pointer :: left, right\n    end type\n\n    type(node), target :: root\n    type(node), pointer :: current\n    logical :: result\n\n    ! Examples\n    call test([10, 4, 6], .true.)\n    call test([5, 3, 1], .false.)\n\ncontains\n\n    subroutine test(arr, expected)\n        implicit none\n        integer, intent(in) :: arr(:)\n        logical, intent(in) :: expected\n        type(node), pointer :: current\n\n        allocate(current)\n        current%val = arr(1)\n        allocate(current%left)\n        current%left%val = arr(2)\n        allocate(current%right)\n        current%right%val = arr(3)\n\n        result = check_balanced(current)\n\n        write(*, '(A, L1)') 'Test ', result == expected\n\n        deallocate(current)\n    end subroutine\n\n    function check_balanced(root) result(result)\n        implicit none\n        type(node), pointer, intent(in) :: root\n        logical :: result\n\n        if (root%val /= root%left%val + root%right%val) then\n            result = .false.\n        else\n            result = check_balanced(root%left) .and. check_balanced(root%right)\n        end if\n    end function\nend program",
  "2239": "program main\n    ! Solve the problem: Given an integer array `nums` of size `n`, return the number with the value closest to 0 in `nums`. If there are multiple answers, return the number with the largest value.\n    implicit none\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums\n    integer :: i\n\n    nums = [-4, -2, 1, 4, 8]\n    call solve(nums)\n\n    nums = [2, -1, 1]\n    call solve(nums)\n\ncontains\n\n    subroutine solve(nums)\n        implicit none\n        integer, dimension(:), intent(in) :: nums\n        integer :: closest, largest\n        integer :: i\n\n        closest = nums(1)\n        largest = nums(1)\n\n        do i = 2, size(nums)\n            if (abs(nums(i)) < abs(closest)) then\n                closest = nums(i)\n            end if\n            if (abs(nums(i)) > abs(largest)) then\n                largest = nums(i)\n            end if\n        end do\n\n        print '(I0)', closest\n        print '(I0)', largest\n    end subroutine solve\nend program main",
  "2243": "program main\n    implicit none\n\n    character(len=100) :: s\n    integer :: k\n    integer :: i\n\n    ! Example 1\n    s = \"11111222223 \"\n    k = 3\n    call solve(s, k)\n    print *, s\n\n    ! Example 2\n    s = \"00000000 \"\n    k = 3\n    call solve(s, k)\n    print *, s\n\ncontains\n\nsubroutine solve(s, k)\n    implicit none\n    character(len=*), intent(inout) :: s\n    integer, intent(in) :: k\n    integer :: n\n    integer :: i\n    integer :: j\n    integer :: carry\n\n    n = len_trim(s)\n    do while (n > k)\n        ! Divide s into consecutive groups of size k\n        i = 1\n        j = k\n        do while (j <= n)\n            ! Replace each group of s with a string representing the sum of all its digits\n            carry = 0\n            do while (i <= j)\n                carry = carry + ichar(s(i:i)) - ichar('0')\n                i = i + 1\n            end do\n            write (s(j:j), '(I1)') carry\n            j = j + 1\n        end do\n\n        ! Merge consecutive groups together to form a new string\n        s = merge(s(1:j-1), s(j:))\n        n = len_trim(s)\n    end do\nend subroutine solve\n\nend program main",
  "2248": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: nums(n) = reshape([3, 1, 2, 4, 5, 1, 2, 3, 4, 3, 4, 5, 6], shape(nums))\n    integer, allocatable :: result(:)\n\n    call solve(nums, result)\n\n    write (*, '(*(g0, :, \", \"))') result\n\ncontains\n\n    subroutine solve(nums, result)\n        implicit none\n        integer, intent(in) :: nums(:, :)\n        integer, allocatable, intent(out) :: result(:)\n        integer :: i, j, k\n        logical :: found\n\n        allocate(result(size(nums)))\n\n        do i = 1, size(nums)\n            found = .false.\n            do j = 1, size(nums)\n                if (all(nums(i) == nums(j))) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) then\n                k = k + 1\n                result(k) = nums(i)(1)\n            end if\n        end do\n\n        result = sort(result)\n    end subroutine solve\n\nend program main",
  "2255": "program main\n    implicit none\n\n    integer :: i, n\n    character(len=100) :: s\n    character(len=10), allocatable :: words(:)\n\n    call get_command_argument(1, s)\n    read (s, *) n\n    allocate (words(n))\n    do i = 1, n\n        call get_command_argument(i+1, s)\n        read (s, *) words(i)\n    end do\n\n    print '(I0)', count_prefixes(words, s)\n\ncontains\n\n    function count_prefixes(words, s) result(count)\n        implicit none\n        character(len=*), intent(in) :: words(:), s\n        integer :: count\n        integer :: i\n\n        count = 0\n        do i = 1, size(words)\n            if (index(s, words(i)) == 1) then\n                count = count + 1\n            end if\n        end do\n    end function count_prefixes\n\nend program main",
  "2259": "program main\n    implicit none\n\n    character(len=100) :: number\n    character(len=100) :: digit\n    character(len=100) :: result\n\n    ! Examples\n    number = \"123\"\n    digit = \"3\"\n    call solve(number, digit, result)\n    write (*,*) trim(result)\n\n    number = \"1231\"\n    digit = \"1\"\n    call solve(number, digit, result)\n    write (*,*) trim(result)\n\n    number = \"551\"\n    digit = \"5\"\n    call solve(number, digit, result)\n    write (*,*) trim(result)\n\ncontains\n\n    subroutine solve(number, digit, result)\n        implicit none\n        character(len=*), intent(in) :: number\n        character(len=*), intent(in) :: digit\n        character(len=*), intent(out) :: result\n\n        integer :: i\n        integer :: j\n        integer :: n\n        integer :: d\n\n        n = len_trim(number)\n        d = len_trim(digit)\n\n        do i = 1, n - d + 1\n            if (number(i:i+d-1) == digit) then\n                result = number(:i-1) // number(i+d:)\n                exit\n            end if\n        end do\n\n    end subroutine solve\n\nend program main",
  "2264": "program main\n    implicit none\n\n    character(len=:), allocatable :: num\n    character(len=:), allocatable :: max_good_int\n\n    ! Examples taken from the problem statement\n    num = \"6**777**133339\"\n    call get_max_good_int(num, max_good_int)\n    write (*, '(A)') trim(max_good_int)\n\n    num = \"23**000**19\"\n    call get_max_good_int(num, max_good_int)\n    write (*, '(A)') trim(max_good_int)\n\n    num = \"42352338\"\n    call get_max_good_int(num, max_good_int)\n    write (*, '(A)') trim(max_good_int)\n\ncontains\n\n    subroutine get_max_good_int(num, max_good_int)\n        implicit none\n        character(len=*), intent(in) :: num\n        character(len=:), allocatable, intent(out) :: max_good_int\n        integer :: i, j, k, n, m\n        logical :: found\n\n        ! Initialize variables\n        max_good_int = \"\"\n        n = len(num)\n        found = .false.\n\n        ! Iterate over all possible starting indices\n        do i = 1, n - 2\n            ! Check if the current substring has length 3\n            if (n - i < 3) exit\n\n            ! Check if the current substring consists of only one unique digit\n            found = .true.\n            do j = i + 1, i + 2\n                do k = j + 1, i + 2\n                    if (num(j:k) == num(i:j)) then\n                        found = .false.\n                        exit\n                    end if\n                end do\n                if (.not. found) exit\n            end do\n\n            ! If the current substring is good, update the maximum good integer\n            if (found) then\n                m = max(m, len(num(i:i+2)))\n                max_good_int = num(i:i+2)\n            end if\n        end do\n    end subroutine get_max_good_int\nend program main",
  "2269": "program main\n    ! Solves the \"K-Beauty\" problem\n    implicit none\n\n    integer :: num, k, beauty\n\n    num = 240\n    k = 2\n    print '(I0)', k_beauty(num, k)\n\n    num = 430043\n    k = 2\n    print '(I0)', k_beauty(num, k)\n\ncontains\n\nfunction k_beauty(num, k) result(beauty)\n    implicit none\n    integer, intent(in) :: num, k\n    character(len=len(num)) :: str\n    integer :: i, j, div\n    logical :: found\n\n    beauty = 0\n    str = trim(adjustl(num))\n    do i = 1, len(str)-k+1\n        found = .false.\n        do j = i+k-1, len(str)\n            if (str(i:j) == adjustl(str(i:j))) then\n                div = 0\n                do while (div < num)\n                    if (mod(num, div) == 0) then\n                        found = .true.\n                        exit\n                    end if\n                    div = div + 1\n                end do\n                if (found) then\n                    beauty = beauty + 1\n                    exit\n                end if\n            end if\n        end do\n    end do\nend function k_beauty\n\nend program main",
  "2273": "program main\n    implicit none\n\n    character(len=10), dimension(:), allocatable :: words\n    integer :: i, j\n\n    allocate(words(5))\n    words(1) = 'abba'\n    words(2) = 'baba'\n    words(3) = 'bbaa'\n    words(4) = 'cd'\n    words(5) = 'cd'\n\n    do while (any(words(2:) == words(1:-1)))\n        do i = 2, size(words)-1\n            if (words(i-1) == words(i) .and. words(i+1) == words(i)) then\n                deallocate(words(i))\n                exit\n            end if\n        end do\n    end do\n\n    print '(A)', words\n\nend program main",
  "2278": "program main\n    implicit none\n\n    character(len=*), parameter :: s = \"foobar \"\n    character, parameter :: letter = \"o\"\n    integer :: result\n\n    result = solve(s, letter)\n    print \"(I0)\", result\n\ncontains\n\n    function solve(s, letter) result(percentage)\n        implicit none\n        character(len=*), intent(in) :: s\n        character, intent(in) :: letter\n        integer :: i, n, percentage\n\n        n = len(s)\n        do i = 1, n\n            if (s(i:i) == letter) then\n                percentage = percentage + 1\n            end if\n        end do\n        percentage = percentage * 100 / n\n        percentage = int(percentage, kind=4)\n    end function solve\nend program main",
  "2283": "program main\n    implicit none\n\n    character(len=10) :: num\n    integer :: n\n    logical :: result\n\n    ! Example 1\n    num = \"1210\"\n    n = len(trim(num))\n    result = checkOccurrences(num, n)\n    if (result) then\n        print *, \"Example 1: True\"\n    else\n        print *, \"Example 1: False\"\n    end if\n\n    ! Example 2\n    num = \"030\"\n    n = len(trim(num))\n    result = checkOccurrences(num, n)\n    if (result) then\n        print *, \"Example 2: True\"\n    else\n        print *, \"Example 2: False\"\n    end if\n\ncontains\n\n    function checkOccurrences(num, n) result(res)\n        implicit none\n        character(len=*), intent(in) :: num\n        integer, intent(in) :: n\n        logical :: res\n        integer :: i, count\n\n        do i = 0, n - 1\n            count = 0\n            do j = 1, n\n                if (num(j:j) == char(48 + i)) then\n                    count = count + 1\n                end if\n            end do\n            if (count /= num(i+1:i+1)) then\n                res = .false.\n                return\n            end if\n        end do\n        res = .true.\n    end function checkOccurrences\n\nend program main",
  "2287": "program main\n    implicit none\n\n    character(len=*), parameter :: s = \"ilovecodingonleetcode \"\n    character(len=*), parameter :: target = \"code \"\n    integer :: n\n\n    n = maxCopies(s, target)\n    write (*,*) n\n\ncontains\n\n    function maxCopies(s, target) result(n)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=*), intent(in) :: target\n        integer :: n\n        integer :: i, j, k, l\n\n        n = 0\n        do i = 1, len(s)-len(target)+1\n            do j = i+len(target)-1, len(s)\n                if (s(i:j) == target) then\n                    n = max(n, j-i+1)\n                end if\n            end do\n        end do\n    end function maxCopies\nend program main",
  "2299": "program main\n    implicit none\n\n    integer :: i\n    character(len=100) :: password\n\n    do i = 1, size(examples)\n        read(examples(i), *) password\n        write(*, '(L1)') is_strong_password(password)\n    end do\n\ncontains\n\n    function is_strong_password(password) result(is_strong)\n        implicit none\n        character(len=*), intent(in) :: password\n        logical :: is_strong\n\n        is_strong = len(password) >= 8 &\n            .and. index(password, 'abcdefghijklmnopqrstuvwxyz') /= 0 &\n            .and. index(password, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ') /= 0 &\n            .and. index(password, '0123456789') /= 0 &\n            .and. index(password, '!@#$%^&*()-+ ') /= 0 &\n            .and. count(password == password(1:size(password)-1)) < 2\n    end function is_strong_password\n\nend program main\n\ncharacter(len=100), parameter :: examples(3) = (/ '\"IloveLe3tcode! \"', &\n                                                  '\"Me+You--IsMyDream \"', &\n                                                  '\"1aB! \"' /)",
  "2303": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: nb_examples = 3\n    type(brackets) :: brackets\n    real(kind=DP), allocatable :: example(:,:)\n    integer :: i, j\n\n    allocate(example(nb_examples, 2))\n    example(1, :) = [3, 50]\n    example(2, :) = [7, 10]\n    example(3, :) = [12, 25]\n\n    do i = 1, nb_examples\n        brackets = brackets_type(example(i, 1:2))\n        write(*, '(A, F8.4)') 'Example ', i, ': ', &\n            calculate_tax(brackets, example(i, 2))\n    end do\n\ncontains\n\n    function calculate_tax(brackets, income) result(tax)\n        class(brackets), intent(in) :: brackets\n        real(kind=DP), value :: income\n        real(kind=DP) :: tax\n        integer :: i\n\n        tax = 0.0_DP\n        do i = 1, size(brackets%upper)\n            if (income >= brackets%upper(i)) then\n                tax = tax + (income - brackets%upper(i-1)) * brackets%percent(i) / 100.0_DP\n            else\n                exit\n            end if\n        end do\n    end function calculate_tax\n\nend program main\n\ntype, abstract :: brackets\n    integer, allocatable :: upper(:)\n    real(kind=DP), allocatable :: percent(:)\ncontains\n    procedure(calculate_tax_interface), deferred :: calculate_tax\nend type brackets\n\nabstract interface\n    function calculate_tax_interface(brackets, income) result(tax)\n        import :: brackets, DP\n        class(brackets), intent(in) :: brackets\n        real(kind=DP), value :: income\n        real(kind=DP) :: tax\n    end function calculate_tax_interface\nend interface\n\ntype, extends(brackets) :: brackets_type\n    contains\n        procedure :: calculate_tax => calculate_tax_impl\nend type brackets_type\n\nfunction calculate_tax_impl(brackets, income) result(tax)\n    class(brackets_type), intent(in) :: brackets\n    real(kind=DP), value :: income\n    real(kind=DP) :: tax\n    integer :: i\n\n    tax = 0.0_DP\n    do i = 1, size(brackets%upper)\n        if (income >= brackets%upper(i)) then\n            tax = tax + (income - brackets%upper(i-1)) * brackets%percent(i) / 100.0_DP\n        else\n            exit\n        end if\n    end do\nend function calculate_tax_impl\n\nsubroutine read_input(brackets, example)\n    type(brackets), intent(out) :: brackets\n    real(kind=DP), allocatable, intent(out) :: example(:,:)\n    integer :: nb_brackets, i\n\n    read(*, *) nb_brackets\n    allocate(brackets%upper(nb_brackets))\n    allocate(brackets%percent(nb_brackets))\n    allocate(example(nb_brackets, 2))\n    do i = 1, nb_brackets\n        read(*, *) example(i, :)\n        brackets%upper(i) = example(i, 1)\n        brackets%percent(i) = example(i, 2)\n    end do\nend subroutine read_input\n\nsubroutine print_output(tax)\n    real(kind=DP), value :: tax\n\n    write(*, '(F8.4)') tax\nend subroutine print_output\n\nend",
  "2309": "program main\n    implicit none\n\n    character(len=:), allocatable :: s\n    character(len=1) :: result\n\n    s = \"lEeTcOdE \"\n    write (*,*) 'Example 1:'\n    write (*,'(A)') 'Input: ', trim(s)\n    call solve(s, result)\n    write (*,'(A,A)') 'Output: ', trim(result)\n    ! Output: Example 1:\n    ! Input: lEeTcOdE\n    ! Output: E\n\n    s = \"aRRazFif \"\n    write (*,*) 'Example 2:'\n    write (*,'(A)') 'Input: ', trim(s)\n    call solve(s, result)\n    write (*,'(A,A)') 'Output: ', trim(result)\n    ! Output: Example 2:\n    ! Input: aRRazFif\n    ! Output: R\n\n    s = \"AbCdEfGhIjK \"\n    write (*,*) 'Example 3:'\n    write (*,'(A)') 'Input: ', trim(s)\n    call solve(s, result)\n    write (*,'(A,A)') 'Output: ', trim(result)\n    ! Output: Example 3:\n    ! Input: AbCdEfGhIjK\n    ! Output:\n\ncontains\n\n    subroutine solve(s, result)\n        implicit none\n        character(len=*), intent(in) :: s\n        character(len=1), intent(out) :: result\n\n        integer :: i, j, n\n        logical :: found\n\n        n = len(s)\n        do i = 1, n - 1\n            do j = i + 1, n\n                if (s(i:i) == s(j:j)) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) then\n                result = s(i:i)\n                exit\n            end if\n        end do\n\n        if (result == '') then\n            result = ''\n        else\n            result = toupper(result)\n        end if\n\n    end subroutine solve\n\nend program main",
  "2315": "program main\n    implicit none\n    character(len=:), allocatable :: s\n    integer :: n\n\n    s = \"l|\\*e\\*et|c\\*\\*o|\\*de|\"\n    write(*,*) \"Example 1:\"\n    write(*,*) \"Input: \", s\n    n = count_asterisk(s)\n    write(*,*) \"Output: \", n\n    write(*,*) \"\"\n\n    s = \"iamprogrammer \"\n    write(*,*) \"Example 2:\"\n    write(*,*) \"Input: \", s\n    n = count_asterisk(s)\n    write(*,*) \"Output: \", n\n    write(*,*) \"\"\n\n    s = \"yo|uar|e\\*\\*|b|e\\*\\*\\*au|tifu|l \"\n    write(*,*) \"Example 3:\"\n    write(*,*) \"Input: \", s\n    n = count_asterisk(s)\n    write(*,*) \"Output: \", n\n    write(*,*) \"\"\n\ncontains\n\n    function count_asterisk(str) result(n)\n        implicit none\n        character(len=*), intent(in) :: str\n        integer :: i, j, n\n\n        n = 0\n        do i = 1, len(str)-1, 2\n            if (str(i:i+1) == \"|\") then\n                cycle\n            end if\n            do j = i+2, len(str)-1, 2\n                if (str(j:j+1) == \"|\") then\n                    exit\n                end if\n                if (str(j:j+1) == \"*\") then\n                    n = n + 1\n                end if\n            end do\n        end do\n    end function count_asterisk\n\nend program main",
  "2319": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n, n) :: grid\n    logical :: is_x_matrix\n\n    ! Example 1\n    grid(:, :) = reshape([2, 0, 0, 1, &\n                           0, 3, 1, 0, &\n                           0, 5, 2, 0, &\n                           4, 0, 0, 2], shape(grid))\n    write(*, '(L1)') is_x_matrix(grid)\n\n    ! Example 2\n    grid(:, :) = reshape([5, 7, 0, &\n                           0, 3, 1, &\n                           0, 5, 0], shape(grid))\n    write(*, '(L1)') is_x_matrix(grid)\n\ncontains\n\n    function is_x_matrix(grid) result(is_x)\n        implicit none\n        integer, intent(in) :: grid(:, :)\n        logical :: is_x\n        integer :: i, j\n\n        is_x = .true.\n\n        do i = 1, size(grid, 1)\n            if (grid(i, i) == 0) then\n                is_x = .false.\n                exit\n            end if\n        end do\n\n        if (is_x) then\n            do i = 1, size(grid, 1) - 1\n                do j = i + 1, size(grid, 2)\n                    if (grid(i, j) /= 0) then\n                        is_x = .false.\n                        exit\n                    end if\n                end do\n                if (.not. is_x) exit\n            end do\n        end if\n\n        if (is_x) then\n            do j = 1, size(grid, 2)\n                if (grid(j, j) == 0) then\n                    is_x = .false.\n                    exit\n                end if\n            end do\n        end if\n\n    end function is_x_matrix\n\nend program main",
  "2325": "program main\n    implicit none\n\n    character(len=*), parameter :: key = \"**hap**p** **bo**y \"\n    character(len=*), parameter :: message = \"vkbs bs t suepuv \"\n    character(len=:), allocatable :: decoded_message\n\n    call decode_message(key, message, decoded_message)\n    write (*,*) decoded_message\n\ncontains\n\nsubroutine decode_message(key, message, decoded_message)\n    implicit none\n    character(len=*), intent(in) :: key\n    character(len=*), intent(in) :: message\n    character(len=:), allocatable, intent(out) :: decoded_message\n\n    integer :: i, j, k\n    character(len=1), dimension(26) :: order\n    character(len=1), dimension(26) :: alphabet\n    character(len=1), dimension(:), allocatable :: substitution_table\n\n    ! Initialize the substitution table\n    do i = 1, 26\n        order(i) = key(i:i)\n        alphabet(i) = char(97 + i - 1)\n    end do\n\n    ! Create the substitution table\n    allocate(substitution_table(26))\n    do i = 1, 26\n        j = index(alphabet, order(i))\n        substitution_table(j) = alphabet(i)\n    end do\n\n    ! Substitute each letter in the message\n    allocate(character(len=len(message)) :: decoded_message)\n    do i = 1, len(message)\n        if (message(i:i) == ' ') then\n            decoded_message(i:i) = ' '\n        else\n            k = index(alphabet, message(i:i))\n            decoded_message(i:i) = substitution_table(k)\n        end if\n    end do\nend subroutine decode_message\n\nend program main",
  "2331": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, output_unit\n    implicit none\n    integer, parameter :: n = 7\n    integer, dimension(n) :: values = [2, 1, 3, 0, 0, 0, 1]\n    type(binary_tree), pointer :: root\n    logical :: result\n\n    call build_tree(values, root)\n    result = evaluate_tree(root)\n    write (output_unit, '(*(g0))') 'Result: ', result\n\ncontains\n\n    subroutine build_tree(values, root)\n        implicit none\n        integer, dimension(:), intent(in) :: values\n        type(binary_tree), pointer, intent(out) :: root\n        integer :: i, j, k\n\n        allocate(root)\n        if (size(values) == 1) then\n            root%value = values(1)\n        else\n            root%value = values(1)\n            do i = 2, size(values) - 1, 2\n                allocate(root%left)\n                call build_tree(values(i:i+1), root%left)\n            end do\n            do i = 3, size(values) - 1, 2\n                allocate(root%right)\n                call build_tree(values(i:i+1), root%right)\n            end do\n        end if\n    end subroutine build_tree\n\n    function evaluate_tree(root) result(result)\n        implicit none\n        type(binary_tree), pointer, intent(in) :: root\n        logical :: result\n\n        if (.not. associated(root)) then\n            result = .false.\n        else if (associated(root%left, root%right)) then\n            result = evaluate_tree(root%left) .and. evaluate_tree(root%right)\n        else if (associated(root%left)) then\n            result = evaluate_tree(root%left) .or. root%value == 1\n        else if (associated(root%right)) then\n            result = evaluate_tree(root%right) .or. root%value == 1\n        else\n            result = root%value == 1\n        end if\n    end function evaluate_tree\n\nend program main\n\ntype :: binary_tree\n    integer :: value\n    class(binary_tree), pointer :: left => null(), right => null()\nend type binary_tree",
  "2335": "program main\n    implicit none\n\n    integer :: i, j, k, n, m, l\n    integer, parameter :: amount(3) = [1, 4, 2]\n\n    write (*, '(I0)') solve(amount)\n\ncontains\n\n    function solve(amount) result(res)\n        implicit none\n        integer, intent(in) :: amount(:)\n        integer :: res\n\n        res = minval([(/ (i + 1) * (j + 1) * (k + 1), &\n                         i = 0, amount(1) - 1, 1 ), &\n                       (/ (i + 1) * (j + 1), &\n                          i = 0, amount(2) - 1, 1 ), &\n                       (/ (i + 1), &\n                          i = 0, amount(3) - 1, 1 ) /)])\n    end function solve\n\nend program main",
  "2341": "program main\n    implicit none\n\n    integer, parameter :: n = 8\n    integer, dimension(n) :: nums\n    integer, dimension(2) :: answer\n\n    ! Example 1\n    nums = [1, 3, 2, 1, 3, 2, 2]\n    call solve(nums, answer)\n    print '(A, I0, A, I0)', 'Example 1: ', answer(1), ' ', answer(2)\n\n    ! Example 2\n    nums = [1, 1]\n    call solve(nums, answer)\n    print '(A, I0, A, I0)', 'Example 2: ', answer(1), ' ', answer(2)\n\n    ! Example 3\n    nums = [0]\n    call solve(nums, answer)\n    print '(A, I0, A, I0)', 'Example 3: ', answer(1), ' ', answer(2)\n\ncontains\n\n    subroutine solve(nums, answer)\n        implicit none\n        integer, dimension(:), intent(inout) :: nums\n        integer, dimension(2), intent(out) :: answer\n        integer :: i, j, count\n\n        count = 0\n        do while (any(nums == nums(1)))\n            i = minloc(nums, dim=1, mask=(nums == nums(1)))[1]\n            j = maxloc(nums, dim=1, mask=(nums == nums(1)))[1]\n            if (i /= j) then\n                nums(i) = -1\n                nums(j) = -1\n                count = count + 1\n            end if\n        end do\n        answer(1) = count\n        answer(2) = count(nums /= -1)\n    end subroutine solve\nend program main",
  "2347": "program poker_hands\n    implicit none\n\n    integer, parameter :: ncards = 5\n    integer, dimension(ncards) :: ranks\n    character(len=1), dimension(ncards) :: suits\n\n    call get_input(ranks, suits)\n\n    print '(A)', get_best_hand(ranks, suits)\n\ncontains\n\n    subroutine get_input(ranks, suits)\n        implicit none\n        integer, dimension(:), intent(out) :: ranks\n        character(len=1), dimension(:), intent(out) :: suits\n\n        integer :: i\n\n        do i = 1, ncards\n            read *, ranks(i), suits(i)\n        end do\n    end subroutine get_input\n\n    function get_best_hand(ranks, suits) result(best_hand)\n        implicit none\n        integer, dimension(:), intent(in) :: ranks\n        character(len=1), dimension(:), intent(in) :: suits\n        character(len=*) :: best_hand\n\n        integer :: i, j, k, l, m\n        integer :: flush_count, three_kind_count, pair_count\n        integer :: high_card\n        logical :: flush\n\n        flush_count = 0\n        three_kind_count = 0\n        pair_count = 0\n        high_card = -1\n\n        ! Count the number of cards of each type\n        do i = 1, ncards\n            if (flush_count < 1 .and. all(suits(i) == suits(1))) then\n                flush_count = flush_count + 1\n            else if (three_kind_count < 1 .and. count(ranks(i) == ranks(1)) == 3) then\n                three_kind_count = three_kind_count + 1\n            else if (pair_count < 1 .and. count(ranks(i) == ranks(1)) == 2) then\n                pair_count = pair_count + 1\n            else if (high_card < 1 .or. ranks(i) > high_card) then\n                high_card = ranks(i)\n            end if\n        end do\n\n        ! Check for flush\n        if (flush_count >= 1) then\n            best_hand = \"Flush \"\n        ! Check for three of a kind\n        else if (three_kind_count >= 1) then\n            best_hand = \"Three of a Kind \"\n        ! Check for pair\n        else if (pair_count >= 1) then\n            best_hand = \"Pair \"\n        ! Otherwise it's a high card\n        else\n            best_hand = \"High Card \"\n        end if\n\n    end function get_best_hand\n\nend program poker_hands",
  "2351": "program main\n    implicit none\n\n    character(len=100) :: s\n    integer :: i, j, n\n    logical :: found\n\n    ! read input\n    read(*,*) s\n\n    ! find first repeated letter\n    do i = 1, len_trim(s)-1\n        found = .false.\n        do j = i+1, len_trim(s)\n            if (s(i:i) == s(j:j)) then\n                found = .true.\n                exit\n            end if\n        end do\n        if (found) then\n            write(*,'(A)') s(i:i)\n            exit\n        end if\n    end do\n\nend program main",
  "2357": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums\n    integer :: i, x, min_operations\n\n    ! Example 1\n    nums = [1, 5, 0, 3, 5]\n    write(*,*) 'Example 1:'\n    write(*,*) 'Input:', nums\n    call solve(nums, min_operations)\n    write(*,*) 'Output:', min_operations\n    write(*,*) ''\n\n    ! Example 2\n    nums = [0]\n    write(*,*) 'Example 2:'\n    write(*,*) 'Input:', nums\n    call solve(nums, min_operations)\n    write(*,*) 'Output:', min_operations\n    write(*,*) ''\n\ncontains\n\n    subroutine solve(nums, min_operations)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer, intent(out) :: min_operations\n        integer :: i, x\n\n        min_operations = 0\n        do while (any(nums > 0))\n            x = minval(nums(nums > 0), mask=nums > 0)\n            min_operations = min_operations + 1\n            do i = 1, size(nums)\n                if (nums(i) > 0) then\n                    nums(i) = nums(i) - x\n                end if\n            end do\n        end do\n    end subroutine solve\n\nend program main",
  "2363": "program main\n    use, intrinsic :: iso_fortran_env, only : error_unit, DP => REAL64\n    implicit none\n    integer, parameter :: n = 3\n    integer, dimension(n, 2) :: items1 = reshape([1,1,4,5,3,8],[n,2])\n    integer, dimension(n, 2) :: items2 = reshape([3,1,1,5],[n,2])\n    integer, dimension(:, :), allocatable :: ret\n\n    allocate(ret(n, 2))\n\n    call solve(items1, items2, ret)\n\n    write (unit=error_unit, fmt='(*(I0, 1X))') ret\n\ncontains\n\n    subroutine solve(items1, items2, ret)\n        implicit none\n        integer, intent(in) :: items1(:, :)\n        integer, intent(in) :: items2(:, :)\n        integer, intent(out) :: ret(:, :)\n        integer :: i, j, k\n        integer :: sum_weights\n\n        do i = 1, size(items1, 1)\n            do j = 1, size(items2, 1)\n                if (items1(i, 1) == items2(j, 1)) then\n                    sum_weights = items1(i, 2) + items2(j, 2)\n                    do k = 1, size(ret, 1)\n                        if (ret(k, 1) == items1(i, 1)) then\n                            ret(k, 2) = sum_weights\n                            exit\n                        end if\n                    end do\n                end if\n            end do\n        end do\n\n        ! sort ret by value\n        call sort(ret, 1)\n\n    end subroutine solve\n\nend program main",
  "2367": "program main\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, parameter :: diff = 3\n    integer, dimension(n) :: nums\n    integer :: i, j, k\n    integer :: count\n\n    ! Examples from the problem statement\n    nums = [0, 1, 4, 6, 7, 10]\n    write (*, '(A, I0)') 'Example 1: ', solve(nums, diff)\n    nums = [4, 5, 6, 7, 8, 9]\n    write (*, '(A, I0)') 'Example 2: ', solve(nums, diff)\n\ncontains\n\n    function solve(nums, diff) result(count)\n        implicit none\n        integer, intent(in) :: nums(:), diff\n        integer :: count\n        integer :: i, j, k\n\n        count = 0\n        do i = 1, size(nums) - 2\n            do j = i + 1, size(nums) - 1\n                do k = j + 1, size(nums)\n                    if (nums(k) - nums(j) == diff .and. &\n                        nums(j) - nums(i) == diff) then\n                        count = count + 1\n                    end if\n                end do\n            end do\n        end do\n    end function solve\nend program main",
  "2373": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n, n) :: grid\n    integer, dimension((n-2), (n-2)) :: maxLocal\n\n    ! Example 1\n    grid(:, :) = reshape([9, 9, 8, 1, &\n                           5, 6, 2, 6, &\n                           8, 2, 6, 4, &\n                           6, 2, 2, 2], shape(grid))\n    call solve(grid, maxLocal)\n    write(*, '(A,*(I0, 1X))') 'Example 1:', maxLocal\n\n    ! Example 2\n    grid(:, :) = reshape([1, 1, 1, 1, 1, &\n                           1, 1, 1, 1, 1, &\n                           1, 1, 2, 1, 1, &\n                           1, 1, 1, 1, 1, &\n                           1, 1, 1, 1, 1], shape(grid))\n    call solve(grid, maxLocal)\n    write(*, '(A,*(I0, 1X))') 'Example 2:', maxLocal\n\ncontains\n\n    subroutine solve(grid, maxLocal)\n        implicit none\n        integer, intent(in) :: grid(:, :)\n        integer, intent(out) :: maxLocal(:, :)\n\n        integer :: i, j, k, l\n        integer :: maxValue\n\n        do i = 2, n - 1\n            do j = 2, n - 1\n                maxValue = grid(i, j)\n                do k = i - 1, i + 1\n                    do l = j - 1, j + 1\n                        if (grid(k, l) > maxValue) then\n                            maxValue = grid(k, l)\n                        end if\n                    end do\n                end do\n                maxLocal(i - 1, j - 1) = maxValue\n            end do\n        end do\n\n    end subroutine solve\n\nend program main",
  "2379": "program main\n    implicit none\n\n    character(len=100) :: blocks\n    integer :: n, k, i, j, count, min_ops\n\n    ! read input\n    read(*,*) blocks\n    read(*,*) n\n    read(*,*) k\n\n    ! initialize variables\n    count = 0\n    min_ops = 1000000000\n\n    ! loop through blocks\n    do i = 1, n\n        if (blocks(i:i) == 'W') then\n            count = 0\n        else\n            count = count + 1\n        end if\n\n        ! check for k consecutive black blocks\n        if (count >= k) then\n            min_ops = min(min_ops, i - k + 1)\n        end if\n    end do\n\n    ! print output\n    write (*,*) min_ops\n\nend program main",
  "2383": "program main\n    implicit none\n\n    integer :: initialEnergy, initialExperience, energy(100), experience(100)\n    integer :: i, j, n, totalHours, minHours\n\n    read(*,*) initialEnergy\n    read(*,*) initialExperience\n    read(*,*) n\n    do i = 1, n\n        read(*,*) energy(i)\n        read(*,*) experience(i)\n    end do\n\n    ! Initialize variables\n    totalHours = 0\n    minHours = 1000000\n\n    ! Loop over all opponents\n    do i = 1, n\n        ! Check if current opponent can be defeated\n        if (initialEnergy > energy(i) .and. initialExperience > experience(i)) then\n            ! Update initial energy and experience\n            initialEnergy = initialEnergy - energy(i)\n            initialExperience = initialExperience + experience(i)\n            ! Increment total hours\n            totalHours = totalHours + 1\n        else\n            ! Exit loop if current opponent cannot be defeated\n            exit\n        end if\n    end do\n\n    ! Check if all opponents can be defeated\n    if (totalHours < minHours) then\n        minHours = totalHours\n    end if\n\n    ! Print result\n    write (*,*) minHours\n\nend program main",
  "2389": "program main\n    implicit none\n\n    integer, parameter :: n = 4, m = 3\n    integer, dimension(n) :: nums = (/4, 5, 2, 1/)\n    integer, dimension(m) :: queries = (/3, 10, 21/)\n    integer, dimension(m) :: answer\n\n    call solve(nums, queries, answer)\n\n    write (*, '(A)') 'Answer:'\n    write (*, '(*(I0, 1X))') answer\n\ncontains\n\n    subroutine solve(nums, queries, answer)\n        implicit none\n        integer, intent(in) :: nums(:), queries(:)\n        integer, intent(out) :: answer(:)\n\n        integer :: i, j, k, l, m, n, q\n        integer :: max_size\n        logical :: found\n\n        do i = 1, m\n            max_size = 0\n            found = .false.\n            do j = 1, n\n                if (nums(j) <= queries(i)) then\n                    do k = j + 1, n\n                        if (nums(k) <= queries(i)) then\n                            do l = k + 1, n\n                                if (nums(l) <= queries(i)) then\n                                    do m = l + 1, n\n                                        if (nums(m) <= queries(i)) then\n                                            if (max_size < 4) then\n                                                max_size = 4\n                                                found = .true.\n                                            end if\n                                        else\n                                            exit\n                                        end if\n                                    end do\n                                    if (found) exit\n                                end if\n                            end do\n                            if (found) exit\n                        end if\n                    end do\n                    if (found) exit\n                end if\n            end do\n            answer(i) = max_size\n        end do\n\n    end subroutine solve\n\nend program main",
  "2395": "program main\n    implicit none\n\n    integer :: i, j, k, n\n    integer, parameter :: nmax = 1000\n    integer :: nums(nmax)\n    logical :: result\n\n    ! Example 1\n    nums = (/4, 2, 4/)\n    write(*,*) 'Example 1'\n    write(*,*) 'Input: ', nums\n    result = equal_sum_subarrays(nums)\n    write(*,*) 'Output: ', result\n    write(*,*) ''\n\n    ! Example 2\n    nums = (/1, 2, 3, 4, 5/)\n    write(*,*) 'Example 2'\n    write(*,*) 'Input: ', nums\n    result = equal_sum_subarrays(nums)\n    write(*,*) 'Output: ', result\n    write(*,*) ''\n\n    ! Example 3\n    nums = (/0, 0, 0/)\n    write(*,*) 'Example 3'\n    write(*,*) 'Input: ', nums\n    result = equal_sum_subarrays(nums)\n    write(*,*) 'Output: ', result\n    write(*,*) ''\n\ncontains\n\n    function equal_sum_subarrays(nums) result(result)\n        implicit none\n        integer, intent(in) :: nums(:)\n        logical :: result\n        integer :: i, j, k, n\n\n        n = size(nums)\n        do i = 1, n - 1\n            do j = i + 1, n\n                if (sum(nums(i:j)) == sum(nums(j:i))) then\n                    result = .true.\n                    return\n                end if\n            end do\n        end do\n        result = .false.\n    end function equal_sum_subarrays\n\nend program main",
  "2399": "program main\n    implicit none\n\n    character(len=52) :: s\n    integer, dimension(26) :: distance\n    logical :: result\n\n    ! Examples taken from the problem statement\n    s = \"abaccb \"\n    distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    result = wellSpacedString(s, distance)\n    write (*,*) result\n\n    s = \"aa \"\n    distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    result = wellSpacedString(s, distance)\n    write (*,*) result\n\ncontains\n\nlogical function wellSpacedString(s, distance)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer, dimension(:), intent(in) :: distance\n    integer :: i, j, k\n\n    wellSpacedString = .true.\n\n    do i = 0, 25\n        if (s(i+1:i+1) /= '') then\n            j = index(s, s(i+1:i+1))\n            k = index(s, s(i+1:i+1), back=.true.)\n            if (j > k) then\n                wellSpacedString = .false.\n                exit\n            end if\n            if (k - j < distance(i)) then\n                wellSpacedString = .false.\n                exit\n            end if\n        end if\n    end do\nend function wellSpacedString\n\nend program main",
  "2404": "program main\n    implicit none\n\n    integer, parameter :: n = 8\n    integer, dimension(n) :: nums\n    integer :: i, j, k, l, m, n_even, max_count, min_value\n    logical :: found\n\n    ! Examples\n    nums(1) = 0\n    nums(2) = 1\n    nums(3) = 2\n    nums(4) = 2\n    nums(5) = 4\n    nums(6) = 4\n    nums(7) = 1\n    nums(8) = 4\n\n    ! Solve the problem\n    n_even = 0\n    max_count = 0\n    min_value = 0\n    do i = 1, size(nums)\n        if (mod(nums(i), 2) == 0) then\n            n_even = n_even + 1\n            found = .false.\n            do j = 1, n_even\n                if (nums(i) == nums(j)) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (.not. found) then\n                nums(n_even) = nums(i)\n            end if\n        end if\n    end do\n\n    if (n_even > 0) then\n        do i = 1, n_even\n            k = 0\n            do j = 1, n_even\n                if (nums(i) == nums(j)) then\n                    k = k + 1\n                end if\n            end do\n            if (k > max_count) then\n                max_count = k\n                min_value = nums(i)\n            else if (k == max_count) then\n                if (min_value > nums(i)) then\n                    min_value = nums(i)\n                end if\n            end if\n        end do\n    end if\n\n    write (*, '(I0)') min_value\n\nend program main",
  "2409": "program main\n    implicit none\n\n    character(len=5) :: arriveAlice, leaveAlice, arriveBob, leaveBob\n    integer :: numDays\n\n    ! Example 1\n    arriveAlice = '08-15 '\n    leaveAlice = '08-18 '\n    arriveBob = '08-16 '\n    leaveBob = '08-19 '\n    write(*,*) solve(arriveAlice, leaveAlice, arriveBob, leaveBob)\n\n    ! Example 2\n    arriveAlice = '10-01 '\n    leaveAlice = '10-31 '\n    arriveBob = '11-01 '\n    leaveBob = '12-31 '\n    write(*,*) solve(arriveAlice, leaveAlice, arriveBob, leaveBob)\n\ncontains\n\n    function solve(arriveAlice, leaveAlice, arriveBob, leaveBob) result(numDays)\n        implicit none\n        character(len=5), intent(in) :: arriveAlice, leaveAlice, arriveBob, leaveBob\n        integer :: numDays\n\n        integer, parameter :: DAYS_PER_MONTH(12) = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n\n        i = index(arriveAlice, '-')\n        j = index(leaveAlice, '-')\n        k = index(arriveBob, '-')\n        l = index(leaveBob, '-')\n\n        m = 0\n        do while (m < 12)\n            if (i == 3 .and. j == 3) then\n                if (arriveAlice(1:2) == arriveBob(1:2)) then\n                    if (arriveAlice(4:5) <= arriveBob(4:5)) then\n                        if (leaveAlice(4:5) >= leaveBob(4:5)) then\n                            m = m + DAYS_PER_MONTH(m)\n                        end if\n                    end if\n                end if\n            else if (k == 3 .and. l == 3) then\n                if (arriveAlice(1:2) == arriveBob(1:2)) then\n                    if (arriveAlice(4:5) <= arriveBob(4:5)) then\n                        if (leaveAlice(4:5) >= leaveBob(4:5)) then\n                            m = m + DAYS_PER_MONTH(m)\n                        end if\n                    end if\n                end if\n            end if\n\n            i = i + 1\n            j = j + 1\n            k = k + 1\n            l = l + 1\n            m = m + 1\n        end do\n\n        numDays = m - 1\n\n    end function solve\n\nend program main",
  "2413": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer :: result\n\n    result = smallestMultiple(n)\n    print '(I0)', result\n\ncontains\n\n    function smallestMultiple(n) result(result_)\n        implicit none\n        integer, value :: n\n        integer :: result_\n\n        result_ = 2 * (n - 1) + 1\n    end function smallestMultiple\nend program main",
  "2418": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    character(len=20), dimension(n) :: names\n    integer, dimension(n) :: heights\n    integer :: i\n\n    ! Example 1\n    names = [\"Mary \", \"John \", \"Emma \"]\n    heights = [180, 165, 170]\n    call sort_by_height(names, heights)\n    write (*, \"(A)\") trim(names(1)) // \" \" // trim(names(2)) // \" \" // trim(names(3))\n\n    ! Example 2\n    names = [\"Alice \", \"Bob \", \"Bob \"]\n    heights = [155, 185, 150]\n    call sort_by_height(names, heights)\n    write (*, \"(A)\") trim(names(1)) // \" \" // trim(names(2)) // \" \" // trim(names(3))\n\ncontains\n\n    subroutine sort_by_height(names, heights)\n        implicit none\n        character(len=*), intent(inout) :: names(:)\n        integer, intent(inout) :: heights(:)\n        integer :: i, j\n\n        do i = 1, size(names)-1\n            do j = i+1, size(names)\n                if (heights(j) < heights(i)) then\n                    call swap(names(i), names(j))\n                    call swap(heights(i), heights(j))\n                end if\n            end do\n        end do\n    end subroutine sort_by_height\n\n    subroutine swap(a, b)\n        implicit none\n        character(len=*), intent(inout) :: a, b\n        character(len=len(a)) :: temp\n\n        temp = a\n        a = b\n        b = temp\n    end subroutine swap\n\nend program main",
  "2423": "program main\n    implicit none\n\n    integer :: i, j, k\n    logical :: result\n    character(len=100) :: word\n\n    ! Example 1\n    word = 'abcc'\n    result = solve(word)\n    if (result) then\n        print *, 'Example 1: ', word\n    else\n        print *, 'Example 1: ', 'FAIL'\n    end if\n\n    ! Example 2\n    word = 'aazz'\n    result = solve(word)\n    if (.not. result) then\n        print *, 'Example 2: ', word\n    else\n        print *, 'Example 2: ', 'FAIL'\n    end if\n\ncontains\n\n    function solve(word) result(result)\n        implicit none\n        character(len=*), intent(in) :: word\n        integer :: freq(26)\n        logical :: result\n\n        result = .false.\n\n        ! Count the frequency of each letter\n        do i = 1, len(word)\n            freq(ichar(word(i:i)) - ichar('a') + 1) = freq(ichar(word(i:i)) - ichar('a') + 1) + 1\n        end do\n\n        ! Check if there is any letter with frequency > 1\n        do i = 1, 26\n            if (freq(i) > 1) then\n                result = .true.\n                exit\n            end if\n        end do\n\n        ! If there is no letter with frequency > 1, check if there is any letter with frequency < 1\n        if (.not. result) then\n            do i = 1, 26\n                if (freq(i) < 1) then\n                    result = .true.\n                    exit\n                end if\n            end do\n        end if\n\n        ! Remove the letter with frequency > 1\n        if (result) then\n            do i = 1, len(word)\n                if (ichar(word(i:i)) - ichar('a') + 1 == maxval(freq)) then\n                    word(i:i) = ' '\n                    exit\n                end if\n            end do\n        end if\n\n        ! Remove the letter with frequency < 1\n        if (.not. result) then\n            do i = 1, len(word)\n                if (ichar(word(i:i)) - ichar('a') + 1 == minval(freq)) then\n                    word(i:i) = ' '\n                    exit\n                end if\n            end do\n        end if\n\n        ! Check if the frequency of every letter is equal\n        do i = 1, 26\n            if (freq(i) /= 1) then\n                result = .false.\n                exit\n            end if\n        end do\n\n    end function solve\n\nend program main",
  "2427": "program main\n    implicit none\n\n    integer :: a, b, n\n\n    a = 12\n    b = 6\n    print '(I0)', common_factors(a, b)\n\n    a = 25\n    b = 30\n    print '(I0)', common_factors(a, b)\n\ncontains\n\nfunction common_factors(a, b) result(n)\n    implicit none\n    integer, intent(in) :: a, b\n    integer :: i, n\n\n    n = 0\n    do i = 1, min(a, b)\n        if (mod(a, i) == 0 .and. mod(b, i) == 0) then\n            n = n + 1\n        end if\n    end do\nend function common_factors\n\nend program main",
  "2432": "program main\n    implicit none\n\n    integer :: n, i, j, id, leaveTime, maxLeaveTime, maxId\n    integer, allocatable :: logs(:, :)\n\n    ! read input\n    read(*, *) n\n    allocate(logs(n, 2))\n    do i = 1, n\n        read(*, *) logs(i, :)\n    end do\n\n    ! solve problem\n    maxLeaveTime = 0\n    maxId = 0\n    do i = 1, n\n        id = logs(i, 1)\n        leaveTime = logs(i, 2)\n        if (leaveTime > maxLeaveTime) then\n            maxLeaveTime = leaveTime\n            maxId = id\n        elseif (leaveTime == maxLeaveTime .and. id < maxId) then\n            maxId = id\n        end if\n    end do\n\n    ! print output\n    write (*, '(I0)') maxId\n\nend program main",
  "2437": "program main\n    implicit none\n\n    character(len=5) :: time\n    integer :: answer\n\n    time = \"?5:00 \"\n    call solve(time, answer)\n    print '(I0)', answer\n\n    time = \"0?:0? \"\n    call solve(time, answer)\n    print '(I0)', answer\n\n    time = \"??:?? \"\n    call solve(time, answer)\n    print '(I0)', answer\n\ncontains\n\n    subroutine solve(time, answer)\n        implicit none\n        character(len=*), intent(in) :: time\n        integer, intent(out) :: answer\n\n        integer :: i, j, k, l, m\n        logical :: valid\n\n        do i = 0, 9\n            do j = 0, 9\n                do k = 0, 9\n                    do l = 0, 9\n                        do m = 0, 9\n                            if (i == 0 .and. j == 0 .and. k == 0 .and. l == 0 .and. m == 0) then\n                                cycle\n                            end if\n\n                            valid = .true.\n\n                            if (time(1:1) == '?') then\n                                if (i < 0 .or. i > 9) then\n                                    valid = .false.\n                                end if\n                            else\n                                if (i /= int(time(1:1)) - 48) then\n                                    valid = .false.\n                                end if\n                            end if\n\n                            if (valid) then\n                                if (time(2:2) == '?') then\n                                    if (j < 0 .or. j > 9) then\n                                        valid = .false.\n                                    end if\n                                else\n                                    if (j /= int(time(2:2)) - 48) then\n                                        valid = .false.\n                                    end if\n                                end if\n                            end if\n\n                            if (valid) then\n                                if (time(3:3) == '?') then\n                                    if (k < 0 .or. k > 9) then\n                                        valid = .false.\n                                    end if\n                                else\n                                    if (k /= int(time(3:3)) - 48) then\n                                        valid = .false.\n                                    end if\n                                end if\n                            end if\n\n                            if (valid) then\n                                if (time(4:4) == '?') then\n                                    if (l < 0 .or. l > 9) then\n                                        valid = .false.\n                                    end if\n                                else\n                                    if (l /= int(time(4:4)) - 48) then\n                                        valid = .false.\n                                    end if\n                                end if\n                            end if\n\n                            if (valid) then\n                                if (time(5:5) == '?') then\n                                    if (m < 0 .or. m > 9) then\n                                        valid = .false.\n                                    end if\n                                else\n                                    if (m /= int(time(5:5)) - 48) then\n                                        valid = .false.\n                                    end if\n                                end if\n                            end if\n\n                            if (valid) then\n                                answer = answer + 1\n                            end if\n                        end do\n                    end do\n                end do\n            end do\n        end do\n    end subroutine solve\nend program main",
  "2441": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: nums\n    integer :: k\n\n    ! Example 1\n    nums = [-1, 2, -3, 3]\n    print '(I0)', solve(nums)\n\n    ! Example 2\n    nums = [-1, 10, 6, 7, -7, 1]\n    print '(I0)', solve(nums)\n\n    ! Example 3\n    nums = [-10, 8, 6, 7, -2, -3]\n    print '(I0)', solve(nums)\n\ncontains\n\n    function solve(nums) result(k)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer :: k\n        logical :: found\n\n        k = -1\n        found = .false.\n\n        do i = 1, size(nums)\n            if (nums(i) == -k) then\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (found) then\n            k = abs(k)\n        end if\n    end function solve\nend program main",
  "2446": "program main\n    implicit none\n\n    character(len=5), dimension(2) :: event1, event2\n    logical :: result\n\n    ! Example 1\n    event1 = [\"01:15 \", \"02:00 \"]\n    event2 = [\"02:00 \", \"03:00 \"]\n    write(*,*) 'Example 1:'\n    write(*,*) 'event1 = ', event1\n    write(*,*) 'event2 = ', event2\n    result = hasConflict(event1, event2)\n    write(*,*) 'Result: ', result\n\n    ! Example 2\n    event1 = [\"01:00 \", \"02:00 \"]\n    event2 = [\"01:20 \", \"03:00 \"]\n    write(*,*) 'Example 2:'\n    write(*,*) 'event1 = ', event1\n    write(*,*) 'event2 = ', event2\n    result = hasConflict(event1, event2)\n    write(*,*) 'Result: ', result\n\n    ! Example 3\n    event1 = [\"10:00 \", \"11:00 \"]\n    event2 = [\"14:00 \", \"15:00 \"]\n    write(*,*) 'Example 3:'\n    write(*,*) 'event1 = ', event1\n    write(*,*) 'event2 = ', event2\n    result = hasConflict(event1, event2)\n    write(*,*) 'Result: ', result\n\ncontains\n\n    function hasConflict(event1, event2) result(conflict)\n        implicit none\n        character(len=5), intent(in) :: event1(:), event2(:)\n        integer :: startTime1, endTime1, startTime2, endTime2\n        logical :: conflict\n\n        read(event1(1), fmt='(I2)') startTime1\n        read(event1(2), fmt='(I2)') endTime1\n        read(event2(1), fmt='(I2)') startTime2\n        read(event2(2), fmt='(I2)') endTime2\n\n        if (startTime1 < startTime2 .and. endTime1 >= startTime2) then\n            conflict = .true.\n        else if (startTime2 < startTime1 .and. endTime2 >= startTime1) then\n            conflict = .true.\n        else\n            conflict = .false.\n        end if\n\n    end function hasConflict\n\nend program main",
  "2451": "program main\n    implicit none\n\n    character(len=:), allocatable :: words(:)\n    integer :: n\n    integer :: i\n\n    words = [\"adc \", \"wzy \", \"abc \"]\n    n = len(words(1))\n\n    do i = 1, size(words)\n        print '(A)', solve(words(i))\n    end do\n\ncontains\n\n    function solve(word) result(diff_str)\n        implicit none\n        character(len=*), intent(in) :: word\n        integer :: diff(size(word)-1)\n        integer :: i\n        character(len=:), allocatable :: diff_str\n\n        diff = [(word(i+1:i+2) - word(i:i), i=1, size(word)-1)]\n\n        write (unit=diff_str, fmt='(*(I0, A))') diff\n    end function solve\nend program main",
  "2455": "program main\n    implicit none\n\n    integer, parameter :: dp = selected_real_kind(15, 307)\n\n    integer, dimension(:), allocatable :: nums\n    integer :: n, i, j, k, sum, avg\n\n    ! read input\n    read (*, *) n\n    allocate (nums(n))\n    do i = 1, n\n        read (*, *) nums(i)\n    end do\n\n    ! solve problem\n    sum = 0\n    do i = 1, n\n        if (mod(nums(i), 2) == 0 .and. mod(nums(i), 3) == 0) then\n            sum = sum + nums(i)\n        end if\n    end do\n    avg = sum / n\n\n    ! print output\n    write (*, '(I0)') avg\n\nend program main",
  "2460": "program main\n    implicit none\n\n    integer, parameter :: n = 6\n    integer, dimension(n) :: nums\n    integer :: i\n\n    ! Example 1\n    nums = [1, 2, 2, 1, 1, 0]\n    call solve(nums)\n    write (*, '(A)') 'Example 1:'\n    write (*, '(*(G0))') nums\n\n    ! Example 2\n    nums = [0, 1]\n    call solve(nums)\n    write (*, '(A)') 'Example 2:'\n    write (*, '(*(G0))') nums\n\ncontains\n\nsubroutine solve(nums)\n    implicit none\n    integer, dimension(:), intent(inout) :: nums\n    integer :: i\n\n    do i = 1, size(nums) - 1\n        if (nums(i) == nums(i + 1)) then\n            nums(i) = nums(i) * 2\n            nums(i + 1) = 0\n        end if\n    end do\n\n    nums = pack(nums, nums /= 0)\nend subroutine solve\n\nend program main",
  "2465": "program main\n    implicit none\n\n    integer :: i, j, k, n, m, min_idx, max_idx, avg\n    integer, dimension(100) :: nums\n    logical, dimension(100) :: used\n\n    ! read input\n    read *, n\n    do i = 1, n\n        read *, nums(i)\n    end do\n\n    ! solve problem\n    m = 0\n    do while (size(nums) > 0)\n        ! find minimum\n        min_idx = -1\n        do i = 1, size(nums)\n            if (min_idx == -1 .or. nums(i) < nums(min_idx)) then\n                min_idx = i\n            end if\n        end do\n        ! find maximum\n        max_idx = -1\n        do i = 1, size(nums)\n            if (max_idx == -1 .or. nums(i) > nums(max_idx)) then\n                max_idx = i\n            end if\n        end do\n        ! calculate average\n        avg = (nums(min_idx) + nums(max_idx)) / 2\n        ! remove minimum and maximum\n        used(min_idx) = .true.\n        used(max_idx) = .true.\n        nums(min_idx) = nums(size(nums))\n        nums(max_idx) = nums(size(nums))\n        nums(:) = nums(:) - 1\n        ! count unique averages\n        if (.not. any(used)) then\n            m = m + 1\n        else\n            do i = 1, size(used)\n                if (.not. used(i)) then\n                    exit\n                end if\n            end do\n            m = m + 1\n        end if\n    end do\n\n    ! print output\n    write (*, '(I0)') m\n\nend program main",
  "2469": "program main\n    implicit none\n\n    real(kind=4), parameter :: tolerance = 10e-5\n    real(kind=4) :: celsius\n    real(kind=4), dimension(2) :: ans\n\n    ! Example 1\n    celsius = 36.50\n    ans = solve_problem(celsius)\n    write(*,*) 'Example 1:'\n    write(*,'(A,F10.5,A,F10.5)') 'Celsius = ', celsius, &\n                                  '; Kelvin = ', ans(1), &\n                                  '; Fahrenheit = ', ans(2)\n\n    ! Example 2\n    celsius = 122.11\n    ans = solve_problem(celsius)\n    write(*,*) 'Example 2:'\n    write(*,'(A,F10.5,A,F10.5)') 'Celsius = ', celsius, &\n                                  '; Kelvin = ', ans(1), &\n                                  '; Fahrenheit = ', ans(2)\n\ncontains\n\n    function solve_problem(celsius) result(ans)\n        implicit none\n        real(kind=4), intent(in) :: celsius\n        real(kind=4), dimension(2) :: ans\n\n        ans(1) = celsius + 273.15\n        ans(2) = celsius * 1.80 + 32.00\n\n    end function solve_problem\n\nend program main",
  "2475": "program main\n\n! This program solves the problem described in the statement.\n! It runs with all provided examples and outputs to stdout.\n\nimplicit none\ninteger :: nums(5)\ninteger :: i, j, k\ninteger :: count\n\nnums = (/ 4, 4, 2, 4, 3 /)\ncount = count_triplets(nums)\nprint '(I0)', count\n\nnums = (/ 1, 1, 1, 1, 1 /)\ncount = count_triplets(nums)\nprint '(I0)', count\n\ncontains\n\nfunction count_triplets(nums) result(count)\nimplicit none\ninteger, intent(in) :: nums(:)\ninteger :: count\ninteger :: i, j, k\nlogical :: pairwise_distinct\n\ncount = 0\ndo i = 0, size(nums)-3\n    do j = i+1, size(nums)-2\n        do k = j+1, size(nums)-1\n            if (nums(i) /= nums(j) .and. &\n                nums(i) /= nums(k) .and. &\n                nums(j) /= nums(k)) then\n                count = count + 1\n            end if\n        end do\n    end do\nend do\n\nend function count_triplets\n\nend program main",
  "2481": "program main\n    implicit none\n\n    integer :: n\n\n    print '(A)', 'Enter the value of n:'\n    read *, n\n\n    print '(I0)', minCuts(n)\n\ncontains\n\n    function minCuts(n) result(cuts)\n        implicit none\n        integer, intent(in) :: n\n        integer :: cuts\n\n        if (n == 1) then\n            cuts = 0\n        else if (n == 2) then\n            cuts = 1\n        else\n            cuts = 2\n        end if\n    end function minCuts\nend program main",
  "2485": "program main\n    implicit none\n\n    integer :: n, x\n\n    n = 8\n    call solve(n, x)\n    print '(I0)', x\n\n    n = 1\n    call solve(n, x)\n    print '(I0)', x\n\n    n = 4\n    call solve(n, x)\n    print '(I0)', x\n\ncontains\n\n    subroutine solve(n, x)\n        implicit none\n        integer, intent(in) :: n\n        integer, intent(out) :: x\n\n        integer :: i, sum1, sum2\n\n        sum1 = 0\n        do i = 1, x\n            sum1 = sum1 + i\n        end do\n\n        sum2 = 0\n        do i = x+1, n\n            sum2 = sum2 + i\n        end do\n\n        if (sum1 == sum2) then\n            x = x\n        else\n            x = -1\n        end if\n\n    end subroutine solve\nend program main",
  "2490": "program main\n    implicit none\n\n    integer :: i\n    character(len=500) :: sentence\n\n    do i = 1, size(examples)\n        sentence = examples(i)\n        write(*,*) 'Sentence: ', trim(sentence), ' Circular: ', is_circular(sentence)\n    end do\n\ncontains\n\n    function is_circular(sentence) result(circular)\n        implicit none\n        character(len=*), intent(in) :: sentence\n        logical :: circular\n        integer :: nwords, iword\n        character(len=:), allocatable :: words(:)\n\n        ! Split the sentence into individual words\n        call split_string(sentence, words)\n        nwords = size(words)\n\n        ! Check if the last character of each word is equal to the first character of the next word\n        do iword = 1, nwords - 1\n            if (words(iword)(len_trim(words(iword))) /= words(iword+1)(1)) then\n                circular = .false.\n                return\n            end if\n        end do\n\n        ! Check if the last character of the last word is equal to the first character of the first word\n        if (words(nwords)(len_trim(words(nwords))) /= words(1)(1)) then\n            circular = .false.\n            return\n        end if\n\n        circular = .true.\n\n    end function is_circular\n\n    subroutine split_string(str, words)\n        implicit none\n        character(len=*), intent(in) :: str\n        character(len=:), allocatable, intent(out) :: words(:)\n        integer :: pos, nwords\n\n        nwords = count(str == ' ') + 1\n        allocate(words(nwords))\n\n        pos = 1\n        words(1) = ''\n        do while (pos < len(str))\n            if (str(pos:pos) == ' ') then\n                pos = pos + 1\n                cycle\n            end if\n            words(1) = trim(words(1)) // str(pos:pos)\n            pos = pos + 1\n        end do\n\n    end subroutine split_string\n\nend program main\n\ncharacter(len=500), parameter :: examples(3) = [\"Hello World \", &\n                                                 \"HELLO \", &\n                                                 \"hello world hello world \"]",
  "2496": "program main\n    implicit none\n\n    integer :: i, j, k, n, m\n    character(len=:), allocatable :: strs(:)\n    integer :: max_val\n\n    ! Example 1\n    n = 5\n    allocate(strs(n))\n    strs(1) = 'alic3 '\n    strs(2) = 'bob '\n    strs(3) = '3 '\n    strs(4) = '4 '\n    strs(5) = '00000 '\n    write(*,*) 'Example 1:'\n    do i = 1, n\n        write(*,'(A)') trim(strs(i)) // ': ' // str(i)\n    end do\n    max_val = max_value(strs)\n    write(*,*) 'Maximum value: ', max_val\n\n    ! Example 2\n    n = 4\n    allocate(strs(n))\n    strs(1) = '1 '\n    strs(2) = '01 '\n    strs(3) = '001 '\n    strs(4) = '0001 '\n    write(*,*) 'Example 2:'\n    do i = 1, n\n        write(*,'(A)') trim(strs(i)) // ': ' // str(i)\n    end do\n    max_val = max_value(strs)\n    write(*,*) 'Maximum value: ', max_val\n\ncontains\n\n    function str(i) result(res)\n        implicit none\n        integer, intent(in) :: i\n        character(len=:), allocatable :: res\n        if (is_digits(strs(i))) then\n            res = num_to_str(str_to_num(strs(i)), 10)\n        else\n            res = strs(i)\n        end if\n    end function str\n\n    pure function is_digits(str) result(res)\n        implicit none\n        character(len=*), intent(in) :: str\n        logical :: res\n        res = .true.\n        do i = 1, len(str)\n            if (.not. is_digit(str(i:i))) then\n                res = .false.\n                exit\n            end if\n        end do\n    end function is_digits\n\n    pure function is_digit(c) result(res)\n        implicit none\n        character, intent(in) :: c\n        logical :: res\n        res = c >= '0' .and. c <= '9'\n    end function is_digit\n\n    pure function str_to_num(str) result(res)\n        implicit none\n        character(len=*), intent(in) :: str\n        integer :: res\n        read(str, *) res\n    end function str_to_num\n\n    pure function num_to_str(num, base) result(res)\n        implicit none\n        integer, intent(in) :: num, base\n        character(len=:), allocatable :: res\n        character(len=:), allocatable :: tmp\n        integer :: i\n        if (base == 10) then\n            res = num_to_str_10(num)\n        else\n            allocate(character(len=log10(num)+1) :: tmp)\n            write(tmp, '(I0)') num\n            res = tmp\n        end if\n    end function num_to_str\n\n    pure function num_to_str_10(num) result(res)\n        implicit none\n        integer, intent(in) :: num\n        character(len=:), allocatable :: res\n        character(len=:), allocatable :: tmp\n        integer :: i\n        allocate(character(len=log10(num)+1) :: tmp)\n        write(tmp, '(I0)') num\n        res = tmp\n    end function num_to_str_10\n\n    pure function max_value(strs) result(res)\n        implicit none\n        character(len=*), intent(in) :: strs(:)\n        integer :: res\n        res = -huge(res)\n        do i = 1, size(strs)\n            if (str(i) > res) then\n                res = str(i)\n            end if\n        end do\n    end function max_",
  "2500": "program main\n    implicit none\n\n    integer, parameter :: m = 2, n = 3\n    integer, dimension(m, n) :: grid = reshape([1, 2, 4, 3, 3, 1], shape(grid))\n    integer :: i, j, max_val, ans\n\n    do while (any(grid /= 0))\n        max_val = -huge(max_val)\n        do i = 1, m\n            if (grid(i, :) > max_val) then\n                max_val = grid(i, :)\n            end if\n        end do\n        do i = 1, m\n            if (grid(i, :) == max_val) then\n                grid(i, :) = 0\n                exit\n            end if\n        end do\n        ans = ans + max_val\n    end do\n\n    print '(I0)', ans\n\nend program main",
  "2506": "program main\n    implicit none\n\n    integer :: n, i, j, count\n    character(len=100) :: words(100)\n\n    ! read input\n    read(*,*) n\n    do i = 1, n\n        read(*,'(A)') words(i)\n    end do\n\n    ! solve problem\n    count = 0\n    do i = 1, n - 1\n        do j = i + 1, n\n            if (similar(words(i), words(j))) then\n                count = count + 1\n            end if\n        end do\n    end do\n\n    ! print output\n    write(*,*) count\n\ncontains\n\n    logical function similar(str1, str2)\n        implicit none\n        character(len=*), intent(in) :: str1, str2\n        integer :: i\n\n        similar = .true.\n        do i = 1, len(str1)\n            if (index(str2, str1(i:i)) == 0) then\n                similar = .false.\n                exit\n            end if\n        end do\n    end function similar\n\nend program main",
  "2511": "program main\n    implicit none\n\n    integer, parameter :: n = 9\n    integer, dimension(n) :: forts\n    integer :: i, j, k, max_enemies\n\n    ! Example 1\n    forts = [-1, 0, 0, -1, 0, 0, 0, 0, 1]\n    write(*,*) \"Example 1\"\n    write(*,*) \"Forts:\", forts\n    call solve(forts, i, j, k, max_enemies)\n    write(*,*) \"Max enemies:\", max_enemies\n\n    ! Example 2\n    forts = [0, 0, 1, -1]\n    write(*,*) \"Example 2\"\n    write(*,*) \"Forts:\", forts\n    call solve(forts, i, j, k, max_enemies)\n    write(*,*) \"Max enemies:\", max_enemies\n\ncontains\n\n    subroutine solve(forts, i, j, k, max_enemies)\n        implicit none\n        integer, intent(in) :: forts(:)\n        integer, intent(out) :: i, j, k, max_enemies\n        logical :: found_empty\n\n        ! Initialize variables\n        i = 0\n        j = 0\n        k = 0\n        max_enemies = 0\n        found_empty = .false.\n\n        ! Loop through the forts\n        do while (i /= n)\n            if (forts(i) == 0) then\n                ! Enemy fort found\n                max_enemies = max(max_enemies, k - i + 1)\n            else if (forts(i) == 1) then\n                ! Your fort found\n                if (.not. found_empty) then\n                    ! Found an empty position\n                    j = i\n                    found_empty = .true.\n                end if\n            end if\n\n            ! Move to next fort\n            i = i + 1\n        end do\n\n        ! Check if we found an empty position\n        if (found_empty) then\n            ! Move the army\n            do while (i /= j)\n                if (forts(i) == 0) then\n                    ! Enemy fort found\n                    max_enemies = max(max_enemies, k - i + 1)\n                end if\n\n                ! Move to next fort\n                i = i + 1\n            end do\n        end if\n    end subroutine solve\nend program main",
  "2515": "program main\n    implicit none\n\n    integer :: i, j, k, l, m, n\n    character(len=100), dimension(:), allocatable :: words\n    character(len=100) :: target\n    integer :: startIndex\n    integer :: result\n\n    ! Examples\n    allocate(words(5))\n    words(1) = 'hello '\n    words(2) = 'i '\n    words(3) = 'am '\n    words(4) = 'leetcode '\n    words(5) = 'hello '\n    target = 'hello '\n    startIndex = 1\n    result = shortestDistance(words, target, startIndex)\n    write(*,*) 'Example 1:'\n    write(*,*) 'words = ', words\n    write(*,*) 'target = ', target\n    write(*,*) 'startIndex = ', startIndex\n    write(*,*) 'result = ', result\n\n    deallocate(words)\n\n    allocate(words(3))\n    words(1) = 'a '\n    words(2) = 'b '\n    words(3) = 'leetcode '\n    target = 'leetcode '\n    startIndex = 0\n    result = shortestDistance(words, target, startIndex)\n    write(*,*) 'Example 2:'\n    write(*,*) 'words = ', words\n    write(*,*) 'target = ', target\n    write(*,*) 'startIndex = ', startIndex\n    write(*,*) 'result = ', result\n\n    deallocate(words)\n\n    allocate(words(3))\n    words(1) = 'i '\n    words(2) = 'eat '\n    words(3) = 'leetcode '\n    target = 'ate '\n    startIndex = 0\n    result = shortestDistance(words, target, startIndex)\n    write(*,*) 'Example 3:'\n    write(*,*) 'words = ', words\n    write(*,*) 'target = ', target\n    write(*,*) 'startIndex = ', startIndex\n    write(*,*) 'result = ', result\n\ncontains\n\n    function shortestDistance(words, target, startIndex) result(res)\n        implicit none\n        character(len=*), dimension(:), intent(in) :: words\n        character(len=*), intent(in) :: target\n        integer, intent(in) :: startIndex\n        integer :: res\n\n        integer :: i, j, k, l, m, n\n        logical :: found\n\n        res = -1\n        found = .false.\n        do i = 1, size(words)\n            if (words(i) == target) then\n                found = .true.\n                exit\n            end if\n        end do\n\n        if (.not. found) return\n\n        res = 0\n        do while (.true.)\n            if (words(startIndex) == target) then\n                exit\n            end if\n\n            if (startIndex == 0) then\n                startIndex = size(words)\n            else\n                startIndex = startIndex - 1\n            end if\n\n            res = res + 1\n        end do\n\n    end function shortestDistance\n\nend program main",
  "2520": "program main\n    ! Solves the problem: Given an integer `num`, return the number of digits in `num` that divide `num`.\n    implicit none\n\n    integer :: num, i, j, count\n    character(len=10) :: str\n\n    ! Examples\n    num = 7\n    call solve(num)\n    write (*,*) \"Example 1:\"\n    write (*,*) \"Input:\", num\n    write (*,*) \"Output:\", count\n    write (*,*) \"\"\n\n    num = 121\n    call solve(num)\n    write (*,*) \"Example 2:\"\n    write (*,*) \"Input:\", num\n    write (*,*) \"Output:\", count\n    write (*,*) \"\"\n\n    num = 1248\n    call solve(num)\n    write (*,*) \"Example 3:\"\n    write (*,*) \"Input:\", num\n    write (*,*) \"Output:\", count\n    write (*,*) \"\"\n\ncontains\n\n    subroutine solve(num)\n        implicit none\n        integer, intent(in) :: num\n        integer :: i, j\n        character(len=10) :: str\n\n        ! Convert `num` to string\n        write (str, '(I10)') num\n\n        ! Count the number of digits that divide `num`\n        count = 0\n        do i = len(str), 1, -1\n            do j = 1, i-1\n                if (str(j:i) == str(i:)) then\n                    count = count + 1\n                    exit\n                end if\n            end do\n        end do\n    end subroutine solve\nend program main",
  "2525": "program main\n\n! This program solves the following problem:\n!\n! Given four integers length, width, height, and mass, representing the dimensions and mass of a box, respectively,\n! return a string representing the category of the box.\n!\n! The box is \"Bulky \" if:\n!     Any of the dimensions of the box is greater or equal to 104.\n!     Or, the volume of the box is greater or equal to 109.\n! If the mass of the box is greater or equal to 100, it is \"Heavy \".\n! If the box is both \"Bulky \" and \"Heavy \", then its category is \"Both \".\n! If the box is neither \"Bulky \" nor \"Heavy \", then its category is \"Neither \".\n! If the box is \"Bulky \" but not \"Heavy \", then its category is \"Bulky \".\n! If the box is \"Heavy \" but not \"Bulky \", then its category is \"Heavy \".\n!\n! Note that the volume of the box is the product of its length, width and height.\n!\n! Examples:\n!\n! Input: length = 1000, width = 35, height = 700, mass = 300\n! Output: \"Heavy \"\n!\n! Input: length = 200, width = 50, height = 800, mass = 50\n! Output: \"Neither \"\n!\n! Constraints:\n!     1 <= length, width, height <= 105\n!     1 <= mass <= 103\n\nimplicit none\n\ninteger :: length, width, height, mass\ncharacter(len=10) :: category\n\nprint '(\"Enter length, width, height, and mass: \")', &\n        '(A, I0, A, I0, A, I0, A, I0)', &\n        'length = ', length, ', ', &\n        'width = ', width, ', ', &\n        'height = ', height, ', ', &\n        'mass = ', mass\n\ncall get_category(length, width, height, mass, category)\n\nprint '(\"The category of the box is: \", A)', category\n\ncontains\n\nsubroutine get_category(length, width, height, mass, category)\n    implicit none\n    integer, intent(in) :: length, width, height, mass\n    character(len=10), intent(out) :: category\n\n    ! Bulky boxes have any dimension greater or equal to 104 or volume greater or equal to 109\n    if (any(shape=",
  "2529": "program max_positive_negative\n    implicit none\n\n    integer :: i, j, k, n\n    integer, parameter :: nums(4) = [-2, -1, -1, 1, 2, 3]\n    integer, parameter :: nums2(6) = [-3, -2, -1, 0, 0, 1, 2]\n    integer, parameter :: nums3(4) = [5, 20, 66, 1314]\n    integer :: pos, neg\n\n    write(*,*) \"Example 1:\"\n    call get_max_pos_neg(nums, pos, neg)\n    write(*,*) \"Positive: \", pos, \"Negative: \", neg, \"Max: \", max(pos, neg)\n\n    write(*,*) \"Example 2:\"\n    call get_max_pos_neg(nums2, pos, neg)\n    write(*,*) \"Positive: \", pos, \"Negative: \", neg, \"Max: \", max(pos, neg)\n\n    write(*,*) \"Example 3:\"\n    call get_max_pos_neg(nums3, pos, neg)\n    write(*,*) \"Positive: \", pos, \"Negative: \", neg, \"Max: \", max(pos, neg)\n\ncontains\n\n    subroutine get_max_pos_neg(nums, pos, neg)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer, intent(out) :: pos, neg\n        integer :: i\n\n        pos = 0\n        neg = 0\n\n        do i = 1, size(nums)\n            if (nums(i) > 0) then\n                pos = pos + 1\n            else if (nums(i) < 0) then\n                neg = neg + 1\n            end if\n        end do\n\n        write(*,*) \"Positive: \", pos, \"Negative: \", neg, \"Max: \", max(pos, neg)\n\n    end subroutine get_max_pos_neg\n\nend program max_positive_negative",
  "2535": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums\n    integer :: i\n\n    ! Examples\n    nums = reshape([1, 15, 6, 3], shape(nums))\n    write(*,*) 'Example 1:'\n    write(*,*) 'Input:', nums\n    write(*,*) 'Output:', abs(sum(nums) - digitSum(nums))\n\n    nums = reshape([1, 2, 3, 4], shape(nums))\n    write(*,*) 'Example 2:'\n    write(*,*) 'Input:', nums\n    write(*,*) 'Output:', abs(sum(nums) - digitSum(nums))\n\ncontains\n\n    function digitSum(arr) result(res)\n        implicit none\n        integer, intent(in) :: arr(:)\n        integer :: res\n        integer :: i, j\n\n        res = 0\n        do i = 1, size(arr)\n            do j = 1, len_trim(str(arr(i)))\n                res = res + ichar(str(arr(i))(j:j)) - ichar('0')\n            end do\n        end do\n    end function digitSum\n\nend program main",
  "2540": "program min_integer_common\n    implicit none\n\n    integer, parameter :: n1 = 3, n2 = 4\n    integer, dimension(n1) :: nums1 = [1, 2, 3]\n    integer, dimension(n2) :: nums2 = [2, 4]\n    integer :: i, j, k, l, m, n, result\n\n    ! Example 1\n    write (*, '(A, I0)') 'Example 1: ', min_integer_common(nums1, nums2)\n\n    ! Example 2\n    nums1 = [1, 2, 3, 6]\n    nums2 = [2, 3, 4, 5]\n    write (*, '(A, I0)') 'Example 2: ', min_integer_common(nums1, nums2)\n\ncontains\n\n    function min_integer_common(nums1, nums2) result(result)\n        implicit none\n        integer, intent(in) :: nums1(:), nums2(:)\n        integer :: result\n        logical :: found\n\n        result = -1\n        do i = 1, size(nums1)\n            found = .false.\n            do j = 1, size(nums2)\n                if (nums1(i) == nums2(j)) then\n                    found = .true.\n                    exit\n                end if\n            end do\n            if (found) then\n                result = max(result, nums1(i))\n            end if\n        end do\n    end function min_integer_common\n\nend program min_integer_common",
  "2544": "program main\n    implicit none\n\n    integer, parameter :: n = 521\n    integer :: i, j, k, l, m, n_digits\n    character(len=1) :: digit\n    logical :: negative\n\n    ! Count the number of digits in n\n    n_digits = 0\n    do while (n /= 0)\n        n_digits = n_digits + 1\n        n = n / 10\n    end do\n\n    ! Print the sum of all digits with their corresponding sign\n    write (*, '(A)') 'Sum of all digits with their corresponding sign:'\n    do i = 1, n_digits\n        ! Get the next digit from n\n        digit = char(ichar('0') + mod(n, 10))\n        n = n / 10\n\n        ! Determine the sign of the current digit\n        if (i == 1) then\n            ! Most significant digit is always positive\n            negative = .false.\n        else\n            ! Other digits have opposite signs as their adjacent digits\n            negative = (mod(i, 2) == 0)\n        end if\n\n        ! Print the digit with its sign\n        if (negative) then\n            write (*, '(A)', advance='no') '-'\n        else\n            write (*, '(A)', advance='no') '+'\n        end if\n        write (*, '(A)', advance='no') digit\n    end do\n    write (*, *)\n\nend program main",
  "2549": "program main\n    implicit none\n\n    integer :: n, x, i, num_distinct\n\n    ! read input\n    read(*,*) n\n\n    ! initialize board\n    call init_board(n)\n\n    ! perform procedure every day\n    do i = 1, 109\n        call perform_procedure()\n    end do\n\n    ! count distinct numbers on board\n    num_distinct = count_distinct()\n\n    ! print result\n    write(*,'(I0)') num_distinct\n\ncontains\n\n    subroutine init_board(n)\n        implicit none\n        integer, intent(in) :: n\n        integer :: x\n\n        do x = 1, n\n            if (mod(x, n) == 0) then\n                call add_to_board(x)\n            end if\n        end do\n    end subroutine init_board\n\n    subroutine perform_procedure()\n        implicit none\n        integer :: x, i\n\n        do x = 1, size(board)\n            do i = 1, n\n                if (mod(x, i) == 1) then\n                    call add_to_board(i)\n                end if\n            end do\n        end do\n    end subroutine perform_procedure\n\n    function count_distinct() result(num_distinct)\n        implicit none\n        integer :: num_distinct\n\n        num_distinct = size(unique(board))\n    end function count_distinct\n\n    subroutine add_to_board(x)\n        implicit none\n        integer, intent(in) :: x\n\n        if (.not. any(board == x)) then\n            board = [board, x]\n        end if\n    end subroutine add_to_board\n\nend program main",
  "2553": "program main\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums = (/ 13, 25, 83, 77 /)\n    integer, dimension(n) :: answer\n    integer :: i\n\n    call solve(nums, answer)\n\n    do i = 1, n\n        write (*, '(I0)') answer(i)\n    end do\n\ncontains\n\n    subroutine solve(nums, answer)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer, intent(out) :: answer(:)\n\n        integer :: i, j, k\n\n        do i = 1, size(nums)\n            k = 1\n            do while (k <= len(nums(i)))\n                j = index(nums(i), '0', back=.true.)\n                if (j == 0) then\n                    exit\n                end if\n                answer(i) = ichar(nums(i)(j:j)) - ichar('0') + 1\n                nums(i) = nums(i)(1:j-1) // nums(i)(j+1:)\n                k = k + 1\n            end do\n        end do\n\n    end subroutine solve\n\nend program main",
  "2558": "program main\n    implicit none\n\n    integer, parameter :: n = 5\n    integer, dimension(n) :: gifts\n    integer :: k\n    integer :: i\n\n    gifts = [25, 64, 9, 4, 100]\n    k = 4\n    call solve(gifts, k)\n\n    gifts = [1, 1, 1, 1]\n    k = 4\n    call solve(gifts, k)\n\ncontains\n\nsubroutine solve(gifts, k)\n    implicit none\n    integer, intent(inout) :: gifts(:)\n    integer, intent(in) :: k\n    integer :: max_gifts\n    integer :: i\n\n    do i = 1, k\n        max_gifts = maxval(gifts)\n        where (gifts == max_gifts)\n            gifts = gifts - floor(sqrt(real(max_gifts)))\n        end where\n    end do\n\n    print '(I0)', sum(gifts)\nend subroutine solve\n\nend program main",
  "2562": "program concatenation_of_numbers\n    implicit none\n\n    integer :: i, j, n, nums(1000), concat_val\n\n    ! read input\n    read(*,*) n\n    do i = 1, n\n        read(*,*) nums(i)\n    end do\n\n    ! solve problem\n    concat_val = 0\n    do while (n > 0)\n        if (n >= 2) then\n            ! concatenate first and last elements\n            concat_val = concat_val + concatenate(nums(1), nums(n))\n            ! remove first and last elements\n            nums(1:n-1) = nums(2:n)\n            n = n - 1\n        else\n            ! concatenate single element\n            concat_val = concat_val + nums(1)\n            ! remove single element\n            nums(1:n-1) = nums(2:n)\n            n = n - 1\n        end if\n    end do\n\n    ! print result\n    write(*,*) concat_val\n\ncontains\n\nfunction concatenate(a, b) result(concat)\n    implicit none\n\n    integer, intent(in) :: a, b\n    integer :: concat\n\n    concat = a * 10 + b\nend function concatenate\n\nend program concatenation_of_numbers",
  "2566": "program main\n    implicit none\n\n    integer :: num\n    integer :: result\n\n    num = 11891\n    result = maxMinDiff(num)\n    print '(I0)', result\n\n    num = 90\n    result = maxMinDiff(num)\n    print '(I0)', result\n\ncontains\n\nfunction maxMinDiff(num) result(diff)\n    implicit none\n    integer, intent(in) :: num\n    integer :: diff\n    integer :: i, j, k\n\n    do i = 0, 9\n        do j = 0, 9\n            if (i /= j) then\n                k = num\n                call replaceDigit(k, i, j)\n                if (k > diff) then\n                    diff = k\n                end if\n            end if\n        end do\n    end do\nend function maxMinDiff\n\nsubroutine replaceDigit(num, oldDigit, newDigit)\n    implicit none\n    integer, intent(inout) :: num\n    integer, intent(in) :: oldDigit, newDigit\n    integer :: digit\n\n    digit = mod(num, 10)\n    if (digit == oldDigit) then\n        num = num / 10\n        num = num * 10 + newDigit\n    else\n        num = num / 10\n        num = num * 10 + digit\n    end if\nend subroutine replaceDigit\n\nend program main",
  "2570": "program main\n    implicit none\n\n    integer, parameter :: n = 3\n    integer, dimension(n) :: nums1 = reshape([1, 2, 4], shape(nums1))\n    integer, dimension(n) :: nums2 = reshape([1, 3, 4], shape(nums2))\n    integer, dimension(:), allocatable :: result\n\n    allocate(result(size(nums1) + size(nums2)))\n\n    call merge_sorted_arrays(nums1, nums2, result)\n\n    write(*,*) 'Result: ', result\n\ncontains\n\nsubroutine merge_sorted_arrays(nums1, nums2, result)\n    implicit none\n    integer, dimension(:, :), intent(in) :: nums1\n    integer, dimension(:, :), intent(in) :: nums2\n    integer, dimension(:), intent(out) :: result\n\n    integer :: i, j, k\n\n    i = 1\n    j = 1\n    k = 1\n\n    do while (i <= ubound(nums1, dim=1) .and. j <= ubound(nums2, dim=1))\n        if (nums1(i, 1) < nums2(j, 1)) then\n            result(k) = nums1(i, 1)\n            result(k+1) = nums1(i, 2)\n            i = i + 1\n        else if (nums1(i, 1) > nums2(j, 1)) then\n            result(k) = nums2(j, 1)\n            result(k+1) = nums2(j, 2)\n            j = j + 1\n        else\n            result(k) = nums1(i, 1)\n            result(k+1) = nums1(i, 2) + nums2(j, 2)\n            i = i + 1\n            j = j + 1\n        end if\n        k = k + 2\n    end do\n\n    do while (i <= ubound(nums1, dim=1))\n        result(k) = nums1(i, 1)\n        result(k+1) = nums1(i, 2)\n        i = i + 1\n        k = k + 2\n    end do\n\n    do while (j <= ubound(nums2, dim=1))\n        result(k) = nums2(j, 1)\n        result(k+1) = nums2(j, 2)\n        j = j + 1\n        k = k + 2\n    end do\nend subroutine merge_sorted_arrays\n\nend program main",
  "2574": "program main\n    ! Solve the problem described in the task\n    implicit none\n\n    integer, parameter :: n = 4\n    integer, dimension(n) :: nums = (/ 10, 4, 8, 3 /)\n    integer, dimension(n) :: answer\n    integer, dimension(n) :: leftSum, rightSum\n\n    call solve(nums, answer, leftSum, rightSum)\n\n    write (*, '(A)') 'Answer:'\n    write (*, '(*(I0, 1X))') answer\n\ncontains\n\n    subroutine solve(nums, answer, leftSum, rightSum)\n        implicit none\n        integer, intent(in) :: nums(:)\n        integer, intent(out) :: answer(:), leftSum(:), rightSum(:)\n\n        leftSum = 0\n        do i = 1, size(nums)\n            leftSum(i) = sum(nums(1:i))\n        end do\n\n        rightSum = 0\n        do i = size(nums), 1, -1\n            rightSum(i) = sum(nums(i+1:size(nums)))\n        end do\n\n        answer = abs(leftSum - rightSum)\n    end subroutine solve\nend program main",
  "2578": "program main\n    implicit none\n\n    integer :: num, num1, num2, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n    character(len=10) :: str\n\n    ! Examples\n    num = 4325\n    call solve(num, num1, num2)\n    write (*, '(A, I0, A, I0)') 'Minimum sum: ', num1 + num2, ' (', num1, ', ', num2, ')'\n\n    num = 687\n    call solve(num, num1, num2)\n    write (*, '(A, I0, A, I0)') 'Minimum sum: ', num1 + num2, ' (', num1, ', ', num2, ')'\n\ncontains\n\n    subroutine solve(num, num1, num2)\n        implicit none\n        integer, intent(in) :: num\n        integer, intent(out) :: num1, num2\n        integer :: count(10), perm(10), tmp(10)\n\n        ! Initialize counts for each digit\n        do i = 1, 10\n            count(i) = 0\n        end do\n\n        ! Count the number of occurrences of each digit in num\n        do i = 1, len_trim(str(num))\n            count(ichar(str(num)(i:i))) = count(ichar(str(num)(i:i))) + 1\n        end do\n\n        ! Generate a permutation of the digits\n        perm(:) = (/ (j, j=1,10) /)\n        call shuffle(perm)\n\n        ! Find the first digit that has a count greater than its position in the permutation\n        do i = 1, 10\n            if (count(perm(i)) > i) then\n                exit\n            end if\n        end do\n\n        ! If no such digit exists, return 0\n        if (i == 11) then\n            num1 = 0\n            num2 = 0\n            return\n        end if\n\n        ! Set num1 to the first digit\n        num1 = perm(i)\n\n        ! Remove the first digit from the count array\n        count(perm(i)) = 0\n\n        ! Find the next digit that has a count greater than its position in the permutation\n        do j = i + 1, 10\n            if (count(perm(j)) > j) then\n                exit\n            end if\n        end do\n\n        ! If no such digit exists, return 0\n        if (j == 11) then\n            num1 = 0\n            num2 = 0\n            return\n        end if\n\n        ! Set num2 to the second digit\n        num2 = perm(j)\n\n        ! Remove the second digit from the count array\n        count(perm(j)) = 0\n\n        ! Find the third digit that has a count greater than its position in the permutation\n        do k = j + 1, 10\n            if (count(perm(k)) > k) then\n                exit\n            end if\n        end do\n\n        ! If no such digit exists, return 0\n        if (k == 11) then\n            num1 = 0\n            num2 = 0\n            return\n        end if\n\n        ! Set num3 to the third digit\n        num3 = perm(k)\n\n        ! Remove the third digit from the count array\n        count(perm(k)) = 0\n\n        ! Find the fourth digit that has a count greater than its position in the permutation\n        do l = k + 1, 10\n            if (count(perm(l)) > l) then\n                exit\n            end if\n        end do\n\n        ! If no such digit exists, return 0\n        if (l == 11) then\n            num1 = 0\n            num2 = 0\n            return\n        end if\n\n        ! Set num4 to the fourth digit\n        num4 = perm(l)\n\n        ! Remove the fourth digit from the count array\n        count(perm(l)) = 0\n\n        ! Find the fifth digit that has a count greater than its position in the permutation\n        do m = l + 1, 10\n            if",
  "2582": "program main\n    implicit none\n\n    integer :: n, time, i, j\n\n    do i = 1, size(examples)\n        read (unit=examples(i), fmt='(I2, I2)') n, time\n        write (*, '(A, I2, A, I2)') 'Example ', i, ': ', solve(n, time)\n    end do\n\ncontains\n\n    function solve(n, time) result(index)\n        implicit none\n\n        integer, intent(in) :: n, time\n        integer :: index\n\n        if (mod(time, 2) == 0) then\n            ! Passing pillow in one direction\n            index = mod((time + 1)/2, n) + 1\n        else\n            ! Passing pillow in opposite direction\n            index = mod(n - (time + 1)/2, n) + 1\n        end if\n\n    end function solve\n\nend program main\n\n! Examples\ninteger, parameter :: examples(2, 2) = reshape([ &\n    4, 5, &\n    3, 2], shape(examples))",
  "2586": "program main\n    implicit none\n\n    integer :: i, j, n\n    character(len=10) :: words(1000)\n    logical :: vowel\n\n    ! read input\n    read(*,*) n\n    do i = 1, n\n        read(*,*) words(i)\n    end do\n    read(*,*) i, j\n\n    ! solve problem\n    vowel = .false.\n    do while (i <= j)\n        if (words(i)(1:1) == 'a' .or. &\n            words(i)(1:1) == 'e' .or. &\n            words(i)(1:1) == 'i' .or. &\n            words(i)(1:1) == 'o' .or. &\n            words(i)(1:1) == 'u') then\n            vowel = .true.\n        else\n            vowel = .false.\n            exit\n        end if\n        if (words(i)(len_trim(words(i)):len_trim(words(i))) == &\n            words(i)(1:1)) then\n            vowel = .true.\n        else\n            vowel = .false.\n            exit\n        end if\n        i = i + 1\n    end do\n\n    ! print output\n    write(*,*) vowel\n\nend program main",
  "2591": "program main\n    implicit none\n\n    integer :: money, children, result\n\n    money = 20\n    children = 3\n    result = solve(money, children)\n    write (*, '(A, I0)') 'Result: ', result\n\n    money = 16\n    children = 2\n    result = solve(money, children)\n    write (*, '(A, I0)') 'Result: ', result\n\ncontains\n\n    function solve(money, children) result(result)\n        implicit none\n        integer, value :: money, children\n        integer :: i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n        integer :: result\n\n        ! This solution uses a brute force approach to find the maximum number of children\n        ! who may receive exactly 8 dollars if we distribute the money according to the\n        ! aforementioned rules.\n        !\n        ! We start by considering all possible combinations of children who may receive 8 dollars.\n        ! For each combination, we check whether it satisfies the rules. If it does, we increment\n        ! the result variable.\n        !\n        ! The time complexity of this solution is O(n^2), where n is the number of children.\n        ! The space complexity is O(1).\n\n        result = -1\n\n        do i = 1, children\n            do j = 1, children\n                if (i + j == 8) then\n                    if (i /= 1 .and. j /= 1) then\n                        result = max(result, i + j)\n                    end if\n                end if\n            end do\n        end do\n\n        do i = 1, children\n            do j = 1, children\n                do k = 1, children\n                    if (i + j + k == 8) then\n                        if (i /= 1 .and. j /= 1 .and. k /= 1) then\n                            result = max(result, i + j + k)\n                        end if\n                    end if\n                end do\n            end do\n        end do\n\n        do i = 1, children\n            do j = 1, children\n                do k = 1, children\n                    do l = 1, children\n                        if (i + j + k + l == 8) then\n                            if (i /= 1 .and. j /= 1 .and. k /= 1 .and. l /= 1) then\n                                result = max(result, i + j + k + l)\n                            end if\n                        end if\n                    end do\n                end do\n            end do\n        end do\n\n        do i = 1, children\n            do j = 1, children\n                do k = 1, children\n                    do l = 1, children\n                        do m = 1, children\n                            if (i + j + k + l + m == 8) then\n                                if (i /= 1 .and. j /= 1 .and. k /= 1 .and. l /= 1 .and. m /= 1) then\n                                    result = max(result, i + j + k + l + m)\n                                end if\n                            end if\n                        end do\n                    end do\n                end do\n            end do\n        end do\n\n        do i = 1, children\n            do j = 1, children\n                do k = 1, children\n                    do l = 1, children\n                        do m = 1, children\n                            do n = 1, children\n                                if (i + j + k + l + m + n == 8) then\n                                    if (i /= 1 .and. j /= 1 .and. k /= 1 .and. l /= 1 .and. m /= 1 .and. n /= 1) then\n                                        result = max(result, i + j + k + l + m + n)\n                                    end if\n                                end if\n                            end do\n                        end do\n                    end do\n                end do\n            end do\n        end do\n\n        do i = 1, children\n            do j = 1, children\n                do k = 1",
  "2595": "program main\n    implicit none\n\n    integer, parameter :: n = 17\n    integer :: answer(2)\n\n    call solve(n, answer)\n\n    write (*, '(A, I0, A, I0)') 'Answer: ', answer(1), ',', answer(2)\n\ncontains\n\nsubroutine solve(n, answer)\n    implicit none\n    integer, intent(in) :: n\n    integer, intent(out) :: answer(:)\n\n    integer :: i, j, k, l, m, n_bits\n    logical :: found\n\n    n_bits = floor(log(real(n)) / log(2.0)) + 1\n\n    do i = 1, n_bits\n        if (mod(i, 2) == 0) then\n            ! Even index\n            found = .false.\n            do j = 1, n_bits\n                if (mod(j, 2) == 0) then\n                    ! Even bit\n                    if (mod(n, 2) == 1) then\n                        ! Bit is set\n                        found = .true.\n                        exit\n                    end if\n                else\n                    ! Odd bit\n                    if (mod(n, 2) == 0) then\n                        ! Bit is set\n                        found = .true.\n                        exit\n                    end if\n                end if\n            end do\n            if (found) then\n                answer(1) = answer(1) + 1\n            end if\n        else\n            ! Odd index\n            found = .false.\n            do j = 1, n_bits\n                if (mod(j, 2) == 0) then\n                    ! Even bit\n                    if (mod(n, 2) == 1) then\n                        ! Bit is set\n                        found = .true.\n                        exit\n                    end if\n                else\n                    ! Odd bit\n                    if (mod(n, 2) == 0) then\n                        ! Bit is set\n                        found = .true.\n                        exit\n                    end if\n                end if\n            end do\n            if (found) then\n                answer(2) = answer(2) + 1\n            end if\n        end if\n    end do\nend subroutine solve\n\nend program main",
  "2600": "program main\n    implicit none\n\n    integer :: numOnes, numZeros, numNegOnes, k, maxSum\n\n    ! Example 1\n    numOnes = 3\n    numZeros = 2\n    numNegOnes = 0\n    k = 2\n    call solve(numOnes, numZeros, numNegOnes, k)\n\n    ! Example 2\n    numOnes = 3\n    numZeros = 2\n    numNegOnes = 0\n    k = 4\n    call solve(numOnes, numZeros, numNegOnes, k)\n\ncontains\n\nsubroutine solve(numOnes, numZeros, numNegOnes, k)\n    implicit none\n    integer, intent(in) :: numOnes, numZeros, numNegOnes, k\n    integer :: i, j, sum\n\n    do i = 1, numOnes\n        do j = 1, numZeros\n            sum = i + j\n            if (sum == k) then\n                write (*, '(A, I0, A, I0, A, I0, A, I0, A)') &\n                    \"The maximum possible sum is \", i, \" + \", j, \" + \", numNegOnes, \" = \", sum\n                return\n            end if\n        end do\n    end do\n\n    do i = 1, numOnes\n        do j = 1, numZeros\n            sum = i + j + numNegOnes\n            if (sum == k) then\n                write (*, '(A, I0, A, I0, A, I0, A, I0, A)') &\n                    \"The maximum possible sum is \", i, \" + \", j, \" + \", numNegOnes, \" = \", sum\n                return\n            end if\n        end do\n    end do\n\n    do i = 1, numOnes\n        sum = i + numNegOnes\n        if (sum == k) then\n            write (*, '(A, I0, A, I0, A, I0, A, I0, A)') &\n                \"The maximum possible sum is \", i, \" + \", numNegOnes, \" = \", sum\n            return\n        end if\n    end do\n\n    do i = 1, numZeros\n        sum = i + numNegOnes\n        if (sum == k) then\n            write (*, '(A, I0, A, I0, A, I0, A, I0, A)') &\n                \"The maximum possible sum is \", i, \" + \", numNegOnes, \" = \", sum\n            return\n        end if\n    end do\n\n    write (*, '(A)') \"No solution found.\"\nend subroutine solve\n\nend program main",
  "2605": "program main\n    implicit none\n\n    integer, parameter :: n = 9\n    integer, dimension(n) :: nums1 = [4, 1, 3], nums2 = [5, 7]\n    integer :: i, j, k, l, m, n1, n2, min_num\n\n    ! solve the problem\n    min_num = solve(nums1, nums2)\n\n    ! print the result\n    write (*, '(A, I0)') 'The smallest number containing at least one digit from each array is: ', min_num\n\ncontains\n\n    function solve(nums1, nums2) result(min_num)\n        implicit none\n        integer, intent(in) :: nums1(:), nums2(:)\n        integer :: i, j, k, l, m, n1, n2, min_num\n\n        ! initialize variables\n        n1 = size(nums1)\n        n2 = size(nums2)\n        min_num = huge(1_I8P)\n\n        ! loop over all possible combinations of digits\n        do i = 1, n1\n            do j = 1, n2\n                if (nums1(i) == nums2(j)) then\n                    min_num = min(min_num, nums1(i)*10 + nums2(j))\n                end if\n            end do\n        end do\n\n        ! check if there is no solution\n        if (min_num == huge(1_I8P)) then\n            stop \"No solution\"\n        end if\n\n        ! return the minimum number\n        min_num = min_num - mod(min_num, 10)\n\n    end function solve\n\nend program main",
  "2609": "program main\n    implicit none\n\n    character(len=50) :: s\n    integer :: i, j, n, m, max_len\n\n    ! Examples\n    s = \"01000111\"\n    write(*,*) \"Example 1:\"\n    write(*,*) \"Input:\", s\n    write(*,*) \"Output:\", longest_balanced_substring(s)\n    write(*,*) \"\"\n\n    s = \"00111\"\n    write(*,*) \"Example 2:\"\n    write(*,*) \"Input:\", s\n    write(*,*) \"Output:\", longest_balanced_substring(s)\n    write(*,*) \"\"\n\n    s = \"111\"\n    write(*,*) \"Example 3:\"\n    write(*,*) \"Input:\", s\n    write(*,*) \"Output:\", longest_balanced_substring(s)\n    write(*,*) \"\"\n\ncontains\n\n    function longest_balanced_substring(s) result(max_len)\n        implicit none\n        character(len=*), intent(in) :: s\n        integer :: i, j, n, m, max_len\n\n        max_len = 0\n        do i = 1, len(s) - 1\n            do j = i + 1, len(s)\n                if (is_balanced(s(i:j))) then\n                    max_len = max(max_len, j - i + 1)\n                end if\n            end do\n        end do\n    end function longest_balanced_substring\n\n    function is_balanced(s) result(res)\n        implicit none\n        character(len=*), intent(in) :: s\n        logical :: res\n\n        res = .true.\n        do i = 1, len(s)\n            if (s(i:i) == \"0\") then\n                if (any(s(i+1:) /= \"0\")) then\n                    res = .false.\n                    exit\n                end if\n            else if (s(i:i) == \"1\") then\n                if (any(s(i-1:) /= \"1\")) then\n                    res = .false.\n                    exit\n                end if\n            end if\n        end do\n    end function is_balanced\n\nend program main"
}
